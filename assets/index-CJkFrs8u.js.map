{"version":3,"mappings":"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","names":["AlgorithmType","MazeType","GRID_ROWS","GRID_COLS","DEFAULT_START_ROW","DEFAULT_START_COL","DEFAULT_FINISH_ROW","DEFAULT_FINISH_COL","createNode","row","col","startRow","startCol","finishRow","finishCol","getSafeNodePositions","rows","cols","getInitialGrid","grid","currentRow","getNewGridWithWallSet","newGrid","node","newNode","getNewGridWithWallRemoved","getNewGridWithStartMoved","newRow","newCol","targetNode","oldRow","oldCol","r","c","getNewGridWithFinishMoved","resetGridForPathfinding","clearWalls","defaultContextValue","GridContext","createContext","useGridContext","context","useContext","useGrid","GridProvider","children","rowCount","setRowCount","useState","colCount","setColCount","setGrid","isMousePressed","setIsMousePressed","isVisualizing","setIsVisualizing","selectedAlgorithm","setSelectedAlgorithm","selectedMaze","setSelectedMaze","isRaceMode","setIsRaceMode","secondAlgorithm","setSecondAlgorithm","animationSpeed","setAnimationSpeed","visualizationStats","setVisualizationStats","toastMsg","setToastMsg","showToast","useCallback","msg","clearToast","resetBoard","resizeGrid","newRows","newCols","clampedRows","clampedCols","clearPath","currentGrid","clearAllWalls","value","jsx","NodeComponent","memo","isStart","isFinish","isWall","isVisited","isPath","onMouseDown","onMouseEnter","onMouseUp","onTouchStart","getNodeClassName","classNames","styles","e","prevProps","nextProps","Board","containerRef","useRef","nodeSize","setNodeSize","isEraserModeRef","isMousePressedRef","isDraggingStartRef","isDraggingFinishRef","calculateNodeSize","container","containerWidth","containerHeight","availableWidth","availableHeight","maxSizeByWidth","maxSizeByHeight","calculatedSize","useEffect","resizeObserver","handleMouseDown","event","isEraserMode","handleTouchStart","handleMouseEnter","handleTouchMove","touch","element","nodeElement","handleTouchEnd","handleMouseUp","handleGlobalMouseUp","handleDragStart","handleContextMenu","boardStyle","Accordion","title","icon","defaultOpen","isOpen","setIsOpen","contentRef","contentHeight","setContentHeight","height","handleToggle","handleKeyDown","jsxs","ALGORITHM_OPTIONS","MAZE_OPTIONS","ControlPanel","onVisualize","onClearPath","onGenerateMaze","onVisualizeRace","handleAlgorithmChange","handleSecondAlgorithmChange","handleRaceModeToggle","newRaceMode","defaultSecond","handleVisualize","handleMazeChange","handleGenerateMaze","handleRowChange","handleColChange","handleSpeedChange","newSpeed","getSpeedLabel","option","Fragment","legendItems","Legend","orientation","compact","item","Toast","isExiting","setIsExiting","exitTimer","clearTimer","toastType","getIcon","toastClasses","useVisualization","isAnimating","timeoutIds","clearAllTimeouts","id","clearVisualizationClasses","visitedNodes","pathNodes","visitedNodesSecond","pathNodesSecond","overlapNodes","pathOverlapNodes","clearVisualization","animateVisitedNodes","visitedNodesInOrder","speed","onComplete","i","timeoutId","animateShortestPath","nodesInShortestPathOrder","visualizePathfinding","algorithm","_setGrid","statsCallbacks","algorithmGrid","startNode","finishNode","startTime","astar","getAstarPath","bfs","getBfsPath","dfs","getDfsPath","dijkstra","getNodesInShortestPathOrder","executionTime","pathFound","stats","pathDelay","clearWallClasses","animateMazeWalls","wallsInOrder","generateMaze","mazeType","resetGrid","clearedGrid","getRecursiveDivisionMaze","getRandomizedDFSMaze","wall","runAlgorithm","visualizeRace","algo1","algo2","createGridCopy","grid1","grid2","startNode1","finishNode1","startNode2","finishNode2","startTime1","result1","endTime1","startTime2","result2","endTime2","visited1","visited2","path1","path2","path1Found","path2Found","stats1","stats2","winner","raceStats","visitedByAgent1","visitedByAgent2","maxVisitedLen","node1","key1","element1","node2","key2","element2","path1Keys","path2Keys","maxPathLen","j","pathTimeoutId","pathNode1","pathNode2","StatisticsSection","lazy","MainContent","statsSectionRef","isSidebarOpen","setIsSidebarOpen","toggleSidebar","prev","closeSidebar","scrollToStats","_a","handleVisualizeRace","handleClearPath","Suspense","App","ReactDOM","React"],"ignoreList":[],"sources":["../../src/types/index.ts","../../src/utils/gridUtils.ts","../../src/context/GridContext.tsx","../../src/components/Node/NodeComponent.tsx","../../src/components/Board/Board.tsx","../../src/components/Controls/Accordion.tsx","../../src/components/Controls/ControlPanel.tsx","../../src/components/Legend/Legend.tsx","../../src/components/UI/Toast.tsx","../../src/hooks/useVisualization.ts","../../src/App.tsx","../../src/main.tsx"],"sourcesContent":["/**\r\n * Node Interface - Core data model for each cell in the grid\r\n * As specified in Section 3.1 of the project requirements\r\n */\r\nexport interface Node {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  distance: number; // For Dijkstra/A* - initialized to Infinity\r\n  previousNode: Node | null; // For backtracking the shortest path\r\n}\r\n\r\n/**\r\n * Grid Type - 2D array of Nodes\r\n */\r\nexport type Grid = Node[][];\r\n\r\n/**\r\n * Algorithm Types\r\n */\r\nexport enum AlgorithmType {\r\n  DIJKSTRA = 'dijkstra',\r\n  ASTAR = 'astar',\r\n  BFS = 'bfs',\r\n  DFS = 'dfs',\r\n}\r\n\r\n/**\r\n * Maze Generation Types\r\n */\r\nexport enum MazeType {\r\n  RECURSIVE_DIVISION = 'recursiveDivision',\r\n  RANDOMIZED_DFS = 'randomizedDFS',\r\n}\r\n\r\n/**\r\n * Node State for styling purposes\r\n */\r\nexport enum NodeState {\r\n  UNVISITED = 'unvisited',\r\n  VISITED = 'visited',\r\n  WALL = 'wall',\r\n  START = 'start',\r\n  FINISH = 'finish',\r\n  PATH = 'path',\r\n}\r\n\r\n/**\r\n * Algorithm Result - returned after algorithm execution\r\n */\r\nexport interface AlgorithmResult {\r\n  visitedNodesInOrder: Node[];\r\n  shortestPath: Node[];\r\n  executionTimeMs: number;\r\n  visitedCount: number;\r\n  pathLength: number;\r\n}\r\n\r\n/**\r\n * Grid Configuration Constants\r\n */\r\nexport const GRID_ROWS = 20;\r\nexport const GRID_COLS = 30;\r\nexport const DEFAULT_START_ROW = 10;\r\nexport const DEFAULT_START_COL = 5;\r\nexport const DEFAULT_FINISH_ROW = 10;\r\nexport const DEFAULT_FINISH_COL = 25;\r\n","import {\r\n  Node,\r\n  Grid,\r\n  GRID_ROWS,\r\n  GRID_COLS,\r\n  DEFAULT_START_ROW,\r\n  DEFAULT_START_COL,\r\n  DEFAULT_FINISH_ROW,\r\n  DEFAULT_FINISH_COL,\r\n} from '../types';\r\n\r\n/**\r\n * Creates a single Node with configurable start/finish positions\r\n */\r\nexport const createNode = (\r\n  row: number,\r\n  col: number,\r\n  startRow: number,\r\n  startCol: number,\r\n  finishRow: number,\r\n  finishCol: number\r\n): Node => {\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === startRow && col === startCol,\r\n    isFinish: row === finishRow && col === finishCol,\r\n    isWall: false,\r\n    isVisited: false,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\n/**\r\n * Calculates safe start/finish positions based on grid dimensions\r\n * Ensures nodes are placed within bounds with reasonable margins\r\n */\r\nexport const getSafeNodePositions = (\r\n  rows: number,\r\n  cols: number\r\n): { startRow: number; startCol: number; finishRow: number; finishCol: number } => {\r\n  // Start node: positioned at ~33% from top, ~10% from left\r\n  const startRow = Math.min(DEFAULT_START_ROW, Math.floor(rows * 0.33));\r\n  const startCol = Math.min(DEFAULT_START_COL, Math.max(1, Math.floor(cols * 0.1)));\r\n\r\n  // Finish node: positioned at ~33% from top, ~90% from left\r\n  const finishRow = Math.min(DEFAULT_FINISH_ROW, Math.floor(rows * 0.33));\r\n  const finishCol = Math.min(DEFAULT_FINISH_COL, Math.max(startCol + 2, Math.floor(cols * 0.9)));\r\n\r\n  return { startRow, startCol, finishRow, finishCol };\r\n};\r\n\r\n/**\r\n * Creates the initial grid with configurable dimensions\r\n * @param rows - Number of rows (default: GRID_ROWS = 30)\r\n * @param cols - Number of columns (default: GRID_COLS = 50)\r\n * Start and Finish nodes are placed safely within bounds\r\n */\r\nexport const getInitialGrid = (\r\n  rows: number = GRID_ROWS,\r\n  cols: number = GRID_COLS\r\n): Grid => {\r\n  const { startRow, startCol, finishRow, finishCol } = getSafeNodePositions(rows, cols);\r\n  const grid: Grid = [];\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    const currentRow: Node[] = [];\r\n    for (let col = 0; col < cols; col++) {\r\n      currentRow.push(createNode(row, col, startRow, startCol, finishRow, finishCol));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n\r\n  return grid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with a wall toggled at the specified position\r\n */\r\nexport const getNewGridWithWallToggled = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow walls on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with a wall SET at the specified position (Draw mode)\r\n * Used for consistent drag-to-draw functionality\r\n */\r\nexport const getNewGridWithWallSet = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow walls on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Already a wall, no change needed\r\n  if (node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: true,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with wall REMOVED at the specified position (Eraser mode)\r\n * Used for Ctrl+Click/Drag erasing functionality\r\n */\r\nexport const getNewGridWithWallRemoved = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't modify start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Not a wall, no change needed\r\n  if (!node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: false,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Moves the start node to a new position\r\n * Auto-finds current Start position and overwrites walls at new position\r\n */\r\nexport const getNewGridWithStartMoved = (\r\n  grid: Grid,\r\n  newRow: number,\r\n  newCol: number\r\n): Grid => {\r\n  const targetNode = grid[newRow][newCol];\r\n\r\n  // Can't move to finish node or if already start\r\n  if (targetNode.isFinish || targetNode.isStart) {\r\n    return grid;\r\n  }\r\n\r\n  // Find current start position\r\n  let oldRow = -1;\r\n  let oldCol = -1;\r\n  for (let r = 0; r < grid.length; r++) {\r\n    for (let c = 0; c < grid[r].length; c++) {\r\n      if (grid[r][c].isStart) {\r\n        oldRow = r;\r\n        oldCol = c;\r\n        break;\r\n      }\r\n    }\r\n    if (oldRow !== -1) break;\r\n  }\r\n\r\n  // Safety check\r\n  if (oldRow === -1) return grid;\r\n\r\n  const newGrid = grid.map((row) => row.slice());\r\n\r\n  // Remove start from old position\r\n  newGrid[oldRow][oldCol] = {\r\n    ...newGrid[oldRow][oldCol],\r\n    isStart: false,\r\n  };\r\n\r\n  // Set start at new position (overwrites wall if present)\r\n  newGrid[newRow][newCol] = {\r\n    ...newGrid[newRow][newCol],\r\n    isStart: true,\r\n    isWall: false,\r\n  };\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Moves the finish node to a new position\r\n * Auto-finds current Finish position and overwrites walls at new position\r\n */\r\nexport const getNewGridWithFinishMoved = (\r\n  grid: Grid,\r\n  newRow: number,\r\n  newCol: number\r\n): Grid => {\r\n  const targetNode = grid[newRow][newCol];\r\n\r\n  // Can't move to start node or if already finish\r\n  if (targetNode.isStart || targetNode.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Find current finish position\r\n  let oldRow = -1;\r\n  let oldCol = -1;\r\n  for (let r = 0; r < grid.length; r++) {\r\n    for (let c = 0; c < grid[r].length; c++) {\r\n      if (grid[r][c].isFinish) {\r\n        oldRow = r;\r\n        oldCol = c;\r\n        break;\r\n      }\r\n    }\r\n    if (oldRow !== -1) break;\r\n  }\r\n\r\n  // Safety check\r\n  if (oldRow === -1) return grid;\r\n\r\n  const newGrid = grid.map((row) => row.slice());\r\n\r\n  // Remove finish from old position\r\n  newGrid[oldRow][oldCol] = {\r\n    ...newGrid[oldRow][oldCol],\r\n    isFinish: false,\r\n  };\r\n\r\n  // Set finish at new position (overwrites wall if present)\r\n  newGrid[newRow][newCol] = {\r\n    ...newGrid[newRow][newCol],\r\n    isFinish: true,\r\n    isWall: false,\r\n  };\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Resets the grid for a new pathfinding run (clears visited/path states)\r\n * Keeps walls, start, and finish intact\r\n */\r\nexport const resetGridForPathfinding = (grid: Grid): Grid => {\r\n  return grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isVisited: false,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n    }))\r\n  );\r\n};\r\n\r\n/**\r\n * Clears all walls from the grid\r\n */\r\nexport const clearWalls = (grid: Grid): Grid => {\r\n  return grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isWall: false,\r\n    }))\r\n  );\r\n};\r\n\r\n/**\r\n * Completely resets the grid to initial state\r\n */\r\nexport const resetGrid = (): Grid => {\r\n  return getInitialGrid();\r\n};\r\n\r\n/**\r\n * Gets the node at a specific position\r\n */\r\nexport const getNode = (grid: Grid, row: number, col: number): Node | null => {\r\n  if (row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS) {\r\n    return null;\r\n  }\r\n  return grid[row][col];\r\n};\r\n\r\n/**\r\n * Gets all neighboring nodes (up, down, left, right)\r\n */\r\nexport const getNeighbors = (grid: Grid, node: Node): Node[] => {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]); // Up\r\n  if (row < GRID_ROWS - 1) neighbors.push(grid[row + 1][col]); // Down\r\n  if (col > 0) neighbors.push(grid[row][col - 1]); // Left\r\n  if (col < GRID_COLS - 1) neighbors.push(grid[row][col + 1]); // Right\r\n\r\n  return neighbors;\r\n};\r\n\r\n/**\r\n * Gets unvisited neighbors that are not walls\r\n */\r\nexport const getUnvisitedNeighbors = (grid: Grid, node: Node): Node[] => {\r\n  return getNeighbors(grid, node).filter(\r\n    (neighbor) => !neighbor.isVisited && !neighbor.isWall\r\n  );\r\n};\r\n","import React, {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useCallback,\r\n  ReactNode,\r\n} from \"react\";\r\nimport { Grid, AlgorithmType, MazeType, GRID_ROWS, GRID_COLS } from \"../types\";\r\nimport {\r\n  getInitialGrid,\r\n  resetGridForPathfinding,\r\n  clearWalls,\r\n} from \"../utils/gridUtils\";\r\nimport { AlgorithmStats, RaceStats } from \"../components/Modals/StatsModal\";\r\n\r\n/**\r\n * Grid Context Type Definition\r\n */\r\ninterface GridContextType {\r\n  // Grid State\r\n  grid: Grid;\r\n  setGrid: React.Dispatch<React.SetStateAction<Grid>>;\r\n\r\n  // Grid Dimensions\r\n  rowCount: number;\r\n  colCount: number;\r\n  resizeGrid: (newRows: number, newCols: number) => void;\r\n\r\n  // Mouse State (for wall drawing)\r\n  isMousePressed: boolean;\r\n  setIsMousePressed: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Visualization State\r\n  isVisualizing: boolean;\r\n  setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Algorithm Selection\r\n  selectedAlgorithm: AlgorithmType;\r\n  setSelectedAlgorithm: React.Dispatch<React.SetStateAction<AlgorithmType>>;\r\n\r\n  // Race Mode State\r\n  isRaceMode: boolean;\r\n  setIsRaceMode: React.Dispatch<React.SetStateAction<boolean>>;\r\n  secondAlgorithm: AlgorithmType | null;\r\n  setSecondAlgorithm: React.Dispatch<\r\n    React.SetStateAction<AlgorithmType | null>\r\n  >;\r\n\r\n  // Maze Selection\r\n  selectedMaze: MazeType | null;\r\n  setSelectedMaze: React.Dispatch<React.SetStateAction<MazeType | null>>;\r\n\r\n  // Speed Control (delay in ms)\r\n  animationSpeed: number;\r\n  setAnimationSpeed: React.Dispatch<React.SetStateAction<number>>;\r\n\r\n  // Visualization Stats (for Statistics Section)\r\n  visualizationStats: AlgorithmStats | RaceStats | null;\r\n  setVisualizationStats: React.Dispatch<\r\n    React.SetStateAction<AlgorithmStats | RaceStats | null>\r\n  >;\r\n\r\n  // Toast Notification State\r\n  toastMsg: string | null;\r\n  showToast: (msg: string) => void;\r\n  clearToast: () => void;\r\n\r\n  // Helper Functions\r\n  resetBoard: () => void;\r\n  clearPath: () => void;\r\n  clearAllWalls: () => void;\r\n}\r\n\r\n/**\r\n * Default Context Value\r\n */\r\nconst defaultContextValue: GridContextType = {\r\n  grid: [],\r\n  setGrid: () => {},\r\n  rowCount: GRID_ROWS,\r\n  colCount: GRID_COLS,\r\n  resizeGrid: () => {},\r\n  isMousePressed: false,\r\n  setIsMousePressed: () => {},\r\n  isVisualizing: false,\r\n  setIsVisualizing: () => {},\r\n  selectedAlgorithm: AlgorithmType.DIJKSTRA,\r\n  setSelectedAlgorithm: () => {},\r\n  isRaceMode: false,\r\n  setIsRaceMode: () => {},\r\n  secondAlgorithm: null,\r\n  setSecondAlgorithm: () => {},\r\n  selectedMaze: null,\r\n  setSelectedMaze: () => {},\r\n  animationSpeed: 10,\r\n  setAnimationSpeed: () => {},\r\n  visualizationStats: null,\r\n  setVisualizationStats: () => {},\r\n  toastMsg: null,\r\n  showToast: () => {},\r\n  clearToast: () => {},\r\n  resetBoard: () => {},\r\n  clearPath: () => {},\r\n  clearAllWalls: () => {},\r\n};\r\n\r\n/**\r\n * Create the Context\r\n */\r\nconst GridContext = createContext<GridContextType>(defaultContextValue);\r\n\r\n/**\r\n * Custom Hook to use Grid Context\r\n */\r\nexport const useGridContext = (): GridContextType => {\r\n  const context = useContext(GridContext);\r\n  if (!context) {\r\n    throw new Error(\"useGridContext must be used within a GridProvider\");\r\n  }\r\n  return context;\r\n};\r\n\r\n// Alias for shorter import in components\r\nexport const useGrid = useGridContext;\r\n\r\n/**\r\n * Provider Props\r\n */\r\ninterface GridProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\n/**\r\n * Grid Provider Component\r\n */\r\nexport const GridProvider: React.FC<GridProviderProps> = ({ children }) => {\r\n  // Grid Dimension State\r\n  const [rowCount, setRowCount] = useState<number>(GRID_ROWS);\r\n  const [colCount, setColCount] = useState<number>(GRID_COLS);\r\n\r\n  // Core Grid State\r\n  const [grid, setGrid] = useState<Grid>(() =>\r\n    getInitialGrid(GRID_ROWS, GRID_COLS)\r\n  );\r\n\r\n  // Mouse State for wall drawing\r\n  const [isMousePressed, setIsMousePressed] = useState<boolean>(false);\r\n\r\n  // Visualization State\r\n  const [isVisualizing, setIsVisualizing] = useState<boolean>(false);\r\n\r\n  // Algorithm Selection\r\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState<AlgorithmType>(\r\n    AlgorithmType.DIJKSTRA\r\n  );\r\n\r\n  // Maze Selection\r\n  const [selectedMaze, setSelectedMaze] = useState<MazeType | null>(null);\r\n\r\n  // Race Mode State\r\n  const [isRaceMode, setIsRaceMode] = useState<boolean>(false);\r\n  const [secondAlgorithm, setSecondAlgorithm] = useState<AlgorithmType | null>(\r\n    null\r\n  );\r\n\r\n  // Animation Speed (delay between node animations in ms)\r\n  const [animationSpeed, setAnimationSpeed] = useState<number>(10);\r\n\r\n  // Visualization Stats (displayed in Statistics Section)\r\n  const [visualizationStats, setVisualizationStats] = useState<\r\n    AlgorithmStats | RaceStats | null\r\n  >(null);\r\n\r\n  // Toast Notification State\r\n  const [toastMsg, setToastMsg] = useState<string | null>(null);\r\n\r\n  /**\r\n   * Shows a toast notification message\r\n   */\r\n  const showToast = useCallback((msg: string): void => {\r\n    setToastMsg(msg);\r\n  }, []);\r\n\r\n  /**\r\n   * Clears the current toast notification\r\n   */\r\n  const clearToast = useCallback((): void => {\r\n    setToastMsg(null);\r\n  }, []);\r\n\r\n  /**\r\n   * Resets the entire board to initial state with current dimensions\r\n   */\r\n  const resetBoard = useCallback((): void => {\r\n    if (isVisualizing) return; // Don't reset while visualizing\r\n    setGrid(getInitialGrid(rowCount, colCount));\r\n  }, [isVisualizing, rowCount, colCount]);\r\n\r\n  /**\r\n   * Resizes the grid to new dimensions\r\n   * Generates a completely new grid (walls are cleared)\r\n   */\r\n  const resizeGrid = useCallback(\r\n    (newRows: number, newCols: number): void => {\r\n      if (isVisualizing) return; // Don't resize while visualizing\r\n\r\n      // Clamp values to reasonable bounds\r\n      const clampedRows = Math.max(5, Math.min(50, newRows));\r\n      const clampedCols = Math.max(5, Math.min(80, newCols));\r\n\r\n      setRowCount(clampedRows);\r\n      setColCount(clampedCols);\r\n      setGrid(getInitialGrid(clampedRows, clampedCols));\r\n    },\r\n    [isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Clears only the path/visited nodes, keeps walls\r\n   */\r\n  const clearPath = useCallback((): void => {\r\n    if (isVisualizing) return;\r\n    setGrid((currentGrid) => resetGridForPathfinding(currentGrid));\r\n  }, [isVisualizing]);\r\n\r\n  /**\r\n   * Clears all walls from the grid\r\n   */\r\n  const clearAllWalls = useCallback((): void => {\r\n    if (isVisualizing) return;\r\n    setGrid((currentGrid) => clearWalls(currentGrid));\r\n  }, [isVisualizing]);\r\n\r\n  const value: GridContextType = {\r\n    grid,\r\n    setGrid,\r\n    rowCount,\r\n    colCount,\r\n    resizeGrid,\r\n    isMousePressed,\r\n    setIsMousePressed,\r\n    isVisualizing,\r\n    setIsVisualizing,\r\n    selectedAlgorithm,\r\n    setSelectedAlgorithm,\r\n    isRaceMode,\r\n    setIsRaceMode,\r\n    secondAlgorithm,\r\n    setSecondAlgorithm,\r\n    selectedMaze,\r\n    setSelectedMaze,\r\n    animationSpeed,\r\n    setAnimationSpeed,\r\n    visualizationStats,\r\n    setVisualizationStats,\r\n    toastMsg,\r\n    showToast,\r\n    clearToast,\r\n    resetBoard,\r\n    clearPath,\r\n    clearAllWalls,\r\n  };\r\n\r\n  return <GridContext.Provider value={value}>{children}</GridContext.Provider>;\r\n};\r\n\r\nexport default GridContext;\r\n","import React, { memo } from \"react\";\r\nimport styles from \"./Node.module.css\";\r\n\r\n/**\r\n * Props for the NodeComponent\r\n * Extends Node properties with event handlers\r\n */\r\nexport interface NodeComponentProps {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  isPath?: boolean; // For shortest path highlighting\r\n  onMouseDown: (row: number, col: number, event: React.MouseEvent) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n  onTouchStart?: (row: number, col: number, event: React.TouchEvent) => void;\r\n}\r\n\r\n/**\r\n * NodeComponent - Represents a single cell in the grid\r\n *\r\n * Wrapped in React.memo to prevent unnecessary re-renders\r\n * of all 1500 nodes during visualization updates.\r\n * Only re-renders when its own props change.\r\n */\r\nconst NodeComponent: React.FC<NodeComponentProps> = memo(\r\n  ({\r\n    row,\r\n    col,\r\n    isStart,\r\n    isFinish,\r\n    isWall,\r\n    isVisited,\r\n    isPath = false,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n    onMouseUp,\r\n    onTouchStart,\r\n  }) => {\r\n    /**\r\n     * Compute the dynamic class name based on node state\r\n     * Priority order: Start > Finish > Path > Wall > Visited > Default\r\n     */\r\n    const getNodeClassName = (): string => {\r\n      const classNames = [styles.node];\r\n\r\n      if (isStart) {\r\n        classNames.push(styles[\"node-start\"]);\r\n      } else if (isFinish) {\r\n        classNames.push(styles[\"node-finish\"]);\r\n      } else if (isPath) {\r\n        classNames.push(styles[\"node-path\"]);\r\n      } else if (isWall) {\r\n        classNames.push(styles[\"node-wall\"]);\r\n      } else if (isVisited) {\r\n        classNames.push(styles[\"node-visited\"]);\r\n      }\r\n\r\n      return classNames.join(\" \");\r\n    };\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={getNodeClassName()}\r\n        data-row={row}\r\n        data-col={col}\r\n        onMouseDown={(e) => onMouseDown(row, col, e)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={onMouseUp}\r\n        onTouchStart={\r\n          onTouchStart ? (e) => onTouchStart(row, col, e) : undefined\r\n        }\r\n        role=\"button\"\r\n        tabIndex={-1}\r\n        aria-label={`Node at row ${row}, column ${col}${\r\n          isStart ? \" (Start)\" : \"\"\r\n        }${isFinish ? \" (Finish)\" : \"\"}${isWall ? \" (Wall)\" : \"\"}`}\r\n      />\r\n    );\r\n  },\r\n  // Custom comparison function for memo\r\n  (prevProps, nextProps) => {\r\n    return (\r\n      prevProps.isStart === nextProps.isStart &&\r\n      prevProps.isFinish === nextProps.isFinish &&\r\n      prevProps.isWall === nextProps.isWall &&\r\n      prevProps.isVisited === nextProps.isVisited &&\r\n      prevProps.isPath === nextProps.isPath &&\r\n      prevProps.row === nextProps.row &&\r\n      prevProps.col === nextProps.col\r\n    );\r\n  }\r\n);\r\n\r\nNodeComponent.displayName = \"NodeComponent\";\r\n\r\nexport default NodeComponent;\r\n","import React, { useCallback, useRef, useEffect, useState } from \"react\";\r\nimport { useGridContext } from \"../../context/GridContext\";\r\nimport NodeComponent from \"../Node\";\r\nimport {\r\n  getNewGridWithWallSet,\r\n  getNewGridWithWallRemoved,\r\n  getNewGridWithStartMoved,\r\n  getNewGridWithFinishMoved,\r\n} from \"../../utils/gridUtils\";\r\nimport styles from \"./Board.module.css\";\r\n\r\n/**\r\n * Board Component - Renders the 2D grid of nodes\r\n *\r\n * Uses GridContext for state management and handles\r\n * mouse events for wall drawing functionality.\r\n *\r\n * Features:\r\n * - Dynamic node sizing based on container dimensions\r\n * - Standard Click/Drag: Draw walls\r\n * - Ctrl/Cmd + Click/Drag: Erase walls (Eraser mode)\r\n */\r\nconst Board: React.FC = () => {\r\n  const {\r\n    grid,\r\n    setGrid,\r\n    setIsMousePressed,\r\n    isVisualizing,\r\n    colCount,\r\n    rowCount,\r\n  } = useGridContext();\r\n\r\n  // Ref for the board container to measure available space\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Dynamic node size state\r\n  const [nodeSize, setNodeSize] = useState<number>(25);\r\n\r\n  // Track eraser mode - persists throughout the drag operation\r\n  const isEraserModeRef = useRef<boolean>(false);\r\n  // Track mouse pressed state with ref to avoid stale closure issues\r\n  const isMousePressedRef = useRef<boolean>(false);\r\n  // Track dragging Start node\r\n  const isDraggingStartRef = useRef<boolean>(false);\r\n  // Track dragging Finish node\r\n  const isDraggingFinishRef = useRef<boolean>(false);\r\n\r\n  /**\r\n   * Calculate and set the optimal node size based on container dimensions\r\n   * Ensures the entire grid fits without scrollbars\r\n   */\r\n  const calculateNodeSize = useCallback(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const container = containerRef.current;\r\n    const containerWidth = container.clientWidth;\r\n    const containerHeight = container.clientHeight;\r\n\r\n    // Account for border (2px on each side = 4px total)\r\n    const availableWidth = containerWidth - 4;\r\n    const availableHeight = containerHeight - 4;\r\n\r\n    // Calculate max size that fits both dimensions\r\n    const maxSizeByWidth = availableWidth / colCount;\r\n    const maxSizeByHeight = availableHeight / rowCount;\r\n\r\n    // Use the smaller value to ensure grid fits in both dimensions\r\n    // Floor to avoid sub-pixel rendering issues, min 10px for usability\r\n    const calculatedSize = Math.max(\r\n      10,\r\n      Math.floor(Math.min(maxSizeByWidth, maxSizeByHeight))\r\n    );\r\n\r\n    setNodeSize(calculatedSize);\r\n  }, [colCount, rowCount]);\r\n\r\n  /**\r\n   * ResizeObserver to recalculate node size when container changes\r\n   */\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    // Initial calculation\r\n    calculateNodeSize();\r\n\r\n    // Create ResizeObserver to watch for container size changes\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      calculateNodeSize();\r\n    });\r\n\r\n    resizeObserver.observe(container);\r\n\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [calculateNodeSize]);\r\n\r\n  /**\r\n   * Recalculate when grid dimensions change\r\n   */\r\n  useEffect(() => {\r\n    calculateNodeSize();\r\n  }, [rowCount, colCount, calculateNodeSize]);\r\n\r\n  /**\r\n   * Handle mouse down on a node - starts wall drawing/erasing or Start/Finish dragging\r\n   * Priority: Start node drag > Finish node drag > Wall drawing/erasing\r\n   * Ctrl/Cmd + Click activates eraser mode (for walls only)\r\n   */\r\n  const handleMouseDown = useCallback(\r\n    (row: number, col: number, event: React.MouseEvent): void => {\r\n      // Prevent default browser behavior (e.g., Ctrl+Click selection on Windows)\r\n      event.preventDefault();\r\n\r\n      if (isVisualizing) return;\r\n\r\n      const node = grid[row][col];\r\n      isMousePressedRef.current = true;\r\n      setIsMousePressed(true);\r\n\r\n      // Priority 1: Start node - begin dragging\r\n      if (node.isStart) {\r\n        isDraggingStartRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 2: Finish node - begin dragging\r\n      if (node.isFinish) {\r\n        isDraggingFinishRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 3: Wall drawing/erasing\r\n      const isEraserMode = event.ctrlKey || event.metaKey;\r\n      isEraserModeRef.current = isEraserMode;\r\n\r\n      // Use functional update to always get latest grid state\r\n      setGrid((currentGrid) => {\r\n        if (isEraserMode) {\r\n          return getNewGridWithWallRemoved(currentGrid, row, col);\r\n        } else {\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [grid, setGrid, setIsMousePressed, isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Handle touch start on a node - mobile equivalent of mousedown\r\n   * Starts wall drawing or Start/Finish dragging\r\n   */\r\n  const handleTouchStart = useCallback(\r\n    (row: number, col: number, event: React.TouchEvent): void => {\r\n      event.preventDefault(); // Prevent scrolling while drawing\r\n\r\n      if (isVisualizing) return;\r\n\r\n      const node = grid[row][col];\r\n      isMousePressedRef.current = true;\r\n      setIsMousePressed(true);\r\n      isEraserModeRef.current = false; // No eraser mode on touch\r\n\r\n      // Priority 1: Start node - begin dragging\r\n      if (node.isStart) {\r\n        isDraggingStartRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 2: Finish node - begin dragging\r\n      if (node.isFinish) {\r\n        isDraggingFinishRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 3: Wall drawing (toggle wall state)\r\n      setGrid((currentGrid) => {\r\n        const currentNode = currentGrid[row][col];\r\n        if (currentNode.isWall) {\r\n          return getNewGridWithWallRemoved(currentGrid, row, col);\r\n        } else {\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [grid, setGrid, setIsMousePressed, isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Handle mouse enter on a node - continues wall drawing/erasing or Start/Finish dragging\r\n   * Maintains the mode (draw/erase/drag) that was set on mouse down\r\n   */\r\n  const handleMouseEnter = useCallback(\r\n    (row: number, col: number): void => {\r\n      // Use ref to check mouse state to avoid stale closure\r\n      if (!isMousePressedRef.current || isVisualizing) return;\r\n\r\n      // Handle Start node dragging\r\n      if (isDraggingStartRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithStartMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle Finish node dragging\r\n      if (isDraggingFinishRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithFinishMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle wall drawing/erasing\r\n      setGrid((currentGrid) => {\r\n        if (isEraserModeRef.current) {\r\n          return getNewGridWithWallRemoved(currentGrid, row, col);\r\n        } else {\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [setGrid, isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Handle touch move - mobile equivalent of mouseenter\r\n   * Uses document.elementFromPoint to find which node is under the finger\r\n   */\r\n  const handleTouchMove = useCallback(\r\n    (event: React.TouchEvent): void => {\r\n      if (!isMousePressedRef.current || isVisualizing) return;\r\n\r\n      const touch = event.touches[0];\r\n      const element = document.elementFromPoint(touch.clientX, touch.clientY);\r\n\r\n      if (!element) return;\r\n\r\n      // Find the node element (may be the element or a parent)\r\n      const nodeElement = element.closest(\"[data-row][data-col]\");\r\n      if (!nodeElement) return;\r\n\r\n      const row = parseInt(nodeElement.getAttribute(\"data-row\") || \"-1\", 10);\r\n      const col = parseInt(nodeElement.getAttribute(\"data-col\") || \"-1\", 10);\r\n\r\n      if (row < 0 || col < 0 || row >= rowCount || col >= colCount) return;\r\n\r\n      // Handle Start node dragging\r\n      if (isDraggingStartRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithStartMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle Finish node dragging\r\n      if (isDraggingFinishRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithFinishMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle wall drawing (always add walls on touch move)\r\n      setGrid((currentGrid) => getNewGridWithWallSet(currentGrid, row, col));\r\n    },\r\n    [setGrid, isVisualizing, rowCount, colCount]\r\n  );\r\n\r\n  /**\r\n   * Handle touch end - mobile equivalent of mouseup\r\n   */\r\n  const handleTouchEnd = useCallback((): void => {\r\n    isMousePressedRef.current = false;\r\n    isEraserModeRef.current = false;\r\n    isDraggingStartRef.current = false;\r\n    isDraggingFinishRef.current = false;\r\n    setIsMousePressed(false);\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Handle mouse up - stops all interactions (wall drawing/erasing, Start/Finish dragging)\r\n   * Resets all mode refs for the next interaction\r\n   */\r\n  const handleMouseUp = useCallback((): void => {\r\n    isMousePressedRef.current = false;\r\n    isEraserModeRef.current = false;\r\n    isDraggingStartRef.current = false;\r\n    isDraggingFinishRef.current = false;\r\n    setIsMousePressed(false);\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Global mouseup listener to handle edge cases where mouseup\r\n   * fires outside of any node (e.g., clicking on tile edges)\r\n   */\r\n  useEffect(() => {\r\n    const handleGlobalMouseUp = (): void => {\r\n      if (isMousePressedRef.current) {\r\n        isMousePressedRef.current = false;\r\n        isEraserModeRef.current = false;\r\n        isDraggingStartRef.current = false;\r\n        isDraggingFinishRef.current = false;\r\n        setIsMousePressed(false);\r\n      }\r\n    };\r\n\r\n    // Listen to mouseup on the entire document\r\n    document.addEventListener(\"mouseup\", handleGlobalMouseUp);\r\n\r\n    return () => {\r\n      document.removeEventListener(\"mouseup\", handleGlobalMouseUp);\r\n    };\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Prevent default drag behavior on the board\r\n   */\r\n  const handleDragStart = (e: React.DragEvent): void => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Prevent context menu on right-click or Ctrl+click\r\n   */\r\n  const handleContextMenu = (e: React.MouseEvent): void => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  // Dynamic grid styling with calculated node size\r\n  const boardStyle: React.CSSProperties = {\r\n    display: \"grid\",\r\n    gridTemplateColumns: `repeat(${colCount}, ${nodeSize}px)`,\r\n    gridTemplateRows: `repeat(${rowCount}, ${nodeSize}px)`,\r\n    // Set CSS variable for node components to use\r\n    [\"--node-size\" as string]: `${nodeSize}px`,\r\n  };\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={styles.boardContainer}\r\n      onMouseLeave={handleMouseUp}\r\n      onDragStart={handleDragStart}\r\n      onContextMenu={handleContextMenu}\r\n      onTouchMove={handleTouchMove}\r\n      onTouchEnd={handleTouchEnd}\r\n    >\r\n      {/* eslint-disable-next-line react/forbid-dom-props */}\r\n      <div\r\n        className={styles.board}\r\n        style={boardStyle}\r\n        role=\"presentation\"\r\n        aria-label=\"Pathfinding Grid\"\r\n      >\r\n        {grid.map((row) =>\r\n          row.map((node) => (\r\n            <NodeComponent\r\n              key={`${node.row}-${node.col}`}\r\n              row={node.row}\r\n              col={node.col}\r\n              isStart={node.isStart}\r\n              isFinish={node.isFinish}\r\n              isWall={node.isWall}\r\n              isVisited={node.isVisited}\r\n              onMouseDown={handleMouseDown}\r\n              onMouseEnter={handleMouseEnter}\r\n              onMouseUp={handleMouseUp}\r\n              onTouchStart={handleTouchStart}\r\n            />\r\n          ))\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Board;\r\n","/**\r\n * Accordion Component\r\n * Reusable collapsible section for grouped controls\r\n * \r\n * Features:\r\n * - Smooth expand/collapse animation\r\n * - Chevron icon rotation\r\n * - Dark minimalist styling\r\n * - Accessible keyboard navigation\r\n */\r\n\r\nimport React, { useState, useRef, useEffect } from 'react';\r\nimport styles from './Accordion.module.css';\r\n\r\ninterface AccordionProps {\r\n  title: string;\r\n  icon?: string;\r\n  children: React.ReactNode;\r\n  defaultOpen?: boolean;\r\n}\r\n\r\nconst Accordion: React.FC<AccordionProps> = ({ \r\n  title, \r\n  icon, \r\n  children, \r\n  defaultOpen = false \r\n}) => {\r\n  const [isOpen, setIsOpen] = useState(defaultOpen);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [contentHeight, setContentHeight] = useState<number | undefined>(\r\n    defaultOpen ? undefined : 0\r\n  );\r\n\r\n  // Update height when content changes or accordion opens/closes\r\n  useEffect(() => {\r\n    if (contentRef.current) {\r\n      const height = contentRef.current.scrollHeight;\r\n      setContentHeight(isOpen ? height : 0);\r\n    }\r\n  }, [isOpen, children]);\r\n\r\n  const handleToggle = () => {\r\n    setIsOpen(!isOpen);\r\n  };\r\n\r\n  const handleKeyDown = (e: React.KeyboardEvent) => {\r\n    if (e.key === 'Enter' || e.key === ' ') {\r\n      e.preventDefault();\r\n      handleToggle();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.accordion} ${isOpen ? styles.open : ''}`}>\r\n      <button\r\n        className={styles.header}\r\n        onClick={handleToggle}\r\n        onKeyDown={handleKeyDown}\r\n        aria-expanded={isOpen ? \"true\" : \"false\"}\r\n        type=\"button\"\r\n      >\r\n        <span className={styles.titleWrapper}>\r\n          {icon && <span className={styles.icon}>{icon}</span>}\r\n          <span className={styles.title}>{title}</span>\r\n        </span>\r\n        <svg\r\n          className={`${styles.chevron} ${isOpen ? styles.chevronOpen : ''}`}\r\n          width=\"16\"\r\n          height=\"16\"\r\n          viewBox=\"0 0 16 16\"\r\n          fill=\"none\"\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n        >\r\n          <path\r\n            d=\"M4 6L8 10L12 6\"\r\n            stroke=\"currentColor\"\r\n            strokeWidth=\"2\"\r\n            strokeLinecap=\"round\"\r\n            strokeLinejoin=\"round\"\r\n          />\r\n        </svg>\r\n      </button>\r\n      <div\r\n        className={styles.contentWrapper}\r\n        style={{ height: contentHeight !== undefined ? `${contentHeight}px` : 'auto' }}\r\n      >\r\n        <div ref={contentRef} className={styles.content}>\r\n          {children}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Accordion;\r\n","/**\r\n * ControlPanel Component\r\n * Professional sidebar with grouped accordion sections\r\n *\r\n * Redesigned with clean, minimalist UI featuring:\r\n * - Collapsible accordion sections\r\n * - Logical grouping of controls\r\n * - Prominent primary CTA\r\n * - Dark theme with subtle accents\r\n */\r\n\r\nimport React from 'react';\r\nimport { useGridContext } from '../../context/GridContext';\r\nimport { AlgorithmType, MazeType } from '../../types';\r\nimport Accordion from './Accordion';\r\nimport styles from './ControlPanel.module.css';\r\n\r\n/**\r\n * Props for the ControlPanel component\r\n */\r\ninterface ControlPanelProps {\r\n  onVisualize: () => void;\r\n  onClearPath: () => void;\r\n  onGenerateMaze: (mazeType: MazeType) => void;\r\n  onVisualizeRace: () => void;\r\n}\r\n\r\n/**\r\n * Algorithm options for the dropdown\r\n */\r\nconst ALGORITHM_OPTIONS: { value: AlgorithmType; label: string }[] = [\r\n  { value: AlgorithmType.DIJKSTRA, label: \"Dijkstra's Algorithm\" },\r\n  { value: AlgorithmType.ASTAR, label: 'A* Search' },\r\n  { value: AlgorithmType.BFS, label: 'Breadth-First Search' },\r\n  { value: AlgorithmType.DFS, label: 'Depth-First Search' },\r\n];\r\n\r\n/**\r\n * Maze generation options for the dropdown\r\n */\r\nconst MAZE_OPTIONS: { value: MazeType | 'none'; label: string }[] = [\r\n  { value: 'none', label: 'Select a maze type...' },\r\n  { value: MazeType.RECURSIVE_DIVISION, label: 'Recursive Division' },\r\n  { value: MazeType.RANDOMIZED_DFS, label: 'Randomized DFS' },\r\n];\r\n\r\n/**\r\n * ControlPanel - Redesigned sidebar with accordion groups\r\n */\r\nconst ControlPanel: React.FC<ControlPanelProps> = ({\r\n  onVisualize,\r\n  onClearPath,\r\n  onGenerateMaze,\r\n  onVisualizeRace,\r\n}) => {\r\n  const {\r\n    selectedAlgorithm,\r\n    setSelectedAlgorithm,\r\n    selectedMaze,\r\n    setSelectedMaze,\r\n    isVisualizing,\r\n    isRaceMode,\r\n    setIsRaceMode,\r\n    secondAlgorithm,\r\n    setSecondAlgorithm,\r\n    rowCount,\r\n    colCount,\r\n    resizeGrid,\r\n    resetBoard,\r\n    clearAllWalls,\r\n    animationSpeed,\r\n    setAnimationSpeed,\r\n  } = useGridContext();\r\n\r\n  // === Handlers ===\r\n\r\n  const handleAlgorithmChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {\r\n    setSelectedAlgorithm(e.target.value as AlgorithmType);\r\n  };\r\n\r\n  const handleSecondAlgorithmChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {\r\n    setSecondAlgorithm(e.target.value as AlgorithmType);\r\n  };\r\n\r\n  const handleRaceModeToggle = (): void => {\r\n    if (isVisualizing) return;\r\n    const newRaceMode = !isRaceMode;\r\n    setIsRaceMode(newRaceMode);\r\n    if (newRaceMode && !secondAlgorithm) {\r\n      const defaultSecond =\r\n        selectedAlgorithm === AlgorithmType.DIJKSTRA\r\n          ? AlgorithmType.ASTAR\r\n          : AlgorithmType.DIJKSTRA;\r\n      setSecondAlgorithm(defaultSecond);\r\n    }\r\n  };\r\n\r\n  const handleVisualize = (): void => {\r\n    if (isRaceMode && secondAlgorithm) {\r\n      onVisualizeRace();\r\n    } else {\r\n      onVisualize();\r\n    }\r\n  };\r\n\r\n  const handleMazeChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {\r\n    const value = e.target.value;\r\n    setSelectedMaze(value === 'none' ? null : (value as MazeType));\r\n  };\r\n\r\n  const handleGenerateMaze = (): void => {\r\n    if (selectedMaze) {\r\n      onGenerateMaze(selectedMaze);\r\n    }\r\n  };\r\n\r\n  const handleRowChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newRows = parseInt(e.target.value, 10);\r\n    resizeGrid(newRows, colCount);\r\n  };\r\n\r\n  const handleColChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newCols = parseInt(e.target.value, 10);\r\n    resizeGrid(rowCount, newCols);\r\n  };\r\n\r\n  const handleSpeedChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newSpeed = parseInt(e.target.value, 10);\r\n    setAnimationSpeed(newSpeed);\r\n  };\r\n\r\n  const getSpeedLabel = (): string => {\r\n    if (animationSpeed <= 5) return 'Very Fast';\r\n    if (animationSpeed <= 10) return 'Fast';\r\n    if (animationSpeed <= 20) return 'Normal';\r\n    if (animationSpeed <= 40) return 'Slow';\r\n    return 'Very Slow';\r\n  };\r\n\r\n  return (\r\n    <aside className={styles.panel}>\r\n      {/* Panel Header */}\r\n      <header className={styles.panelHeader}>\r\n        <h2 className={styles.panelTitle}>Controls</h2>\r\n        <p className={styles.panelSubtitle}>Configure & Visualize</p>\r\n      </header>\r\n\r\n      {/* Accordion Sections */}\r\n      <div className={styles.accordionContainer}>\r\n        {/* === Section 1: Pathfinding Algorithms === */}\r\n        <Accordion title=\"Pathfinding Algorithms\" icon=\"\" defaultOpen={true}>\r\n          {/* Algorithm Selection */}\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>Algorithm</label>\r\n            <select\r\n              value={selectedAlgorithm}\r\n              onChange={handleAlgorithmChange}\r\n              disabled={isVisualizing}\r\n              className={styles.select}\r\n              title=\"Select pathfinding algorithm\"\r\n            >\r\n              {ALGORITHM_OPTIONS.map((option) => (\r\n                <option key={option.value} value={option.value}>\r\n                  {option.label}\r\n                </option>\r\n              ))}\r\n            </select>\r\n          </div>\r\n\r\n          {/* Race Mode Toggle */}\r\n          <div className={styles.toggleRow}>\r\n            <span className={styles.toggleLabel}> Race Mode</span>\r\n            <button\r\n              type=\"button\"\r\n              className={`${styles.toggle} ${isRaceMode ? styles.toggleActive : ''}`}\r\n              onClick={handleRaceModeToggle}\r\n              disabled={isVisualizing}\r\n              aria-pressed={isRaceMode ? \"true\" : \"false\"}\r\n              title=\"Toggle race mode to compare two algorithms\"\r\n            >\r\n              <span className={styles.toggleKnob} />\r\n            </button>\r\n          </div>\r\n\r\n          {/* Second Algorithm (Race Mode) */}\r\n          {isRaceMode && (\r\n            <div className={styles.controlGroup}>\r\n              <label className={styles.labelSecondary}>Agent 2 Algorithm</label>\r\n              <select\r\n                value={secondAlgorithm || ''}\r\n                onChange={handleSecondAlgorithmChange}\r\n                disabled={isVisualizing}\r\n                className={`${styles.select} ${styles.selectSecondary}`}\r\n                title=\"Select second algorithm for race mode\"\r\n              >\r\n                {ALGORITHM_OPTIONS.map((option) => (\r\n                  <option\r\n                    key={option.value}\r\n                    value={option.value}\r\n                    disabled={option.value === selectedAlgorithm}\r\n                  >\r\n                    {option.label}\r\n                    {option.value === selectedAlgorithm ? ' (Agent 1)' : ''}\r\n                  </option>\r\n                ))}\r\n              </select>\r\n            </div>\r\n          )}\r\n\r\n          {/* Primary CTA - Visualize Button */}\r\n          <button\r\n            onClick={handleVisualize}\r\n            disabled={isVisualizing || (isRaceMode && !secondAlgorithm)}\r\n            className={`${styles.buttonPrimary} ${isRaceMode ? styles.buttonRace : ''}`}\r\n          >\r\n            {isVisualizing ? (\r\n              <>\r\n                <span className={styles.spinner} />\r\n                Visualizing...\r\n              </>\r\n            ) : isRaceMode ? (\r\n              ' Start Race!'\r\n            ) : (\r\n              ' Visualize!'\r\n            )}\r\n          </button>\r\n        </Accordion>\r\n\r\n        {/* === Section 2: Maze Generation === */}\r\n        <Accordion title=\"Maze Generation\" icon=\"\">\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>Maze Type</label>\r\n            <select\r\n              value={selectedMaze || 'none'}\r\n              onChange={handleMazeChange}\r\n              disabled={isVisualizing}\r\n              className={styles.select}\r\n              title=\"Select maze generation algorithm\"\r\n            >\r\n              {MAZE_OPTIONS.map((option) => (\r\n                <option key={option.value} value={option.value}>\r\n                  {option.label}\r\n                </option>\r\n              ))}\r\n            </select>\r\n          </div>\r\n\r\n          <button\r\n            onClick={handleGenerateMaze}\r\n            disabled={isVisualizing || !selectedMaze}\r\n            className={styles.buttonSecondary}\r\n          >\r\n             Generate Maze\r\n          </button>\r\n\r\n          <button\r\n            onClick={clearAllWalls}\r\n            disabled={isVisualizing}\r\n            className={styles.buttonGhost}\r\n          >\r\n             Clear All Walls\r\n          </button>\r\n        </Accordion>\r\n\r\n        {/* === Section 3: Grid Settings === */}\r\n        <Accordion title=\"Grid Settings\" icon=\"\">\r\n          {/* Speed Control */}\r\n          <div className={styles.controlGroup}>\r\n            <div className={styles.sliderHeader}>\r\n              <label className={styles.label}>Animation Speed</label>\r\n              <span className={styles.sliderValue}>{getSpeedLabel()}</span>\r\n            </div>\r\n            <input\r\n              type=\"range\"\r\n              min=\"1\"\r\n              max=\"50\"\r\n              value={animationSpeed}\r\n              onChange={handleSpeedChange}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Adjust animation speed\"\r\n            />\r\n            <div className={styles.sliderLabels}>\r\n              <span>Fast</span>\r\n              <span>Slow</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Row Count */}\r\n          <div className={styles.controlGroup}>\r\n            <div className={styles.sliderHeader}>\r\n              <label className={styles.label}>Rows</label>\r\n              <span className={styles.sliderValue}>{rowCount}</span>\r\n            </div>\r\n            <input\r\n              type=\"range\"\r\n              min=\"5\"\r\n              max=\"40\"\r\n              value={rowCount}\r\n              onChange={handleRowChange}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Adjust number of rows\"\r\n            />\r\n          </div>\r\n\r\n          {/* Column Count */}\r\n          <div className={styles.controlGroup}>\r\n            <div className={styles.sliderHeader}>\r\n              <label className={styles.label}>Columns</label>\r\n              <span className={styles.sliderValue}>{colCount}</span>\r\n            </div>\r\n            <input\r\n              type=\"range\"\r\n              min=\"5\"\r\n              max=\"60\"\r\n              value={colCount}\r\n              onChange={handleColChange}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Adjust number of columns\"\r\n            />\r\n          </div>\r\n\r\n          {/* Board Actions */}\r\n          <div className={styles.buttonRow}>\r\n            <button\r\n              onClick={onClearPath}\r\n              disabled={isVisualizing}\r\n              className={styles.buttonGhost}\r\n            >\r\n              Clear Path\r\n            </button>\r\n            <button\r\n              onClick={resetBoard}\r\n              disabled={isVisualizing}\r\n              className={styles.buttonGhost}\r\n            >\r\n              Reset Board\r\n            </button>\r\n          </div>\r\n        </Accordion>\r\n      </div>\r\n\r\n      {/* Footer Instructions */}\r\n      <footer className={styles.footer}>\r\n        <div className={styles.instructionTitle}>Quick Tips</div>\r\n        <ul className={styles.instructionList}>\r\n          <li>\r\n            <kbd>Click</kbd> + drag to draw walls\r\n          </li>\r\n          <li>\r\n            <kbd>Ctrl</kbd> + click to erase\r\n          </li>\r\n          <li>Drag <span className={styles.nodeHint}></span> or <span className={styles.nodeHint}></span> to move</li>\r\n        </ul>\r\n      </footer>\r\n    </aside>\r\n  );\r\n};\r\n\r\nexport default ControlPanel;\r\n","/**\r\n * Legend Component\r\n * Displays color legend for grid node types\r\n *\r\n * Shows all possible node states with their corresponding colors\r\n */\r\n\r\nimport React from \"react\";\r\nimport styles from \"./Legend.module.css\";\r\n\r\ninterface LegendItem {\r\n  label: string;\r\n  color?: string;\r\n  gradient?: string;\r\n  border?: string;\r\n}\r\n\r\nconst legendItems: LegendItem[] = [\r\n  { label: \"Start\", color: \"#4caf50\", border: \"2px solid #2e7d32\" },\r\n  { label: \"Target\", color: \"#f44336\", border: \"2px solid #c62828\" },\r\n  { label: \"Wall\", color: \"#34495e\", border: \"2px solid #2c3e50\" },\r\n  {\r\n    label: \"Visited (A1)\",\r\n    gradient: \"linear-gradient(135deg, #00bcd4 0%, #9c27b0 100%)\",\r\n  },\r\n  {\r\n    label: \"Visited (A2)\",\r\n    gradient: \"linear-gradient(135deg, #ff9800 0%, #f44336 100%)\",\r\n  },\r\n  { label: \"Path (A1)\", color: \"#ffeb3b\", border: \"2px solid #f9a825\" },\r\n  { label: \"Path (A2)\", color: \"#00e5ff\", border: \"2px solid #00acc1\" },\r\n  { label: \"Overlap\", color: \"#76ff03\", border: \"2px solid #64dd17\" },\r\n];\r\n\r\ninterface LegendProps {\r\n  orientation?: \"horizontal\" | \"vertical\";\r\n  compact?: boolean;\r\n}\r\n\r\nconst Legend: React.FC<LegendProps> = ({\r\n  orientation = \"horizontal\",\r\n  compact = false,\r\n}) => {\r\n  return (\r\n    <div\r\n      className={`${styles.legend} ${styles[orientation]} ${\r\n        compact ? styles.compact : \"\"\r\n      }`}\r\n      role=\"region\"\r\n      aria-label=\"Color Legend\"\r\n    >\r\n      <span className={styles.title}>Legend:</span>\r\n      <div className={styles.items}>\r\n        {legendItems.map((item) => (\r\n          <div key={item.label} className={styles.item}>\r\n            {/* eslint-disable-next-line react/forbid-dom-props */}\r\n            <div\r\n              className={styles.colorBox}\r\n              style={{\r\n                background: item.gradient || item.color,\r\n                border: item.border || \"none\",\r\n              }}\r\n              aria-hidden=\"true\"\r\n            />\r\n            <span className={styles.label}>{item.label}</span>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Legend;\r\n","import { useEffect, useState } from \"react\";\r\nimport { useGrid } from \"../../context/GridContext\";\r\nimport styles from \"./Toast.module.css\";\r\n\r\n/**\r\n * Toast Notification Component\r\n * Displays slide-up notifications at bottom-center of screen\r\n * Auto-dismisses after 3 seconds with exit animation\r\n */\r\nconst Toast = () => {\r\n  const { toastMsg, clearToast } = useGrid();\r\n  const [isExiting, setIsExiting] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!toastMsg) {\r\n      setIsExiting(false);\r\n      return;\r\n    }\r\n\r\n    // Start exit animation after 2.7s, then clear after 3s total\r\n    const exitTimer = setTimeout(() => {\r\n      setIsExiting(true);\r\n    }, 2700);\r\n\r\n    const clearTimer = setTimeout(() => {\r\n      clearToast();\r\n      setIsExiting(false);\r\n    }, 3000);\r\n\r\n    return () => {\r\n      clearTimeout(exitTimer);\r\n      clearTimeout(clearTimer);\r\n    };\r\n  }, [toastMsg, clearToast]);\r\n\r\n  if (!toastMsg) return null;\r\n\r\n  // Determine toast type based on message content\r\n  const getToastType = (): \"error\" | \"warning\" | \"success\" | undefined => {\r\n    if (\r\n      toastMsg.toLowerCase().includes(\"unreachable\") ||\r\n      toastMsg.toLowerCase().includes(\"no path\")\r\n    ) {\r\n      return \"error\";\r\n    }\r\n    if (toastMsg.toLowerCase().includes(\"warning\")) {\r\n      return \"warning\";\r\n    }\r\n    if (\r\n      toastMsg.toLowerCase().includes(\"success\") ||\r\n      toastMsg.toLowerCase().includes(\"complete\")\r\n    ) {\r\n      return \"success\";\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  const toastType = getToastType();\r\n\r\n  // Icon based on type\r\n  const getIcon = () => {\r\n    switch (toastType) {\r\n      case \"error\":\r\n        return \"\";\r\n      case \"warning\":\r\n        return \"\";\r\n      case \"success\":\r\n        return \"\";\r\n      default:\r\n        return \"\";\r\n    }\r\n  };\r\n\r\n  const toastClasses = [\r\n    styles.toast,\r\n    toastType ? styles[toastType] : \"\",\r\n    isExiting ? styles.exiting : \"\",\r\n  ]\r\n    .filter(Boolean)\r\n    .join(\" \");\r\n\r\n  return (\r\n    <div className={styles.toastContainer}>\r\n      <div className={toastClasses} role=\"alert\" aria-live=\"polite\">\r\n        <span className={styles.icon}>{getIcon()}</span>\r\n        <span className={styles.message}>{toastMsg}</span>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Toast;\r\n","/**\r\n * useVisualization Hook\r\n * Phase B & C: Animation System for Pathfinding and Maze Generation\r\n *\r\n * Uses direct DOM manipulation for performance (1000+ nodes).\r\n * Does NOT use React setState inside animation loops.\r\n */\r\n\r\nimport { useCallback, useRef } from \"react\";\r\nimport { Grid, Node, MazeType, AlgorithmType } from \"../types\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/pathfinding/dijkstra\";\r\nimport {\r\n  astar,\r\n  getNodesInShortestPathOrder as getAstarPath,\r\n} from \"../algorithms/pathfinding/astar\";\r\nimport {\r\n  bfs,\r\n  getNodesInShortestPathOrder as getBfsPath,\r\n} from \"../algorithms/pathfinding/bfs\";\r\nimport {\r\n  dfs,\r\n  getNodesInShortestPathOrder as getDfsPath,\r\n} from \"../algorithms/pathfinding/dfs\";\r\nimport { getRecursiveDivisionMaze } from \"../algorithms/maze/recursiveDivision\";\r\nimport { getRandomizedDFSMaze } from \"../algorithms/maze/randomizedDFS\";\r\nimport { resetGridForPathfinding, clearWalls } from \"../utils/gridUtils\";\r\nimport { AlgorithmStats, RaceStats } from \"../components/Modals/StatsModal\";\r\n\r\n/**\r\n * Callbacks for stats and scroll behavior\r\n */\r\ninterface StatsCallbacks {\r\n  setVisualizationStats: React.Dispatch<\r\n    React.SetStateAction<AlgorithmStats | RaceStats | null>\r\n  >;\r\n  scrollToStats: () => void;\r\n  showToast?: (msg: string) => void;\r\n}\r\n\r\n/**\r\n * Return type for the useVisualization hook\r\n */\r\ninterface UseVisualizationReturn {\r\n  visualizePathfinding: (\r\n    algorithm: AlgorithmType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number,\r\n    statsCallbacks?: StatsCallbacks\r\n  ) => void;\r\n  visualizeRace: (\r\n    algo1: AlgorithmType,\r\n    algo2: AlgorithmType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number,\r\n    statsCallbacks?: StatsCallbacks\r\n  ) => void;\r\n  generateMaze: (\r\n    mazeType: MazeType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number\r\n  ) => void;\r\n  clearVisualization: (\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>\r\n  ) => void;\r\n  isAnimating: React.MutableRefObject<boolean>;\r\n}\r\n\r\n/**\r\n * Custom hook for managing pathfinding visualization animations\r\n *\r\n * Key Design Decisions:\r\n * - Direct DOM manipulation via getElementById (bypasses React for performance)\r\n * - setTimeout-based animation queue (non-blocking UI)\r\n * - CSS class toggling for visual effects\r\n * - Ref-based animation state to prevent stale closures\r\n */\r\nexport const useVisualization = (): UseVisualizationReturn => {\r\n  // Track animation state with ref (not state - to avoid stale closures)\r\n  const isAnimating = useRef<boolean>(false);\r\n  // Store timeout IDs for cleanup\r\n  const timeoutIds = useRef<ReturnType<typeof setTimeout>[]>([]);\r\n\r\n  /**\r\n   * Clears all pending animation timeouts\r\n   */\r\n  const clearAllTimeouts = useCallback((): void => {\r\n    timeoutIds.current.forEach((id) => clearTimeout(id));\r\n    timeoutIds.current = [];\r\n  }, []);\r\n\r\n  /**\r\n   * Removes visualization CSS classes from all nodes via DOM\r\n   * SIMPLIFIED: Only handles basic visited/path classes\r\n   */\r\n  const clearVisualizationClasses = useCallback((): void => {\r\n    // Remove visited and path classes from all nodes (both agents)\r\n    const visitedNodes = document.querySelectorAll(\".node-visited\");\r\n    const pathNodes = document.querySelectorAll(\".node-path\");\r\n    const visitedNodesSecond = document.querySelectorAll(\r\n      \".node-visited-second\"\r\n    );\r\n    const pathNodesSecond = document.querySelectorAll(\".node-path-second\");\r\n    const overlapNodes = document.querySelectorAll(\".node-visited-overlap\");\r\n    // Simple path overlap class (for mixed color)\r\n    const pathOverlapNodes = document.querySelectorAll(\".node-path-overlap\");\r\n\r\n    visitedNodes.forEach((node) => {\r\n      node.classList.remove(\"node-visited\");\r\n    });\r\n\r\n    pathNodes.forEach((node) => {\r\n      node.classList.remove(\"node-path\");\r\n    });\r\n\r\n    visitedNodesSecond.forEach((node) => {\r\n      node.classList.remove(\"node-visited-second\");\r\n    });\r\n\r\n    pathNodesSecond.forEach((node) => {\r\n      node.classList.remove(\"node-path-second\");\r\n    });\r\n\r\n    overlapNodes.forEach((node) => {\r\n      node.classList.remove(\"node-visited-overlap\");\r\n    });\r\n\r\n    // Clear simple path overlap class\r\n    pathOverlapNodes.forEach((node) => {\r\n      node.classList.remove(\"node-path-overlap\");\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Clears the visualization (both DOM and React state)\r\n   */\r\n  const clearVisualization = useCallback(\r\n    (grid: Grid, setGrid: React.Dispatch<React.SetStateAction<Grid>>): void => {\r\n      // Stop any ongoing animation\r\n      clearAllTimeouts();\r\n      isAnimating.current = false;\r\n\r\n      // Clear DOM classes\r\n      clearVisualizationClasses();\r\n\r\n      // Reset React state (distance, previousNode, isVisited)\r\n      setGrid(resetGridForPathfinding(grid));\r\n    },\r\n    [clearAllTimeouts, clearVisualizationClasses]\r\n  );\r\n\r\n  /**\r\n   * Animates the visited nodes one by one\r\n   * Uses setTimeout with increasing delays based on index\r\n   */\r\n  const animateVisitedNodes = useCallback(\r\n    (\r\n      visitedNodesInOrder: Node[],\r\n      speed: number,\r\n      onComplete: () => void\r\n    ): void => {\r\n      for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n\r\n          // Skip Start and Finish nodes (preserve their colors)\r\n          if (node.isStart || node.isFinish) {\r\n            // If this is the last node, trigger path animation\r\n            if (i === visitedNodesInOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation for performance\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            element.classList.add(\"node-visited\");\r\n          }\r\n\r\n          // If this is the last node, trigger path animation\r\n          if (i === visitedNodesInOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Animates the shortest path nodes\r\n   * Called after visited animation completes\r\n   */\r\n  const animateShortestPath = useCallback(\r\n    (\r\n      nodesInShortestPathOrder: Node[],\r\n      speed: number,\r\n      onComplete: () => void\r\n    ): void => {\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n\r\n          // Skip Start and Finish nodes (preserve their colors)\r\n          if (node.isStart || node.isFinish) {\r\n            if (i === nodesInShortestPathOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            // Remove visited class first, then add path class\r\n            element.classList.remove(\"node-visited\");\r\n            element.classList.add(\"node-path\");\r\n          }\r\n\r\n          // If this is the last node, mark animation as complete\r\n          if (i === nodesInShortestPathOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * (speed * 3)); // Path animation is slower (3x)\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Main visualization function for pathfinding algorithms\r\n   *\r\n   * CRITICAL: Strict separation between Calculation and Visualization\r\n   * - Phase 1: Calculation (Pure Logic) - NO React state updates\r\n   * - Phase 2: Animation (DOM Manipulation) - Progressive visual feedback\r\n   * - Phase 3: Cleanup - Reset animation state\r\n   *\r\n   * The algorithm runs on a DEEP COPY of the grid to prevent React re-renders\r\n   * from showing the final state before animation completes.\r\n   */\r\n  const visualizePathfinding = useCallback(\r\n    (\r\n      algorithm: AlgorithmType,\r\n      grid: Grid,\r\n      _setGrid: React.Dispatch<React.SetStateAction<Grid>>, // Unused - kept for API consistency\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number,\r\n      statsCallbacks?: StatsCallbacks\r\n    ): void => {\r\n      // Prevent multiple visualizations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous visualization (DOM classes)\r\n      clearAllTimeouts();\r\n      clearVisualizationClasses();\r\n\r\n      // CRITICAL: Create a DEEP COPY of the grid for algorithm execution\r\n      // This prevents the algorithm from mutating React state\r\n      // The original grid in React state stays \"clean\" (isVisited: false)\r\n      const algorithmGrid: Grid = grid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          isVisited: false,\r\n          distance: Infinity,\r\n          previousNode: null,\r\n        }))\r\n      );\r\n\r\n      // Find Start and Finish nodes from the ALGORITHM COPY\r\n      let startNode: Node | null = null;\r\n      let finishNode: Node | null = null;\r\n\r\n      for (const row of algorithmGrid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode = node;\r\n          if (node.isFinish) finishNode = node;\r\n        }\r\n      }\r\n\r\n      // Safety check\r\n      if (!startNode || !finishNode) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        return;\r\n      }\r\n\r\n      // Mark as visualizing BEFORE algorithm runs\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // === PHASE 1: CALCULATION (Pure Logic) ===\r\n      // Run pathfinding algorithm on the COPY - this mutates algorithmGrid, NOT React state\r\n      // The original grid in React state remains unchanged (all nodes white)\r\n      let visitedNodesInOrder: Node[] = [];\r\n      let nodesInShortestPathOrder: Node[] = [];\r\n\r\n      // Start timing for metrics\r\n      const startTime = performance.now();\r\n\r\n      switch (algorithm) {\r\n        case AlgorithmType.ASTAR:\r\n          visitedNodesInOrder = astar(algorithmGrid, startNode, finishNode);\r\n          nodesInShortestPathOrder = getAstarPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BFS:\r\n          visitedNodesInOrder = bfs(algorithmGrid, startNode, finishNode);\r\n          nodesInShortestPathOrder = getBfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DFS:\r\n          visitedNodesInOrder = dfs(algorithmGrid, startNode, finishNode);\r\n          nodesInShortestPathOrder = getDfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DIJKSTRA:\r\n        default:\r\n          visitedNodesInOrder = dijkstra(algorithmGrid, startNode, finishNode);\r\n          nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n          break;\r\n      }\r\n\r\n      // End timing\r\n      const endTime = performance.now();\r\n      const executionTime = endTime - startTime;\r\n\r\n      // Check if path was found (path length <= 1 means only start node or empty)\r\n      const pathFound = nodesInShortestPathOrder.length > 1;\r\n\r\n      // Capture stats for single algorithm mode\r\n      // Use -1 for pathLength to indicate unreachable target\r\n      const stats: AlgorithmStats = {\r\n        algorithm,\r\n        executionTime,\r\n        visitedCount: visitedNodesInOrder.length,\r\n        pathLength: pathFound ? nodesInShortestPathOrder.length : -1,\r\n      };\r\n\r\n      // === PHASE 2: ANIMATION (DOM Manipulation) ===\r\n      // Now animate using setTimeout + DOM classList\r\n      // React state is NOT updated - only CSS classes are toggled\r\n      animateVisitedNodes(visitedNodesInOrder, speed, () => {\r\n        // After visited animation, check if path exists\r\n        if (!pathFound) {\r\n          // No path found - skip path animation, show toast, update stats\r\n          isAnimating.current = false;\r\n          setIsVisualizing(false);\r\n\r\n          if (statsCallbacks) {\r\n            statsCallbacks.setVisualizationStats(stats);\r\n            // Trigger toast notification for unreachable target\r\n            if (statsCallbacks.showToast) {\r\n              statsCallbacks.showToast(\r\n                \"Target is unreachable! No path exists.\"\r\n              );\r\n            }\r\n            setTimeout(() => {\r\n              statsCallbacks.scrollToStats();\r\n            }, 500);\r\n          }\r\n          return;\r\n        }\r\n\r\n        // Path exists - animate shortest path\r\n        const pathDelay = setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder, speed, () => {\r\n            // === PHASE 3: CLEANUP ===\r\n            // Animation complete - reset flags\r\n            isAnimating.current = false;\r\n            setIsVisualizing(false);\r\n\r\n            // Update stats and scroll to statistics section\r\n            if (statsCallbacks) {\r\n              statsCallbacks.setVisualizationStats(stats);\r\n              // Small delay before scrolling to let user see the final path\r\n              setTimeout(() => {\r\n                statsCallbacks.scrollToStats();\r\n              }, 500);\r\n            }\r\n            // NOTE: We intentionally do NOT sync React state here\r\n            // The visual state (DOM classes) is the source of truth during visualization\r\n          });\r\n        }, 50);\r\n        timeoutIds.current.push(pathDelay);\r\n      });\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      animateVisitedNodes,\r\n      animateShortestPath,\r\n    ]\r\n  );\r\n\r\n  /**\r\n   * Removes wall CSS classes from all nodes via DOM\r\n   */\r\n  const clearWallClasses = useCallback((): void => {\r\n    const wallNodes = document.querySelectorAll(\".node-wall\");\r\n    wallNodes.forEach((node) => {\r\n      node.classList.remove(\"node-wall\");\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Animates maze wall generation\r\n   * Uses setTimeout to sequentially add walls for visual effect\r\n   * Protects Start/Finish nodes from being turned into walls\r\n   */\r\n  const animateMazeWalls = useCallback(\r\n    (wallsInOrder: Node[], speed: number, onComplete: () => void): void => {\r\n      for (let i = 0; i < wallsInOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = wallsInOrder[i];\r\n\r\n          // PROTECTION: Skip Start and Finish nodes (never turn them into walls)\r\n          if (node.isStart || node.isFinish) {\r\n            // If this is the last wall, trigger completion\r\n            if (i === wallsInOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation for wall animation\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            element.classList.add(\"node-wall\");\r\n          }\r\n\r\n          // If this is the last wall, trigger completion\r\n          if (i === wallsInOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n\r\n      // Handle empty walls array\r\n      if (wallsInOrder.length === 0) {\r\n        onComplete();\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Main maze generation function\r\n   *\r\n   * Steps:\r\n   * A. Clear any existing visualization and walls\r\n   * B. Get maze walls from algorithm\r\n   * C. Animate wall building\r\n   * D. Sync React state with final walls\r\n   */\r\n  const generateMaze = useCallback(\r\n    (\r\n      mazeType: MazeType,\r\n      grid: Grid,\r\n      setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number\r\n    ): void => {\r\n      // Prevent multiple generations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous animations and timeouts\r\n      clearAllTimeouts();\r\n\r\n      // === DOM SAFETY NET ===\r\n      // Explicitly clear ALL visualization classes from DOM before starting\r\n      // This ensures a clean slate even if React state and DOM are out of sync\r\n      clearVisualizationClasses(); // Removes .node-visited and .node-path\r\n      clearWallClasses(); // Removes .node-wall\r\n\r\n      // Step A: Clear walls AND pathfinding state from React state\r\n      // First reset pathfinding (isVisited, distance, previousNode)\r\n      const resetGrid = resetGridForPathfinding(grid);\r\n      // Then clear walls\r\n      const clearedGrid = clearWalls(resetGrid);\r\n      setGrid(clearedGrid);\r\n\r\n      // Find Start and Finish nodes\r\n      let startNode: Node | null = null;\r\n      let finishNode: Node | null = null;\r\n\r\n      for (const row of clearedGrid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode = node;\r\n          if (node.isFinish) finishNode = node;\r\n        }\r\n      }\r\n\r\n      // Safety check\r\n      if (!startNode || !finishNode) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        return;\r\n      }\r\n\r\n      // Step B: Get maze walls based on algorithm type\r\n      let wallsInOrder: Node[] = [];\r\n      let animationSpeed = speed;\r\n\r\n      switch (mazeType) {\r\n        case MazeType.RECURSIVE_DIVISION:\r\n          wallsInOrder = getRecursiveDivisionMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          break;\r\n        case MazeType.RANDOMIZED_DFS:\r\n          wallsInOrder = getRandomizedDFSMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          // DFS generates many walls - use faster animation (5ms min)\r\n          animationSpeed = Math.max(5, speed / 3);\r\n          break;\r\n        default:\r\n          console.error(\"Unknown maze type:\", mazeType);\r\n          return;\r\n      }\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // Step C: Animate wall building\r\n      // Use setTimeout to allow React to process the grid state update first\r\n      // This ensures isVisited=false is rendered before animation starts\r\n      setTimeout(() => {\r\n        animateMazeWalls(wallsInOrder, animationSpeed, () => {\r\n          // Step D: Sync React state with walls\r\n          // This is CRUCIAL - without this, Dijkstra won't see the walls\r\n          setGrid((currentGrid) => {\r\n            const newGrid = currentGrid.map((row) =>\r\n              row.map((node) => ({ ...node }))\r\n            );\r\n\r\n            // Mark all walls in the grid state\r\n            for (const wall of wallsInOrder) {\r\n              if (\r\n                !newGrid[wall.row][wall.col].isStart &&\r\n                !newGrid[wall.row][wall.col].isFinish\r\n              ) {\r\n                newGrid[wall.row][wall.col].isWall = true;\r\n              }\r\n            }\r\n\r\n            return newGrid;\r\n          });\r\n\r\n          // Animation complete\r\n          isAnimating.current = false;\r\n          setIsVisualizing(false);\r\n        });\r\n      }, 50); // Small delay to let React re-render with cleared state\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      clearWallClasses,\r\n      animateMazeWalls,\r\n    ]\r\n  );\r\n\r\n  /**\r\n   * Helper function to run an algorithm and get results\r\n   */\r\n  const runAlgorithm = useCallback(\r\n    (\r\n      algorithm: AlgorithmType,\r\n      algorithmGrid: Grid,\r\n      startNode: Node,\r\n      finishNode: Node\r\n    ): { visitedNodes: Node[]; pathNodes: Node[] } => {\r\n      let visitedNodes: Node[] = [];\r\n      let pathNodes: Node[] = [];\r\n\r\n      switch (algorithm) {\r\n        case AlgorithmType.ASTAR:\r\n          visitedNodes = astar(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getAstarPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BFS:\r\n          visitedNodes = bfs(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getBfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DFS:\r\n          visitedNodes = dfs(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getDfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DIJKSTRA:\r\n        default:\r\n          visitedNodes = dijkstra(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getNodesInShortestPathOrder(finishNode);\r\n          break;\r\n      }\r\n\r\n      return { visitedNodes, pathNodes };\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Race Mode: Run two algorithms simultaneously and animate them together\r\n   *\r\n   * Algorithm Logic:\r\n   * 1. Create two independent deep copies of the grid\r\n   * 2. Run both algorithms on their respective copies\r\n   * 3. Animate both visited node arrays in parallel (step by step)\r\n   * 4. Handle overlaps with a special class\r\n   * 5. Animate both paths after visited animation completes\r\n   */\r\n  const visualizeRace = useCallback(\r\n    (\r\n      algo1: AlgorithmType,\r\n      algo2: AlgorithmType,\r\n      grid: Grid,\r\n      _setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number,\r\n      statsCallbacks?: StatsCallbacks\r\n    ): void => {\r\n      // Prevent multiple visualizations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous visualization\r\n      clearAllTimeouts();\r\n      clearVisualizationClasses();\r\n\r\n      // Create TWO independent deep copies - one for each algorithm\r\n      const createGridCopy = (): Grid =>\r\n        grid.map((row) =>\r\n          row.map((node) => ({\r\n            ...node,\r\n            isVisited: false,\r\n            distance: Infinity,\r\n            previousNode: null,\r\n          }))\r\n        );\r\n\r\n      const grid1 = createGridCopy();\r\n      const grid2 = createGridCopy();\r\n\r\n      // Find Start and Finish nodes from each copy\r\n      let startNode1: Node | null = null;\r\n      let finishNode1: Node | null = null;\r\n      let startNode2: Node | null = null;\r\n      let finishNode2: Node | null = null;\r\n\r\n      for (const row of grid1) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode1 = node;\r\n          if (node.isFinish) finishNode1 = node;\r\n        }\r\n      }\r\n\r\n      for (const row of grid2) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode2 = node;\r\n          if (node.isFinish) finishNode2 = node;\r\n        }\r\n      }\r\n\r\n      // Safety check\r\n      if (!startNode1 || !finishNode1 || !startNode2 || !finishNode2) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        return;\r\n      }\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // === PHASE 1: CALCULATION ===\r\n      // Run both algorithms on their respective grid copies with timing\r\n      const startTime1 = performance.now();\r\n      const result1 = runAlgorithm(algo1, grid1, startNode1, finishNode1);\r\n      const endTime1 = performance.now();\r\n\r\n      const startTime2 = performance.now();\r\n      const result2 = runAlgorithm(algo2, grid2, startNode2, finishNode2);\r\n      const endTime2 = performance.now();\r\n\r\n      const visited1 = result1.visitedNodes;\r\n      const visited2 = result2.visitedNodes;\r\n      const path1 = result1.pathNodes;\r\n      const path2 = result2.pathNodes;\r\n\r\n      // Check if paths were found (path length <= 1 means only start node or empty)\r\n      const path1Found = path1.length > 1;\r\n      const path2Found = path2.length > 1;\r\n\r\n      // Capture stats for both algorithms (-1 for unreachable)\r\n      const stats1: AlgorithmStats = {\r\n        algorithm: algo1,\r\n        executionTime: endTime1 - startTime1,\r\n        visitedCount: visited1.length,\r\n        pathLength: path1Found ? path1.length : -1,\r\n      };\r\n\r\n      const stats2: AlgorithmStats = {\r\n        algorithm: algo2,\r\n        executionTime: endTime2 - startTime2,\r\n        visitedCount: visited2.length,\r\n        pathLength: path2Found ? path2.length : -1,\r\n      };\r\n\r\n      // Determine winner (shorter path = winner, tie if equal or no path)\r\n      let winner: \"agent1\" | \"agent2\" | \"tie\" = \"tie\";\r\n      if (path1Found && path2Found) {\r\n        if (path1.length < path2.length) {\r\n          winner = \"agent1\";\r\n        } else if (path2.length < path1.length) {\r\n          winner = \"agent2\";\r\n        }\r\n        // If paths are equal, compare execution time\r\n        if (path1.length === path2.length) {\r\n          if (stats1.executionTime < stats2.executionTime) {\r\n            winner = \"agent1\";\r\n          } else if (stats2.executionTime < stats1.executionTime) {\r\n            winner = \"agent2\";\r\n          }\r\n        }\r\n      } else if (path1Found) {\r\n        winner = \"agent1\";\r\n      } else if (path2Found) {\r\n        winner = \"agent2\";\r\n      }\r\n      // If neither found a path, winner stays 'tie'\r\n\r\n      const raceStats: RaceStats = {\r\n        agent1: stats1,\r\n        agent2: stats2,\r\n        winner,\r\n      };\r\n\r\n      // Track which nodes have been visited by which agent\r\n      const visitedByAgent1 = new Set<string>();\r\n      const visitedByAgent2 = new Set<string>();\r\n\r\n      // === PHASE 2: PARALLEL ANIMATION ===\r\n      const maxVisitedLen = Math.max(visited1.length, visited2.length);\r\n\r\n      for (let i = 0; i < maxVisitedLen; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          // Agent 1 animation\r\n          if (i < visited1.length) {\r\n            const node1 = visited1[i];\r\n            if (!node1.isStart && !node1.isFinish) {\r\n              const key1 = `${node1.row}-${node1.col}`;\r\n              const element1 = document.getElementById(\r\n                `node-${node1.row}-${node1.col}`\r\n              );\r\n              if (element1) {\r\n                visitedByAgent1.add(key1);\r\n                // Check if Agent 2 already visited this node\r\n                if (visitedByAgent2.has(key1)) {\r\n                  element1.classList.remove(\"node-visited-second\");\r\n                  element1.classList.add(\"node-visited-overlap\");\r\n                } else {\r\n                  element1.classList.add(\"node-visited\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Agent 2 animation\r\n          if (i < visited2.length) {\r\n            const node2 = visited2[i];\r\n            if (!node2.isStart && !node2.isFinish) {\r\n              const key2 = `${node2.row}-${node2.col}`;\r\n              const element2 = document.getElementById(\r\n                `node-${node2.row}-${node2.col}`\r\n              );\r\n              if (element2) {\r\n                visitedByAgent2.add(key2);\r\n                // Check if Agent 1 already visited this node\r\n                if (visitedByAgent1.has(key2)) {\r\n                  element2.classList.remove(\"node-visited\");\r\n                  element2.classList.add(\"node-visited-overlap\");\r\n                } else {\r\n                  element2.classList.add(\"node-visited-second\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // After last visited node, animate paths\r\n          if (i === maxVisitedLen - 1) {\r\n            const pathDelay = setTimeout(() => {\r\n              // Create a Set for path1 nodes for O(1) lookup (to detect overlaps)\r\n              const path1Keys = new Set<string>();\r\n              for (const node of path1) {\r\n                path1Keys.add(`${node.row}-${node.col}`);\r\n              }\r\n\r\n              // Create a Set for path2 nodes for O(1) lookup\r\n              const path2Keys = new Set<string>();\r\n              for (const node of path2) {\r\n                path2Keys.add(`${node.row}-${node.col}`);\r\n              }\r\n\r\n              // SIMPLIFIED: Path animation uses simple CSS classes\r\n              // Complex SVG overlay will be added in a future component\r\n              const maxPathLen = Math.max(path1.length, path2.length);\r\n\r\n              for (let j = 0; j < maxPathLen; j++) {\r\n                const pathTimeoutId = setTimeout(() => {\r\n                  // Path 1 animation (Agent 1 - Yellow)\r\n                  if (j < path1.length) {\r\n                    const pathNode1 = path1[j];\r\n                    if (!pathNode1.isStart && !pathNode1.isFinish) {\r\n                      const key1 = `${pathNode1.row}-${pathNode1.col}`;\r\n                      const element = document.getElementById(\r\n                        `node-${pathNode1.row}-${pathNode1.col}`\r\n                      );\r\n                      if (element) {\r\n                        element.classList.remove(\r\n                          \"node-visited\",\r\n                          \"node-visited-second\",\r\n                          \"node-visited-overlap\"\r\n                        );\r\n                        // Check if this node is also in path2 (overlap)\r\n                        if (path2Keys.has(key1)) {\r\n                          // Simple overlap class (lime green for now)\r\n                          element.classList.add(\"node-path-overlap\");\r\n                        } else {\r\n                          element.classList.add(\"node-path\");\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  // Path 2 animation (Agent 2 - Cyan)\r\n                  if (j < path2.length) {\r\n                    const pathNode2 = path2[j];\r\n                    if (!pathNode2.isStart && !pathNode2.isFinish) {\r\n                      const key2 = `${pathNode2.row}-${pathNode2.col}`;\r\n                      const element = document.getElementById(\r\n                        `node-${pathNode2.row}-${pathNode2.col}`\r\n                      );\r\n                      if (element) {\r\n                        element.classList.remove(\r\n                          \"node-visited\",\r\n                          \"node-visited-second\",\r\n                          \"node-visited-overlap\",\r\n                          \"node-path\"\r\n                        );\r\n                        // Check if this node is also in path1 (overlap)\r\n                        if (path1Keys.has(key2)) {\r\n                          // Simple overlap class (lime green for now)\r\n                          element.classList.add(\"node-path-overlap\");\r\n                        } else {\r\n                          element.classList.add(\"node-path-second\");\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  // After both paths complete\r\n                  if (j === maxPathLen - 1) {\r\n                    isAnimating.current = false;\r\n                    setIsVisualizing(false);\r\n\r\n                    // Update stats and scroll to statistics section\r\n                    if (statsCallbacks) {\r\n                      statsCallbacks.setVisualizationStats(raceStats);\r\n                      setTimeout(() => {\r\n                        statsCallbacks.scrollToStats();\r\n                      }, 500);\r\n                    }\r\n                  }\r\n                }, j * (speed * 3));\r\n\r\n                timeoutIds.current.push(pathTimeoutId);\r\n              }\r\n\r\n              // Handle case where both paths are empty\r\n              if (maxPathLen === 0) {\r\n                isAnimating.current = false;\r\n                setIsVisualizing(false);\r\n\r\n                // Update stats and scroll even if no paths found\r\n                if (statsCallbacks) {\r\n                  statsCallbacks.setVisualizationStats(raceStats);\r\n                  // Show toast if neither algorithm found a path\r\n                  if (!path1Found && !path2Found && statsCallbacks.showToast) {\r\n                    statsCallbacks.showToast(\r\n                      \"Target is unreachable! Neither algorithm found a path.\"\r\n                    );\r\n                  }\r\n                  setTimeout(() => {\r\n                    statsCallbacks.scrollToStats();\r\n                  }, 500);\r\n                }\r\n              }\r\n            }, 50);\r\n\r\n            timeoutIds.current.push(pathDelay);\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n\r\n      // Handle case where both visited arrays are empty\r\n      if (maxVisitedLen === 0) {\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n\r\n        // Update stats and scroll even if nothing was visited\r\n        if (statsCallbacks) {\r\n          statsCallbacks.setVisualizationStats(raceStats);\r\n          setTimeout(() => {\r\n            statsCallbacks.scrollToStats();\r\n          }, 500);\r\n        }\r\n      }\r\n    },\r\n    [clearAllTimeouts, clearVisualizationClasses, runAlgorithm]\r\n  );\r\n\r\n  return {\r\n    visualizePathfinding,\r\n    visualizeRace,\r\n    generateMaze,\r\n    clearVisualization,\r\n    isAnimating,\r\n  };\r\n};\r\n\r\nexport default useVisualization;\r\n","import React, { useRef, useCallback, useState, lazy, Suspense } from \"react\";\r\nimport { GridProvider, useGridContext } from \"./context/GridContext\";\r\nimport Board from \"./components/Board\";\r\nimport { ControlPanel } from \"./components/Controls\";\r\nimport { Legend } from \"./components/Legend\";\r\nimport Toast from \"./components/UI/Toast\";\r\nimport { useVisualization } from \"./hooks/useVisualization\";\r\nimport { MazeType } from \"./types\";\r\nimport styles from \"./App.module.css\";\r\n\r\n// Lazy load the Statistics section to reduce initial bundle size\r\n// This component is below the fold and not needed for initial render\r\nconst StatisticsSection = lazy(\r\n  () => import(\"./components/Statistics/StatisticsSection\")\r\n);\r\n\r\n/**\r\n * MainContent Component - Two-Page Scroll Layout\r\n * Section 1: Visualizer (Board + Controls)\r\n * Section 2: Statistics Dashboard\r\n */\r\nconst MainContent: React.FC = () => {\r\n  const {\r\n    grid,\r\n    setGrid,\r\n    setIsVisualizing,\r\n    animationSpeed,\r\n    selectedAlgorithm,\r\n    secondAlgorithm,\r\n    isRaceMode,\r\n    clearAllWalls,\r\n    visualizationStats,\r\n    setVisualizationStats,\r\n    showToast,\r\n  } = useGridContext();\r\n\r\n  const {\r\n    visualizePathfinding,\r\n    visualizeRace,\r\n    generateMaze,\r\n    clearVisualization,\r\n  } = useVisualization();\r\n\r\n  // Ref for the stats section to enable programmatic scrolling\r\n  const statsSectionRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Mobile sidebar state\r\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false);\r\n\r\n  // Toggle mobile sidebar\r\n  const toggleSidebar = useCallback(() => {\r\n    setIsSidebarOpen((prev) => !prev);\r\n  }, []);\r\n\r\n  // Close sidebar (for overlay click)\r\n  const closeSidebar = useCallback(() => {\r\n    setIsSidebarOpen(false);\r\n  }, []);\r\n\r\n  // Scroll to stats section\r\n  const scrollToStats = useCallback(() => {\r\n    statsSectionRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n  }, []);\r\n\r\n  // Stats callbacks for visualization hooks\r\n  const statsCallbacks = {\r\n    setVisualizationStats,\r\n    scrollToStats,\r\n    showToast,\r\n  };\r\n\r\n  // Handler for visualize button (single algorithm)\r\n  const handleVisualize = (): void => {\r\n    visualizePathfinding(\r\n      selectedAlgorithm,\r\n      grid,\r\n      setGrid,\r\n      setIsVisualizing,\r\n      animationSpeed,\r\n      statsCallbacks\r\n    );\r\n  };\r\n\r\n  // Handler for race mode visualization (two algorithms)\r\n  const handleVisualizeRace = (): void => {\r\n    if (secondAlgorithm) {\r\n      visualizeRace(\r\n        selectedAlgorithm,\r\n        secondAlgorithm,\r\n        grid,\r\n        setGrid,\r\n        setIsVisualizing,\r\n        animationSpeed,\r\n        statsCallbacks\r\n      );\r\n    }\r\n  };\r\n\r\n  // Handler for clear path button\r\n  const handleClearPath = (): void => {\r\n    clearVisualization(grid, setGrid);\r\n  };\r\n\r\n  // Handler for generate maze button\r\n  const handleGenerateMaze = (mazeType: MazeType): void => {\r\n    handleClearPath();\r\n    clearAllWalls();\r\n\r\n    requestAnimationFrame(() => {\r\n      setTimeout(() => {\r\n        generateMaze(\r\n          mazeType,\r\n          grid,\r\n          setGrid,\r\n          setIsVisualizing,\r\n          Math.max(15, animationSpeed / 2)\r\n        );\r\n      }, 50);\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div className={styles.snapContainer}>\r\n      {/* Section 1: Visualizer */}\r\n      <div className={`${styles.snapSection} ${styles.visualizerSection}`}>\r\n        {/* Mobile Menu Toggle Button */}\r\n        <button\r\n          className={styles.mobileMenuToggle}\r\n          onClick={toggleSidebar}\r\n          aria-label={isSidebarOpen ? \"Close menu\" : \"Open menu\"}\r\n          aria-expanded={isSidebarOpen}\r\n        >\r\n          <span className={styles.hamburgerIcon}>\r\n            {isSidebarOpen ? \"\" : \"\"}\r\n          </span>\r\n        </button>\r\n\r\n        {/* Mobile Overlay */}\r\n        {isSidebarOpen && (\r\n          <div\r\n            className={styles.sidebarOverlay}\r\n            onClick={closeSidebar}\r\n            aria-hidden=\"true\"\r\n          />\r\n        )}\r\n\r\n        {/* Control Panel Sidebar - Fixed width, full height */}\r\n        <aside\r\n          className={`${styles.controlPanelSidebar} ${\r\n            isSidebarOpen ? styles.sidebarOpen : \"\"\r\n          }`}\r\n        >\r\n          <ControlPanel\r\n            onVisualize={handleVisualize}\r\n            onClearPath={handleClearPath}\r\n            onGenerateMaze={handleGenerateMaze}\r\n            onVisualizeRace={handleVisualizeRace}\r\n          />\r\n        </aside>\r\n\r\n        {/* Game Area - Takes remaining space */}\r\n        <div className={styles.gameArea}>\r\n          {/* Header - Fixed height */}\r\n          <header className={styles.header}>\r\n            <h1 className={styles.title}>Maze & Pathfinding Visualizer</h1>\r\n            <p className={styles.subtitle}>\r\n              Visualize pathfinding algorithms on an interactive grid\r\n            </p>\r\n          </header>\r\n\r\n          {/* Board Container - Takes all remaining vertical space */}\r\n          <div className={styles.boardContainer}>\r\n            <Board />\r\n          </div>\r\n\r\n          {/* Legend - Fixed height */}\r\n          <div className={styles.legendArea}>\r\n            <Legend orientation=\"horizontal\" compact />\r\n          </div>\r\n\r\n          {/* Scroll Indicator - Fixed height */}\r\n          <footer className={styles.footer}>\r\n            <div className={styles.scrollIndicator} onClick={scrollToStats}>\r\n              <span>View Statistics</span>\r\n              <span></span>\r\n            </div>\r\n          </footer>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Section 2: Statistics */}\r\n      <div className={styles.snapSection} ref={statsSectionRef}>\r\n        <Suspense\r\n          fallback={\r\n            <div className={styles.statsLoading}>Loading Statistics...</div>\r\n          }\r\n        >\r\n          <StatisticsSection\r\n            stats={visualizationStats}\r\n            isRaceMode={isRaceMode}\r\n          />\r\n        </Suspense>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n/**\r\n * Main Application Component\r\n * Wraps the entire app with GridProvider for global state management.\r\n */\r\nconst App: React.FC = () => {\r\n  return (\r\n    <GridProvider>\r\n      <MainContent />\r\n      <Toast />\r\n    </GridProvider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom/client';\r\nimport App from './App';\r\nimport './styles/variables.css';\r\n\r\n/**\r\n * Application Entry Point\r\n * \r\n * Renders the root App component into the DOM\r\n */\r\nReactDOM.createRoot(document.getElementById('root')!).render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>\r\n);\r\n"],"file":"assets/index-CJkFrs8u.js"}