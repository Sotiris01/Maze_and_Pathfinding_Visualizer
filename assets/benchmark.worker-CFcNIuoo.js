var pt=Object.defineProperty;var ut=(V,R,C)=>R in V?pt(V,R,{enumerable:!0,configurable:!0,writable:!0,value:C}):V[R]=C;var F=(V,R,C)=>ut(V,typeof R!="symbol"?R+"":R,C);(function(){"use strict";var V=(o=>(o.DIJKSTRA="dijkstra",o.ASTAR="astar",o.BFS="bfs",o.DFS="dfs",o.GREEDY_BEST_FIRST="greedyBestFirst",o.BIDIRECTIONAL_BFS="bidirectionalBFS",o.BIDIRECTIONAL_ASTAR="bidirectionalAStar",o.JUMP_POINT_SEARCH="jumpPointSearch",o))(V||{});let R=class{constructor(){F(this,"heap",[]);F(this,"positionMap",new Map)}getKey(t){return`${t.row}-${t.col}`}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.heap[t].distance>=this.heap[e].distance)break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.heap[s].distance<this.heap[n].distance&&(n=s),i<e&&this.heap[i].distance<this.heap[n].distance&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function C(o,t,e){const s=[],i=new Set,n=h=>`${h.row}-${h.col}`;t.distance=0;const a=new R;for(a.insert(t);!a.isEmpty();){const h=a.extractMin(),l=n(h);if(i.has(l)||h.isWall)continue;if(h.distance===1/0||(i.add(l),h.isVisited=!0,s.push(h),h===e))return s;const c=A(h,o,i);for(const g of c){const y=h.distance+g.weight;y<g.distance&&(g.distance=y,g.previousNode=h,a.insert(g))}}return s}function A(o,t,e){const s=[],{row:i,col:n}=o,a=t.length,h=t[0].length;return i>0&&s.push(t[i-1][n]),i<a-1&&s.push(t[i+1][n]),n>0&&s.push(t[i][n-1]),n<h-1&&s.push(t[i][n+1]),s.filter(l=>{const c=`${l.row}-${l.col}`;return!e.has(c)&&!l.isWall})}let Q=class{constructor(t,e){F(this,"heap",[]);F(this,"getKey");F(this,"getPriority");F(this,"positionMap",new Map);this.getKey=t,this.getPriority=e}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}contains(t){return this.positionMap.has(this.getKey(t))}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return null;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.getPriority(this.heap[t])>=this.getPriority(this.heap[e]))break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.getPriority(this.heap[s])<this.getPriority(this.heap[n])&&(n=s),i<e&&this.getPriority(this.heap[i])<this.getPriority(this.heap[n])&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function O(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}function L(o,t,e){const s=[],i=new Map,n=new Map,a=c=>`${c.row}-${c.col}`;for(const c of o)for(const g of c){const y=a(g);i.set(y,1/0),n.set(y,1/0)}const h=a(t);i.set(h,0),n.set(h,O(t,e));const l=new Q(a,c=>n.get(a(c))??1/0);for(l.insert(t);!l.isEmpty();){const c=l.extractMin(),g=a(c);if(c.isWall||c.isVisited)continue;const y=i.get(g)??1/0;if(y===1/0||(c.isVisited=!0,s.push(c),c===e))return s;const S=Y(c,o);for(const K of S){if(K.isWall||K.isVisited)continue;const u=a(K),b=y+K.weight,w=i.get(u)??1/0;b<w&&(K.previousNode=c,i.set(u,b),n.set(u,b+O(K,e)),l.insert(K))}}return s}function Y(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return s>0&&e.push(t[s-1][i]),s<n-1&&e.push(t[s+1][i]),i>0&&e.push(t[s][i-1]),i<a-1&&e.push(t[s][i+1]),e}let X=class{constructor(){F(this,"items",[]);F(this,"head",0)}enqueue(t){this.items.push(t)}dequeue(){if(this.isEmpty())return;const t=this.items[this.head];return this.head++,this.head>1e3&&this.head>this.items.length/2&&(this.items=this.items.slice(this.head),this.head=0),t}isEmpty(){return this.head>=this.items.length}get size(){return this.items.length-this.head}};function Z(o,t,e){const s=[],i=new X;for(t.isVisited=!0,t.distance=0,i.enqueue(t),s.push(t);!i.isEmpty();){const n=i.dequeue();if(n.isWall)continue;if(n===e)return s;const a=N(n,o);for(const h of a)if(!h.isWall&&(h.isVisited=!0,h.previousNode=n,h.distance=n.distance+1,i.enqueue(h),s.push(h),h===e))return s}return s}function N(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return s>0&&e.push(t[s-1][i]),s<n-1&&e.push(t[s+1][i]),i>0&&e.push(t[s][i-1]),i<a-1&&e.push(t[s][i+1]),e.filter(h=>!h.isVisited)}function x(o,t,e){const s=[],i=[];for(i.push(t);i.length>0;){const n=i.pop();if(n.isWall||n.isVisited)continue;if(n.isVisited=!0,s.push(n),n===e)return s;const a=j(n,o);for(const h of a)h.isWall||h.isVisited||(h.previousNode=n,i.push(h))}return s}function j(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return i>0&&e.push(t[s][i-1]),s<n-1&&e.push(t[s+1][i]),i<a-1&&e.push(t[s][i+1]),s>0&&e.push(t[s-1][i]),e.filter(h=>!h.isVisited)}let tt=class{constructor(t,e){F(this,"heap",[]);F(this,"getKey");F(this,"getPriority");F(this,"positionMap",new Map);this.getKey=t,this.getPriority=e}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.getPriority(this.heap[t])>=this.getPriority(this.heap[e]))break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.getPriority(this.heap[s])<this.getPriority(this.heap[n])&&(n=s),i<e&&this.getPriority(this.heap[i])<this.getPriority(this.heap[n])&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function H(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}function et(o,t,e){const s=[],i=new Set,n=c=>`${c.row}-${c.col}`,a=new Map,h=new tt(n,c=>a.get(n(c))??1/0),l=n(t);for(a.set(l,H(t,e)),h.insert(t);!h.isEmpty();){const c=h.extractMin(),g=n(c);if(c.isWall||i.has(g))continue;if(i.add(g),c.isVisited=!0,s.push(c),c===e)return s;const y=st(c,o);for(const S of y){const K=n(S);S.isWall||i.has(K)||(S.previousNode=c,a.set(K,H(S,e)),h.insert(S))}}return s}function st(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return s>0&&e.push(t[s-1][i]),s<n-1&&e.push(t[s+1][i]),i>0&&e.push(t[s][i-1]),i<a-1&&e.push(t[s][i+1]),e}class _{constructor(){F(this,"items",[]);F(this,"head",0)}enqueue(t){this.items.push(t)}dequeue(){if(this.head>=this.items.length)return;const t=this.items[this.head];return this.head++,this.head>this.items.length/2&&this.head>100&&(this.items=this.items.slice(this.head),this.head=0),t}get size(){return this.items.length-this.head}isEmpty(){return this.head>=this.items.length}}function it(o,t,e){const s=[],i=o.length,n=o[0].length,a=new Map,h=new Map,l=new Set,c=new Set,g=p=>`${p.row}-${p.col}`,y=p=>{const[r,f]=p.split("-").map(Number);return o[r][f]},S=new _,K=new _,u=g(t);l.add(u),a.set(u,null),t.isVisited=!0,s.push(t),S.enqueue(t);const b=g(e);c.add(b),h.set(b,null),K.enqueue(e);let w=null;const k=p=>{const r=[],{row:f,col:I}=p;return f>0&&r.push(o[f-1][I]),f<i-1&&r.push(o[f+1][I]),I>0&&r.push(o[f][I-1]),I<n-1&&r.push(o[f][I+1]),r.filter(D=>!D.isWall)};for(;!S.isEmpty()&&!K.isEmpty();){if(!S.isEmpty()){const p=S.dequeue();for(const r of k(p)){const f=g(r);if(!l.has(f)){if(l.add(f),a.set(f,p),r.isVisited=!0,s.push(r),c.has(f)){w=f;break}S.enqueue(r)}}if(w)break}if(!K.isEmpty()&&!w){const p=K.dequeue();p===e&&(e.isVisited=!0,s.push(e));for(const r of k(p)){const f=g(r);if(!c.has(f)){if(c.add(f),h.set(f,p),r.isVisited=!0,s.push(r),l.has(f)){w=f;break}K.enqueue(r)}}if(w)break}}if(w){const p=[];let r=w;for(;r!==null;){p.unshift(y(r));const m=a.get(r);r=m?g(m):null}const f=[],I=h.get(w);for(r=I?g(I):null;r!==null;){f.push(y(r));const m=h.get(r);r=m?g(m):null}const D=[...p,...f];for(let m=1;m<D.length;m++)D[m].previousNode=D[m-1];e.isVisited=!0}return s}let B=class{constructor(t,e){F(this,"heap",[]);F(this,"getKey");F(this,"getPriority");F(this,"positionMap",new Map);this.getKey=t,this.getPriority=e}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}peekMin(){return this.heap[0]}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.getPriority(this.heap[t])>=this.getPriority(this.heap[e]))break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.getPriority(this.heap[s])<this.getPriority(this.heap[n])&&(n=s),i<e&&this.getPriority(this.heap[i])<this.getPriority(this.heap[n])&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function G(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}function nt(o,t,e){const s=[],i=o.length,n=o[0].length,a=m=>`${m.row}-${m.col}`,h=m=>{const[d,E]=m.split("-").map(Number);return o[d][E]},l=new Map,c=new Map,g=new Map,y=new Set,S=new Map,K=new Map,u=new Map,b=new Set;for(const m of o)for(const d of m){const E=a(d);l.set(E,1/0),c.set(E,1/0),S.set(E,1/0),K.set(E,1/0)}const w=a(t);l.set(w,0),c.set(w,G(t,e)),g.set(w,null),y.add(w),t.isVisited=!0,s.push(t);const k=a(e);S.set(k,0),K.set(k,G(e,t)),u.set(k,null),b.add(k);const p=new B(a,m=>c.get(a(m))??1/0),r=new B(a,m=>K.get(a(m))??1/0);p.insert(t),r.insert(e);let f=null,I=1/0;const D=m=>{const d=[],{row:E,col:v}=m;return E>0&&d.push(o[E-1][v]),E<i-1&&d.push(o[E+1][v]),v>0&&d.push(o[E][v-1]),v<n-1&&d.push(o[E][v+1]),d.filter($=>!$.isWall)};for(;!p.isEmpty()&&!r.isEmpty();){const m=c.get(a(p.peekMin()))??1/0,d=K.get(a(r.peekMin()))??1/0;if(I<=Math.min(m,d))break;if(m<=d){const v=p.extractMin(),$=a(v);if(v.isWall)continue;if(b.has($)){const M=(l.get($)??1/0)+(S.get($)??1/0);M<I&&(I=M,f=$)}for(const M of D(v)){const P=a(M),U=(l.get($)??1/0)+M.weight,q=l.get(P)??1/0;if(U<q&&(g.set(P,v),l.set(P,U),c.set(P,U+G(M,e)),p.insert(M),!y.has(P)&&(y.add(P),M.isVisited=!0,s.push(M),b.has(P)))){const W=U+(S.get(P)??1/0);W<I&&(I=W,f=P)}}}else{const v=r.extractMin(),$=a(v);if(v.isWall)continue;if(v===e&&!s.includes(e)&&(e.isVisited=!0,s.push(e)),y.has($)){const M=(l.get($)??1/0)+(S.get($)??1/0);M<I&&(I=M,f=$)}for(const M of D(v)){const P=a(M),U=(S.get($)??1/0)+M.weight,q=S.get(P)??1/0;if(U<q&&(u.set(P,v),S.set(P,U),K.set(P,U+G(M,t)),r.insert(M),!b.has(P)&&(b.add(P),M.isVisited=!0,s.push(M),y.has(P)))){const W=(l.get(P)??1/0)+U;W<I&&(I=W,f=P)}}}}if(f!==null){const m=[];let d=f;for(;d!==null;){m.unshift(h(d));const M=g.get(d);d=M?a(M):null}const E=[],v=u.get(f);for(d=v?a(v):null;d!==null;){E.push(h(d));const M=u.get(d);d=M?a(M):null}const $=[...m,...E];for(let M=1;M<$.length;M++)$[M].previousNode=$[M-1];e.isVisited=!0}return s}class ot{constructor(){F(this,"heap",[]);F(this,"positionMap",new Map)}getKey(t){return`${t.row}-${t.col}`}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);t.fScore<this.heap[s].fScore&&(this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s))}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}has(t){return this.positionMap.has(t)}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.heap[t].fScore>=this.heap[e].fScore)break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.heap[s].fScore<this.heap[n].fScore&&(n=s),i<e&&this.heap[i].fScore<this.heap[n].fScore&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}}function T(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}const ht=[[-1,0],[1,0],[0,-1],[0,1]];function rt(o,t,e){const s=[],i=o.length,n=o[0].length,a=(u,b)=>`${u}-${b}`,h=(u,b)=>u<0||u>=i||b<0||b>=n?!1:!o[u][b].isWall,l=new Map,c=new Map,g=a(t.row,t.col);l.set(g,0),c.set(g,null);const y=new ot;y.insert({row:t.row,col:t.col,dirRow:0,dirCol:0,fScore:T(t,e)});const S=(u,b,w,k)=>{let p=u+w,r=b+k;for(;;){if(!h(p,r))return null;if(p===e.row&&r===e.col)return{row:p,col:r};if(w===0&&(!h(p-1,r-k)&&h(p-1,r)||!h(p+1,r-k)&&h(p+1,r)))return{row:p,col:r};if(k===0&&(!h(p-w,r-1)&&h(p,r-1)||!h(p-w,r+1)&&h(p,r+1)))return{row:p,col:r};p+=w,r+=k}},K=(u,b,w,k)=>{const p=[];let r;w===0&&k===0?r=ht:w===0?(r=[[0,k]],!h(u-1,b-k)&&h(u-1,b)&&r.push([-1,0]),!h(u+1,b-k)&&h(u+1,b)&&r.push([1,0])):(r=[[w,0]],!h(u-w,b-1)&&h(u,b-1)&&r.push([0,-1]),!h(u-w,b+1)&&h(u,b+1)&&r.push([0,1]));for(const[f,I]of r){const D=S(u,b,f,I);D&&p.push(D)}return p};for(;!y.isEmpty();){const u=y.extractMin(),b=a(u.row,u.col),w=o[u.row][u.col];if(w.isVisited)continue;if(w.isVisited=!0,s.push(w),u.row===e.row&&u.col===e.col)return at(o,c,e),s;const k=K(u.row,u.col,u.dirRow,u.dirCol);for(const p of k){const r=a(p.row,p.col),f=o[p.row][p.col];if(f.isVisited)continue;const I=(l.get(b)??1/0)+T(w,f);if(I<(l.get(r)??1/0)){c.set(r,b),l.set(r,I);const D=I+T(f,e),m=p.row===u.row?0:p.row>u.row?1:-1,d=p.col===u.col?0:p.col>u.col?1:-1;y.insert({row:p.row,col:p.col,dirRow:m,dirCol:d,fScore:D})}}}return s}function at(o,t,e){const s=[];let i=`${e.row}-${e.col}`;const n=[];for(;i!==null;){const[a,h]=i.split("-").map(Number);n.unshift(o[a][h]),i=t.get(i)??null}for(let a=0;a<n.length-1;a++){const h=n[a],l=n[a+1];let c=h.row,g=h.col;for(;c!==l.row||g!==l.col;){const y=o[c][g];s.length>0&&(y.previousNode=s[s.length-1]),s.push(y),c<l.row?c++:c>l.row?c--:g<l.col?g++:g>l.col&&g--}}n.length>0&&(e.previousNode=s.length>0?s[s.length-1]:null,s.push(e))}function ct(o){return o.map(t=>t.map(e=>({row:e.row,col:e.col,isStart:e.isStart,isFinish:e.isFinish,isWall:e.isWall,isVisited:!1,distance:1/0,previousNode:null,weight:1})))}function J(o){const t=o.map(i=>i.map(n=>({...n,isVisited:!1,distance:1/0,previousNode:null})));let e=null,s=null;for(const i of t)for(const n of i)n.isStart&&(e=n),n.isFinish&&(s=n);if(!e||!s)throw new Error("Start or Finish node not found in grid");return{clonedGrid:t,start:e,finish:s}}function z(o,t,e,s){switch(o){case V.DIJKSTRA:C(t,e,s);break;case V.ASTAR:L(t,e,s);break;case V.BFS:Z(t,e,s);break;case V.DFS:x(t,e,s);break;case V.GREEDY_BEST_FIRST:et(t,e,s);break;case V.BIDIRECTIONAL_BFS:it(t,e,s);break;case V.BIDIRECTIONAL_ASTAR:nt(t,e,s);break;case V.JUMP_POINT_SEARCH:rt(t,e,s);break;default:C(t,e,s)}}self.onmessage=o=>{var h,l,c,g;const{requestId:t,algorithmName:e,gridData:s,startPos:i,finishPos:n,minDuration:a}=o.data;try{const y=ct(s);if(!((l=(h=y[i.row])==null?void 0:h[i.col])!=null&&l.isStart)||!((g=(c=y[n.row])==null?void 0:c[n.col])!=null&&g.isFinish))throw new Error("Invalid start/finish positions");for(let r=0;r<3;r++){const{clonedGrid:f,start:I,finish:D}=J(y);z(e,f,I,D)}let S=0;const K=performance.now();let u=0;for(;u<a;){const{clonedGrid:r,start:f,finish:I}=J(y);z(e,r,f,I),S++,u=performance.now()-K}const b=u,w=b/S,k=1e3/w,p={avgTime:w,iterations:S,opsPerSec:k,totalTime:b};self.postMessage({success:!0,data:p,requestId:t})}catch(y){self.postMessage({success:!1,error:y instanceof Error?y.message:"Unknown error",requestId:t})}}})();
//# sourceMappingURL=benchmark.worker-CFcNIuoo.js.map
