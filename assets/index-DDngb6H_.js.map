{"version":3,"mappings":"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","names":["AlgorithmType","MazeType","GRID_ROWS","GRID_COLS","createNode","row","col","startRow","startCol","finishRow","finishCol","getSafeNodePositions","rows","cols","getInitialGrid","grid","currentRow","getNewGridWithWallSet","newGrid","node","newNode","getNewGridWithWallRemoved","getNewGridWithStartMoved","newRow","newCol","targetNode","oldRow","oldCol","r","c","getNewGridWithFinishMoved","resetGridForPathfinding","clearWalls","HISTORY_STORAGE_KEY","MAX_HISTORY_ITEMS","AVAILABLE_MAZE_TYPES","getRandomMazeType","randomIndex","defaultContextValue","GridContext","createContext","useGridContext","context","useContext","useGrid","GridProvider","children","rowCount","setRowCount","useState","colCount","setColCount","setGrid","isMousePressed","setIsMousePressed","isVisualizing","setIsVisualizing","selectedAlgorithm","setSelectedAlgorithm","selectedMaze","setSelectedMaze","isRaceMode","setIsRaceMode","secondAlgorithm","setSecondAlgorithm","animationSpeed","setAnimationSpeed","visualizationStats","setVisualizationStats","toastMsg","setToastMsg","isHiddenTargetMode","setIsHiddenTargetMode","runHistory","setRunHistory","stored","useEffect","showToast","useCallback","msg","clearToast","addRunRecord","record","newRecord","prev","clearRunHistory","deleteRunRecord","id","resetBoard","resizeGrid","newRows","newCols","clampedRows","clampedCols","clearPath","currentGrid","clearAllWalls","value","jsx","NodeComponent","memo","isStart","isFinish","isWall","isVisited","isPath","onMouseDown","onMouseEnter","onMouseUp","onTouchStart","getNodeClassName","classNames","styles","e","prevProps","nextProps","Board","containerRef","useRef","nodeSize","setNodeSize","isEraserModeRef","isMousePressedRef","isDraggingStartRef","isDraggingFinishRef","calculateNodeSize","container","containerWidth","containerHeight","availableWidth","availableHeight","maxSizeByWidth","maxSizeByHeight","calculatedSize","resizeObserver","handleMouseDown","event","isEraserMode","handleTouchStart","handleMouseEnter","handleTouchMove","touch","element","nodeElement","handleTouchEnd","handleMouseUp","handleGlobalMouseUp","handleDragStart","handleContextMenu","boardStyle","Accordion","title","icon","defaultOpen","isOpen","setIsOpen","contentRef","contentHeight","setContentHeight","height","handleToggle","handleKeyDown","jsxs","ALGORITHM_OPTIONS","MAZE_OPTIONS","ControlPanel","onVisualize","onClearPath","onGenerateMaze","onVisualizeRace","isHeuristicAlgorithm","alg","handleAlgorithmChange","newAlgorithm","handleSecondAlgorithmChange","handleHiddenTargetToggle","newMode","handleRaceModeToggle","newRaceMode","defaultSecond","handleVisualize","handleMazeChange","handleGenerateMaze","handleRowChange","handleColChange","handleSpeedChange","newSpeed","getSpeedLabel","option","isDisabled","isSameAsAgent1","isDisabledByHiddenMode","Fragment","legendItems","Legend","orientation","compact","item","Toast","isExiting","setIsExiting","exitTimer","clearTimer","toastType","getIcon","toastClasses","DEFAULT_MIN_DURATION","requestIdCounter","useBenchmarking","workerRef","pendingRequests","getWorker","requestId","success","data","error","pending","errorObj","serializeGrid","findPositions","startPos","finishPos","runBenchmark","algorithm","minDuration","worker","positions","serializedGrid","resolve","reject","terminateWorker","useVisualization","isAnimating","timeoutIds","BENCHMARK_MIN_DURATION","clearAllTimeouts","clearVisualizationClasses","visitedNodes","pathNodes","visitedNodesSecond","pathNodesSecond","overlapNodes","pathOverlapNodes","clearVisualization","animateVisitedNodes","visitedNodesInOrder","speed","onComplete","i","timeoutId","animateShortestPath","nodesInShortestPathOrder","runAlgorithm","algorithmGrid","startNode","finishNode","astar","getAstarPath","bfs","getBfsPath","dfs","getDfsPath","greedyBestFirst","getGreedyPath","bidirectionalBFS","getBidirectionalPath","bidirectionalAStar","getBidirectionalAStarPath","jumpPointSearch","getJPSPath","dijkstra","getNodesInShortestPathOrder","visualizePathfinding","_setGrid","statsCallbacks","benchmarkResult","fallbackStart","fallbackTime","executionTime","pathFound","stats","pathDelay","clearWallClasses","animateMazeWalls","wallsInOrder","generateMaze","mazeType","resetGrid","clearedGrid","getRecursiveDivisionMaze","getRandomizedDFSMaze","getPrimsMaze","getSpiralMaze","getCellularAutomataMaze","wall","visualizeRace","algo1","algo2","benchmark1Result","benchmark2Result","b1","b2","createGridCopy","findNodes","g","start","finish","grid1","nodes1","fallback1Start","result1","fallback1Time","grid2","nodes2","fallback2Start","result2","fallback2Time","executionTime1","executionTime2","visited1","visited2","path1","path2","path1Found","path2Found","stats1","stats2","winner","raceStats","visitedByAgent1","visitedByAgent2","maxVisitedLen","node1","key1","element1","node2","key2","element2","path1Keys","path2Keys","maxPathLen","j","pathTimeoutId","pathNode1","pathNode2","winnerName","StatisticsSection","lazy","HistorySection","MainContent","statsSectionRef","isSidebarOpen","setIsSidebarOpen","hasGeneratedInitialMaze","setHasGeneratedInitialMaze","timer","toggleSidebar","closeSidebar","scrollToStats","_a","handleVisualizeRace","handleClearPath","Suspense","App","ReactDOM","React"],"ignoreList":[],"sources":["../../src/types/index.ts","../../src/utils/gridUtils.ts","../../src/context/GridContext.tsx","../../src/components/Node/NodeComponent.tsx","../../src/components/Board/Board.tsx","../../src/components/Controls/Accordion.tsx","../../src/components/Controls/ControlPanel.tsx","../../src/components/Legend/Legend.tsx","../../src/components/UI/Toast.tsx","../../src/hooks/useBenchmarking.ts","../../src/hooks/useVisualization.ts","../../src/App.tsx","../../src/main.tsx"],"sourcesContent":["/**\r\n * Node Interface - Core data model for each cell in the grid\r\n * As specified in Section 3.1 of the project requirements\r\n */\r\nexport interface Node {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  distance: number; // For Dijkstra/A* - initialized to Infinity\r\n  previousNode: Node | null; // For backtracking the shortest path\r\n}\r\n\r\n/**\r\n * Grid Type - 2D array of Nodes\r\n */\r\nexport type Grid = Node[][];\r\n\r\n/**\r\n * Algorithm Types\r\n */\r\nexport enum AlgorithmType {\r\n  DIJKSTRA = \"dijkstra\",\r\n  ASTAR = \"astar\",\r\n  BFS = \"bfs\",\r\n  DFS = \"dfs\",\r\n  GREEDY_BEST_FIRST = \"greedyBestFirst\",\r\n  BIDIRECTIONAL_BFS = \"bidirectionalBFS\",\r\n  BIDIRECTIONAL_ASTAR = \"bidirectionalAStar\",\r\n  JUMP_POINT_SEARCH = \"jumpPointSearch\",\r\n}\r\n\r\n/**\r\n * Maze Generation Types\r\n */\r\nexport enum MazeType {\r\n  RECURSIVE_DIVISION = \"recursiveDivision\",\r\n  RANDOMIZED_DFS = \"randomizedDFS\",\r\n  PRIMS = \"prims\",\r\n  SPIRAL = \"spiral\",\r\n  CELLULAR_AUTOMATA = \"cellularAutomata\",\r\n}\r\n\r\n/**\r\n * Node State for styling purposes\r\n */\r\nexport enum NodeState {\r\n  UNVISITED = \"unvisited\",\r\n  VISITED = \"visited\",\r\n  WALL = \"wall\",\r\n  START = \"start\",\r\n  FINISH = \"finish\",\r\n  PATH = \"path\",\r\n}\r\n\r\n/**\r\n * Algorithm Result - returned after algorithm execution\r\n */\r\nexport interface AlgorithmResult {\r\n  visitedNodesInOrder: Node[];\r\n  shortestPath: Node[];\r\n  executionTimeMs: number;\r\n  visitedCount: number;\r\n  pathLength: number;\r\n}\r\n\r\n/**\r\n * Run Record - stored in localStorage for history tracking\r\n */\r\nexport interface RunRecord {\r\n  id: string; // UUID\r\n  timestamp: number; // Unix timestamp for sorting\r\n  date: string; // ISO format for display\r\n  mode: \"Single\" | \"Race\";\r\n  algorithm1: string; // Display name of algorithm 1\r\n  algorithm2?: string; // Display name of algorithm 2 (Race mode only)\r\n  gridSize: string; // e.g., \"20x30\"\r\n  // Algorithm 1 stats\r\n  time1: number; // Execution time in ms\r\n  pathLength1: number;\r\n  visitedCount1: number;\r\n  // Algorithm 2 stats (Race mode only)\r\n  time2?: number;\r\n  pathLength2?: number;\r\n  visitedCount2?: number;\r\n  // Race mode result\r\n  winner?: string; // \"Algorithm 1 Name\" | \"Algorithm 2 Name\" | \"Tie\" | \"Both Failed\"\r\n}\r\n\r\n/**\r\n * Grid Configuration Constants\r\n */\r\nexport const GRID_ROWS = 20;\r\nexport const GRID_COLS = 30;\r\n// Default Start: Top-left corner (1,1) for nice padding from edge\r\nexport const DEFAULT_START_ROW = 1;\r\nexport const DEFAULT_START_COL = 1;\r\n// Default Finish: Center of the grid (calculated dynamically)\r\nexport const DEFAULT_FINISH_ROW = Math.floor(GRID_ROWS / 2);\r\nexport const DEFAULT_FINISH_COL = Math.floor(GRID_COLS / 2);\r\n","import { Node, Grid, GRID_ROWS, GRID_COLS } from \"../types\";\r\n\r\n/**\r\n * Creates a single Node with configurable start/finish positions\r\n */\r\nexport const createNode = (\r\n  row: number,\r\n  col: number,\r\n  startRow: number,\r\n  startCol: number,\r\n  finishRow: number,\r\n  finishCol: number\r\n): Node => {\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === startRow && col === startCol,\r\n    isFinish: row === finishRow && col === finishCol,\r\n    isWall: false,\r\n    isVisited: false,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\n/**\r\n * Calculates safe start/finish positions based on grid dimensions\r\n * Start: Top-left corner (1,1) with padding from edge\r\n * Finish: Exact center of the grid\r\n */\r\nexport const getSafeNodePositions = (\r\n  rows: number,\r\n  cols: number\r\n): {\r\n  startRow: number;\r\n  startCol: number;\r\n  finishRow: number;\r\n  finishCol: number;\r\n} => {\r\n  // Start node: Top-left corner with 1 cell padding from edge\r\n  // For very small grids (5x5), use row 1, col 1\r\n  const startRow = Math.min(1, rows - 2);\r\n  const startCol = Math.min(1, cols - 2);\r\n\r\n  // Finish node: Exact center of the grid\r\n  const finishRow = Math.floor(rows / 2);\r\n  const finishCol = Math.floor(cols / 2);\r\n\r\n  // Ensure start and finish don't overlap (for very small grids)\r\n  // If they would overlap, move finish slightly\r\n  if (startRow === finishRow && startCol === finishCol) {\r\n    // Move finish to bottom-right area for small grids\r\n    return {\r\n      startRow,\r\n      startCol,\r\n      finishRow: Math.max(startRow + 1, rows - 2),\r\n      finishCol: Math.max(startCol + 1, cols - 2),\r\n    };\r\n  }\r\n\r\n  return { startRow, startCol, finishRow, finishCol };\r\n};\r\n\r\n/**\r\n * Creates the initial grid with configurable dimensions\r\n * @param rows - Number of rows (default: GRID_ROWS = 30)\r\n * @param cols - Number of columns (default: GRID_COLS = 50)\r\n * Start and Finish nodes are placed safely within bounds\r\n */\r\nexport const getInitialGrid = (\r\n  rows: number = GRID_ROWS,\r\n  cols: number = GRID_COLS\r\n): Grid => {\r\n  const { startRow, startCol, finishRow, finishCol } = getSafeNodePositions(\r\n    rows,\r\n    cols\r\n  );\r\n  const grid: Grid = [];\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    const currentRow: Node[] = [];\r\n    for (let col = 0; col < cols; col++) {\r\n      currentRow.push(\r\n        createNode(row, col, startRow, startCol, finishRow, finishCol)\r\n      );\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n\r\n  return grid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with a wall toggled at the specified position\r\n */\r\nexport const getNewGridWithWallToggled = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow walls on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with a wall SET at the specified position (Draw mode)\r\n * Used for consistent drag-to-draw functionality\r\n */\r\nexport const getNewGridWithWallSet = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow walls on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Already a wall, no change needed\r\n  if (node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: true,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with wall REMOVED at the specified position (Eraser mode)\r\n * Used for Ctrl+Click/Drag erasing functionality\r\n */\r\nexport const getNewGridWithWallRemoved = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't modify start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Not a wall, no change needed\r\n  if (!node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: false,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Moves the start node to a new position\r\n * Auto-finds current Start position and overwrites walls at new position\r\n */\r\nexport const getNewGridWithStartMoved = (\r\n  grid: Grid,\r\n  newRow: number,\r\n  newCol: number\r\n): Grid => {\r\n  const targetNode = grid[newRow][newCol];\r\n\r\n  // Can't move to finish node or if already start\r\n  if (targetNode.isFinish || targetNode.isStart) {\r\n    return grid;\r\n  }\r\n\r\n  // Find current start position\r\n  let oldRow = -1;\r\n  let oldCol = -1;\r\n  for (let r = 0; r < grid.length; r++) {\r\n    for (let c = 0; c < grid[r].length; c++) {\r\n      if (grid[r][c].isStart) {\r\n        oldRow = r;\r\n        oldCol = c;\r\n        break;\r\n      }\r\n    }\r\n    if (oldRow !== -1) break;\r\n  }\r\n\r\n  // Safety check\r\n  if (oldRow === -1) return grid;\r\n\r\n  const newGrid = grid.map((row) => row.slice());\r\n\r\n  // Remove start from old position\r\n  newGrid[oldRow][oldCol] = {\r\n    ...newGrid[oldRow][oldCol],\r\n    isStart: false,\r\n  };\r\n\r\n  // Set start at new position (overwrites wall if present)\r\n  newGrid[newRow][newCol] = {\r\n    ...newGrid[newRow][newCol],\r\n    isStart: true,\r\n    isWall: false,\r\n  };\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Moves the finish node to a new position\r\n * Auto-finds current Finish position and overwrites walls at new position\r\n */\r\nexport const getNewGridWithFinishMoved = (\r\n  grid: Grid,\r\n  newRow: number,\r\n  newCol: number\r\n): Grid => {\r\n  const targetNode = grid[newRow][newCol];\r\n\r\n  // Can't move to start node or if already finish\r\n  if (targetNode.isStart || targetNode.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Find current finish position\r\n  let oldRow = -1;\r\n  let oldCol = -1;\r\n  for (let r = 0; r < grid.length; r++) {\r\n    for (let c = 0; c < grid[r].length; c++) {\r\n      if (grid[r][c].isFinish) {\r\n        oldRow = r;\r\n        oldCol = c;\r\n        break;\r\n      }\r\n    }\r\n    if (oldRow !== -1) break;\r\n  }\r\n\r\n  // Safety check\r\n  if (oldRow === -1) return grid;\r\n\r\n  const newGrid = grid.map((row) => row.slice());\r\n\r\n  // Remove finish from old position\r\n  newGrid[oldRow][oldCol] = {\r\n    ...newGrid[oldRow][oldCol],\r\n    isFinish: false,\r\n  };\r\n\r\n  // Set finish at new position (overwrites wall if present)\r\n  newGrid[newRow][newCol] = {\r\n    ...newGrid[newRow][newCol],\r\n    isFinish: true,\r\n    isWall: false,\r\n  };\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Resets the grid for a new pathfinding run (clears visited/path states)\r\n * Keeps walls, start, and finish intact\r\n */\r\nexport const resetGridForPathfinding = (grid: Grid): Grid => {\r\n  return grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isVisited: false,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n    }))\r\n  );\r\n};\r\n\r\n/**\r\n * Clears all walls from the grid\r\n */\r\nexport const clearWalls = (grid: Grid): Grid => {\r\n  return grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isWall: false,\r\n    }))\r\n  );\r\n};\r\n\r\n/**\r\n * Completely resets the grid to initial state\r\n */\r\nexport const resetGrid = (): Grid => {\r\n  return getInitialGrid();\r\n};\r\n\r\n/**\r\n * Gets the node at a specific position\r\n */\r\nexport const getNode = (grid: Grid, row: number, col: number): Node | null => {\r\n  if (row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS) {\r\n    return null;\r\n  }\r\n  return grid[row][col];\r\n};\r\n\r\n/**\r\n * Gets all neighboring nodes (up, down, left, right)\r\n */\r\nexport const getNeighbors = (grid: Grid, node: Node): Node[] => {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]); // Up\r\n  if (row < GRID_ROWS - 1) neighbors.push(grid[row + 1][col]); // Down\r\n  if (col > 0) neighbors.push(grid[row][col - 1]); // Left\r\n  if (col < GRID_COLS - 1) neighbors.push(grid[row][col + 1]); // Right\r\n\r\n  return neighbors;\r\n};\r\n\r\n/**\r\n * Gets unvisited neighbors that are not walls\r\n */\r\nexport const getUnvisitedNeighbors = (grid: Grid, node: Node): Node[] => {\r\n  return getNeighbors(grid, node).filter(\r\n    (neighbor) => !neighbor.isVisited && !neighbor.isWall\r\n  );\r\n};\r\n","import React, {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useCallback,\r\n  useEffect,\r\n  ReactNode,\r\n} from \"react\";\r\nimport {\r\n  Grid,\r\n  AlgorithmType,\r\n  MazeType,\r\n  RunRecord,\r\n  GRID_ROWS,\r\n  GRID_COLS,\r\n} from \"../types\";\r\nimport {\r\n  getInitialGrid,\r\n  resetGridForPathfinding,\r\n  clearWalls,\r\n} from \"../utils/gridUtils\";\r\nimport { AlgorithmStats, RaceStats } from \"../components/Modals/StatsModal\";\r\n\r\nconst HISTORY_STORAGE_KEY = \"pathfinder_run_history\";\r\nconst MAX_HISTORY_ITEMS = 50;\r\n\r\n/**\r\n * Available maze types for random selection\r\n */\r\nconst AVAILABLE_MAZE_TYPES: MazeType[] = [\r\n  MazeType.RECURSIVE_DIVISION,\r\n  MazeType.RANDOMIZED_DFS,\r\n  MazeType.PRIMS,\r\n  MazeType.SPIRAL,\r\n];\r\n\r\n/**\r\n * Get a random maze type from available options\r\n */\r\nconst getRandomMazeType = (): MazeType => {\r\n  const randomIndex = Math.floor(Math.random() * AVAILABLE_MAZE_TYPES.length);\r\n  return AVAILABLE_MAZE_TYPES[randomIndex];\r\n};\r\n\r\n/**\r\n * Grid Context Type Definition\r\n */\r\ninterface GridContextType {\r\n  // Grid State\r\n  grid: Grid;\r\n  setGrid: React.Dispatch<React.SetStateAction<Grid>>;\r\n\r\n  // Grid Dimensions\r\n  rowCount: number;\r\n  colCount: number;\r\n  resizeGrid: (newRows: number, newCols: number) => void;\r\n\r\n  // Mouse State (for wall drawing)\r\n  isMousePressed: boolean;\r\n  setIsMousePressed: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Visualization State\r\n  isVisualizing: boolean;\r\n  setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Algorithm Selection\r\n  selectedAlgorithm: AlgorithmType;\r\n  setSelectedAlgorithm: React.Dispatch<React.SetStateAction<AlgorithmType>>;\r\n\r\n  // Race Mode State\r\n  isRaceMode: boolean;\r\n  setIsRaceMode: React.Dispatch<React.SetStateAction<boolean>>;\r\n  secondAlgorithm: AlgorithmType | null;\r\n  setSecondAlgorithm: React.Dispatch<\r\n    React.SetStateAction<AlgorithmType | null>\r\n  >;\r\n\r\n  // Maze Selection\r\n  selectedMaze: MazeType;\r\n  setSelectedMaze: React.Dispatch<React.SetStateAction<MazeType>>;\r\n\r\n  // Speed Control (delay in ms)\r\n  animationSpeed: number;\r\n  setAnimationSpeed: React.Dispatch<React.SetStateAction<number>>;\r\n\r\n  // Visualization Stats (for Statistics Section)\r\n  visualizationStats: AlgorithmStats | RaceStats | null;\r\n  setVisualizationStats: React.Dispatch<\r\n    React.SetStateAction<AlgorithmStats | RaceStats | null>\r\n  >;\r\n\r\n  // Toast Notification State\r\n  toastMsg: string | null;\r\n  showToast: (msg: string) => void;\r\n  clearToast: () => void;\r\n\r\n  // Hidden Target Mode (Fog of War)\r\n  isHiddenTargetMode: boolean;\r\n  setIsHiddenTargetMode: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Run History\r\n  runHistory: RunRecord[];\r\n  addRunRecord: (record: Omit<RunRecord, \"id\" | \"timestamp\" | \"date\">) => void;\r\n  clearRunHistory: () => void;\r\n  deleteRunRecord: (id: string) => void;\r\n\r\n  // Helper Functions\r\n  resetBoard: () => void;\r\n  clearPath: () => void;\r\n  clearAllWalls: () => void;\r\n}\r\n\r\n/**\r\n * Default Context Value\r\n */\r\nconst defaultContextValue: GridContextType = {\r\n  grid: [],\r\n  setGrid: () => {},\r\n  rowCount: GRID_ROWS,\r\n  colCount: GRID_COLS,\r\n  resizeGrid: () => {},\r\n  isMousePressed: false,\r\n  setIsMousePressed: () => {},\r\n  isVisualizing: false,\r\n  setIsVisualizing: () => {},\r\n  selectedAlgorithm: AlgorithmType.DIJKSTRA,\r\n  setSelectedAlgorithm: () => {},\r\n  isRaceMode: false,\r\n  setIsRaceMode: () => {},\r\n  secondAlgorithm: null,\r\n  setSecondAlgorithm: () => {},\r\n  selectedMaze: MazeType.RECURSIVE_DIVISION,\r\n  setSelectedMaze: () => {},\r\n  animationSpeed: 10,\r\n  setAnimationSpeed: () => {},\r\n  visualizationStats: null,\r\n  setVisualizationStats: () => {},\r\n  toastMsg: null,\r\n  showToast: () => {},\r\n  clearToast: () => {},\r\n  isHiddenTargetMode: false,\r\n  setIsHiddenTargetMode: () => {},\r\n  runHistory: [],\r\n  addRunRecord: () => {},\r\n  clearRunHistory: () => {},\r\n  deleteRunRecord: () => {},\r\n  resetBoard: () => {},\r\n  clearPath: () => {},\r\n  clearAllWalls: () => {},\r\n};\r\n\r\n/**\r\n * Create the Context\r\n */\r\nconst GridContext = createContext<GridContextType>(defaultContextValue);\r\n\r\n/**\r\n * Custom Hook to use Grid Context\r\n */\r\nexport const useGridContext = (): GridContextType => {\r\n  const context = useContext(GridContext);\r\n  if (!context) {\r\n    throw new Error(\"useGridContext must be used within a GridProvider\");\r\n  }\r\n  return context;\r\n};\r\n\r\n// Alias for shorter import in components\r\nexport const useGrid = useGridContext;\r\n\r\n/**\r\n * Provider Props\r\n */\r\ninterface GridProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\n/**\r\n * Grid Provider Component\r\n */\r\nexport const GridProvider: React.FC<GridProviderProps> = ({ children }) => {\r\n  // Grid Dimension State\r\n  const [rowCount, setRowCount] = useState<number>(GRID_ROWS);\r\n  const [colCount, setColCount] = useState<number>(GRID_COLS);\r\n\r\n  // Core Grid State\r\n  const [grid, setGrid] = useState<Grid>(() =>\r\n    getInitialGrid(GRID_ROWS, GRID_COLS)\r\n  );\r\n\r\n  // Mouse State for wall drawing\r\n  const [isMousePressed, setIsMousePressed] = useState<boolean>(false);\r\n\r\n  // Visualization State\r\n  const [isVisualizing, setIsVisualizing] = useState<boolean>(false);\r\n\r\n  // Algorithm Selection\r\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState<AlgorithmType>(\r\n    AlgorithmType.DIJKSTRA\r\n  );\r\n\r\n  // Maze Selection - initialized with random maze type for first paint experience\r\n  const [selectedMaze, setSelectedMaze] = useState<MazeType>(getRandomMazeType);\r\n\r\n  // Race Mode State\r\n  const [isRaceMode, setIsRaceMode] = useState<boolean>(false);\r\n  const [secondAlgorithm, setSecondAlgorithm] = useState<AlgorithmType | null>(\r\n    null\r\n  );\r\n\r\n  // Animation Speed (delay between node animations in ms)\r\n  const [animationSpeed, setAnimationSpeed] = useState<number>(10);\r\n\r\n  // Visualization Stats (displayed in Statistics Section)\r\n  const [visualizationStats, setVisualizationStats] = useState<\r\n    AlgorithmStats | RaceStats | null\r\n  >(null);\r\n\r\n  // Toast Notification State\r\n  const [toastMsg, setToastMsg] = useState<string | null>(null);\r\n\r\n  // Hidden Target Mode State (Fog of War)\r\n  const [isHiddenTargetMode, setIsHiddenTargetMode] = useState<boolean>(false);\r\n\r\n  // Run History State with localStorage persistence\r\n  const [runHistory, setRunHistory] = useState<RunRecord[]>(() => {\r\n    try {\r\n      const stored = localStorage.getItem(HISTORY_STORAGE_KEY);\r\n      if (stored) {\r\n        return JSON.parse(stored) as RunRecord[];\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to load history from localStorage:\", error);\r\n      localStorage.removeItem(HISTORY_STORAGE_KEY);\r\n    }\r\n    return [];\r\n  });\r\n\r\n  // Persist history to localStorage whenever it changes\r\n  useEffect(() => {\r\n    try {\r\n      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(runHistory));\r\n    } catch (error) {\r\n      console.error(\"Failed to save history to localStorage:\", error);\r\n    }\r\n  }, [runHistory]);\r\n\r\n  /**\r\n   * Shows a toast notification message\r\n   */\r\n  const showToast = useCallback((msg: string): void => {\r\n    setToastMsg(msg);\r\n  }, []);\r\n\r\n  /**\r\n   * Clears the current toast notification\r\n   */\r\n  const clearToast = useCallback((): void => {\r\n    setToastMsg(null);\r\n  }, []);\r\n\r\n  /**\r\n   * Adds a new run record to history\r\n   */\r\n  const addRunRecord = useCallback(\r\n    (record: Omit<RunRecord, \"id\" | \"timestamp\" | \"date\">): void => {\r\n      const newRecord: RunRecord = {\r\n        ...record,\r\n        id: crypto.randomUUID(),\r\n        timestamp: Date.now(),\r\n        date: new Date().toISOString(),\r\n      };\r\n      setRunHistory((prev) => {\r\n        const updated = [newRecord, ...prev];\r\n        return updated.slice(0, MAX_HISTORY_ITEMS);\r\n      });\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Clears all run history\r\n   */\r\n  const clearRunHistory = useCallback((): void => {\r\n    setRunHistory([]);\r\n  }, []);\r\n\r\n  /**\r\n   * Deletes a single run record by ID\r\n   */\r\n  const deleteRunRecord = useCallback((id: string): void => {\r\n    setRunHistory((prev) => prev.filter((record) => record.id !== id));\r\n  }, []);\r\n\r\n  /**\r\n   * Resets the entire board to initial state with current dimensions\r\n   */\r\n  const resetBoard = useCallback((): void => {\r\n    if (isVisualizing) return; // Don't reset while visualizing\r\n    setGrid(getInitialGrid(rowCount, colCount));\r\n  }, [isVisualizing, rowCount, colCount]);\r\n\r\n  /**\r\n   * Resizes the grid to new dimensions\r\n   * Generates a completely new grid (walls are cleared)\r\n   */\r\n  const resizeGrid = useCallback(\r\n    (newRows: number, newCols: number): void => {\r\n      if (isVisualizing) return; // Don't resize while visualizing\r\n\r\n      // Clamp values to reasonable bounds\r\n      const clampedRows = Math.max(5, Math.min(50, newRows));\r\n      const clampedCols = Math.max(5, Math.min(80, newCols));\r\n\r\n      setRowCount(clampedRows);\r\n      setColCount(clampedCols);\r\n      setGrid(getInitialGrid(clampedRows, clampedCols));\r\n    },\r\n    [isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Clears only the path/visited nodes, keeps walls\r\n   */\r\n  const clearPath = useCallback((): void => {\r\n    if (isVisualizing) return;\r\n    setGrid((currentGrid) => resetGridForPathfinding(currentGrid));\r\n  }, [isVisualizing]);\r\n\r\n  /**\r\n   * Clears all walls from the grid\r\n   */\r\n  const clearAllWalls = useCallback((): void => {\r\n    if (isVisualizing) return;\r\n    setGrid((currentGrid) => clearWalls(currentGrid));\r\n  }, [isVisualizing]);\r\n\r\n  const value: GridContextType = {\r\n    grid,\r\n    setGrid,\r\n    rowCount,\r\n    colCount,\r\n    resizeGrid,\r\n    isMousePressed,\r\n    setIsMousePressed,\r\n    isVisualizing,\r\n    setIsVisualizing,\r\n    selectedAlgorithm,\r\n    setSelectedAlgorithm,\r\n    isRaceMode,\r\n    setIsRaceMode,\r\n    secondAlgorithm,\r\n    setSecondAlgorithm,\r\n    selectedMaze,\r\n    setSelectedMaze,\r\n    animationSpeed,\r\n    setAnimationSpeed,\r\n    visualizationStats,\r\n    setVisualizationStats,\r\n    toastMsg,\r\n    showToast,\r\n    clearToast,\r\n    isHiddenTargetMode,\r\n    setIsHiddenTargetMode,\r\n    runHistory,\r\n    addRunRecord,\r\n    clearRunHistory,\r\n    deleteRunRecord,\r\n    resetBoard,\r\n    clearPath,\r\n    clearAllWalls,\r\n  };\r\n\r\n  return <GridContext.Provider value={value}>{children}</GridContext.Provider>;\r\n};\r\n\r\nexport default GridContext;\r\n","import React, { memo } from \"react\";\r\nimport { useGridContext } from \"../../context/GridContext\";\r\nimport styles from \"./Node.module.css\";\r\n\r\n/**\r\n * Props for the NodeComponent\r\n * Extends Node properties with event handlers\r\n */\r\nexport interface NodeComponentProps {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  isPath?: boolean; // For shortest path highlighting\r\n  onMouseDown: (row: number, col: number, event: React.MouseEvent) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n  onTouchStart?: (row: number, col: number, event: React.TouchEvent) => void;\r\n}\r\n\r\n/**\r\n * NodeComponent - Represents a single cell in the grid\r\n *\r\n * Wrapped in React.memo to prevent unnecessary re-renders\r\n * of all 1500 nodes during visualization updates.\r\n * Only re-renders when its own props change.\r\n */\r\nconst NodeComponent: React.FC<NodeComponentProps> = memo(\r\n  ({\r\n    row,\r\n    col,\r\n    isStart,\r\n    isFinish,\r\n    isWall,\r\n    isVisited,\r\n    isPath = false,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n    onMouseUp,\r\n    onTouchStart,\r\n  }) => {\r\n    const { isHiddenTargetMode } = useGridContext();\r\n\r\n    /**\r\n     * Compute the dynamic class name based on node state\r\n     * Priority order: Start > Finish > Path > Wall > Visited > Default\r\n     *\r\n     * Hidden Target Mode: If finish node is hidden and not yet visited,\r\n     * show it with a blinking animation (visible to user, hidden from algorithm)\r\n     */\r\n    const getNodeClassName = (): string => {\r\n      const classNames = [styles.node];\r\n\r\n      if (isStart) {\r\n        classNames.push(styles[\"node-start\"]);\r\n      } else if (isFinish) {\r\n        // Hidden Target Mode: Show blinking animation until discovered by algorithm\r\n        if (isHiddenTargetMode && !isVisited) {\r\n          classNames.push(styles[\"node-finish-hidden\"]);\r\n        } else {\r\n          classNames.push(styles[\"node-finish\"]);\r\n        }\r\n      } else if (isPath) {\r\n        classNames.push(styles[\"node-path\"]);\r\n      } else if (isWall) {\r\n        classNames.push(styles[\"node-wall\"]);\r\n      } else if (isVisited) {\r\n        classNames.push(styles[\"node-visited\"]);\r\n      }\r\n\r\n      return classNames.join(\" \");\r\n    };\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={getNodeClassName()}\r\n        data-row={row}\r\n        data-col={col}\r\n        onMouseDown={(e) => onMouseDown(row, col, e)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={onMouseUp}\r\n        onTouchStart={\r\n          onTouchStart ? (e) => onTouchStart(row, col, e) : undefined\r\n        }\r\n        role=\"button\"\r\n        tabIndex={-1}\r\n        aria-label={`Node at row ${row}, column ${col}${\r\n          isStart ? \" (Start)\" : \"\"\r\n        }${isFinish ? \" (Finish)\" : \"\"}${isWall ? \" (Wall)\" : \"\"}`}\r\n      />\r\n    );\r\n  },\r\n  // Custom comparison function for memo\r\n  (prevProps, nextProps) => {\r\n    return (\r\n      prevProps.isStart === nextProps.isStart &&\r\n      prevProps.isFinish === nextProps.isFinish &&\r\n      prevProps.isWall === nextProps.isWall &&\r\n      prevProps.isVisited === nextProps.isVisited &&\r\n      prevProps.isPath === nextProps.isPath &&\r\n      prevProps.row === nextProps.row &&\r\n      prevProps.col === nextProps.col\r\n    );\r\n  }\r\n);\r\n\r\nNodeComponent.displayName = \"NodeComponent\";\r\n\r\nexport default NodeComponent;\r\n","import React, { useCallback, useRef, useEffect, useState } from \"react\";\r\nimport { useGridContext } from \"../../context/GridContext\";\r\nimport NodeComponent from \"../Node\";\r\nimport {\r\n  getNewGridWithWallSet,\r\n  getNewGridWithWallRemoved,\r\n  getNewGridWithStartMoved,\r\n  getNewGridWithFinishMoved,\r\n} from \"../../utils/gridUtils\";\r\nimport styles from \"./Board.module.css\";\r\n\r\n/**\r\n * Board Component - Renders the 2D grid of nodes\r\n *\r\n * Uses GridContext for state management and handles\r\n * mouse events for wall drawing functionality.\r\n *\r\n * Features:\r\n * - Dynamic node sizing based on container dimensions\r\n * - Standard Click/Drag: Draw walls\r\n * - Ctrl/Cmd + Click/Drag: Erase walls (Eraser mode)\r\n */\r\nconst Board: React.FC = () => {\r\n  const {\r\n    grid,\r\n    setGrid,\r\n    setIsMousePressed,\r\n    isVisualizing,\r\n    colCount,\r\n    rowCount,\r\n    isHiddenTargetMode,\r\n  } = useGridContext();\r\n\r\n  // Ref for the board container to measure available space\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Dynamic node size state\r\n  const [nodeSize, setNodeSize] = useState<number>(25);\r\n\r\n  // Track eraser mode - persists throughout the drag operation\r\n  const isEraserModeRef = useRef<boolean>(false);\r\n  // Track mouse pressed state with ref to avoid stale closure issues\r\n  const isMousePressedRef = useRef<boolean>(false);\r\n  // Track dragging Start node\r\n  const isDraggingStartRef = useRef<boolean>(false);\r\n  // Track dragging Finish node\r\n  const isDraggingFinishRef = useRef<boolean>(false);\r\n\r\n  /**\r\n   * Calculate and set the optimal node size based on container dimensions\r\n   * Ensures the entire grid fits without scrollbars\r\n   */\r\n  const calculateNodeSize = useCallback(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const container = containerRef.current;\r\n    const containerWidth = container.clientWidth;\r\n    const containerHeight = container.clientHeight;\r\n\r\n    // Account for border (2px on each side = 4px total)\r\n    const availableWidth = containerWidth - 4;\r\n    const availableHeight = containerHeight - 4;\r\n\r\n    // Calculate max size that fits both dimensions\r\n    const maxSizeByWidth = availableWidth / colCount;\r\n    const maxSizeByHeight = availableHeight / rowCount;\r\n\r\n    // Use the smaller value to ensure grid fits in both dimensions\r\n    // Floor to avoid sub-pixel rendering issues, min 10px for usability\r\n    const calculatedSize = Math.max(\r\n      10,\r\n      Math.floor(Math.min(maxSizeByWidth, maxSizeByHeight))\r\n    );\r\n\r\n    setNodeSize(calculatedSize);\r\n  }, [colCount, rowCount]);\r\n\r\n  /**\r\n   * ResizeObserver to recalculate node size when container changes\r\n   */\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    // Initial calculation\r\n    calculateNodeSize();\r\n\r\n    // Create ResizeObserver to watch for container size changes\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      calculateNodeSize();\r\n    });\r\n\r\n    resizeObserver.observe(container);\r\n\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [calculateNodeSize]);\r\n\r\n  /**\r\n   * Recalculate when grid dimensions change\r\n   */\r\n  useEffect(() => {\r\n    calculateNodeSize();\r\n  }, [rowCount, colCount, calculateNodeSize]);\r\n\r\n  /**\r\n   * Handle mouse down on a node - starts wall drawing/erasing or Start/Finish dragging\r\n   * Priority: Start node drag > Finish node drag > Wall drawing/erasing\r\n   * Ctrl/Cmd + Click activates eraser mode (for walls only)\r\n   */\r\n  const handleMouseDown = useCallback(\r\n    (row: number, col: number, event: React.MouseEvent): void => {\r\n      // Prevent default browser behavior (e.g., Ctrl+Click selection on Windows)\r\n      event.preventDefault();\r\n\r\n      if (isVisualizing) return;\r\n\r\n      const node = grid[row][col];\r\n      isMousePressedRef.current = true;\r\n      setIsMousePressed(true);\r\n\r\n      // Priority 1: Start node - begin dragging\r\n      if (node.isStart) {\r\n        isDraggingStartRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 2: Finish node - begin dragging\r\n      if (node.isFinish) {\r\n        // Hidden Target Mode: Prevent dragging the finish node when it's hidden\r\n        if (isHiddenTargetMode) {\r\n          return; // Do nothing - user shouldn't move invisible target\r\n        }\r\n        // Hidden Target Mode: Prevent dragging the finish node when it's hidden\r\n        if (isHiddenTargetMode) {\r\n          return; // Do nothing - user shouldn't move invisible target\r\n        }\r\n        isDraggingFinishRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 3: Wall drawing/erasing\r\n      const isEraserMode = event.ctrlKey || event.metaKey;\r\n      isEraserModeRef.current = isEraserMode;\r\n\r\n      // Use functional update to always get latest grid state\r\n      setGrid((currentGrid) => {\r\n        if (isEraserMode) {\r\n          return getNewGridWithWallRemoved(currentGrid, row, col);\r\n        } else {\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [grid, setGrid, setIsMousePressed, isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Handle touch start on a node - mobile equivalent of mousedown\r\n   * Starts wall drawing or Start/Finish dragging\r\n   */\r\n  const handleTouchStart = useCallback(\r\n    (row: number, col: number, event: React.TouchEvent): void => {\r\n      event.preventDefault(); // Prevent scrolling while drawing\r\n\r\n      if (isVisualizing) return;\r\n\r\n      const node = grid[row][col];\r\n      isMousePressedRef.current = true;\r\n      setIsMousePressed(true);\r\n      isEraserModeRef.current = false; // No eraser mode on touch\r\n\r\n      // Priority 1: Start node - begin dragging\r\n      if (node.isStart) {\r\n        isDraggingStartRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 2: Finish node - begin dragging\r\n      if (node.isFinish) {\r\n        isDraggingFinishRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 3: Wall drawing (toggle wall state)\r\n      setGrid((currentGrid) => {\r\n        const currentNode = currentGrid[row][col];\r\n        if (currentNode.isWall) {\r\n          return getNewGridWithWallRemoved(currentGrid, row, col);\r\n        } else {\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [grid, setGrid, setIsMousePressed, isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Handle mouse enter on a node - continues wall drawing/erasing or Start/Finish dragging\r\n   * Maintains the mode (draw/erase/drag) that was set on mouse down\r\n   */\r\n  const handleMouseEnter = useCallback(\r\n    (row: number, col: number): void => {\r\n      // Use ref to check mouse state to avoid stale closure\r\n      if (!isMousePressedRef.current || isVisualizing) return;\r\n\r\n      // Handle Start node dragging\r\n      if (isDraggingStartRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithStartMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle Finish node dragging\r\n      if (isDraggingFinishRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithFinishMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle wall drawing/erasing\r\n      setGrid((currentGrid) => {\r\n        if (isEraserModeRef.current) {\r\n          return getNewGridWithWallRemoved(currentGrid, row, col);\r\n        } else {\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [setGrid, isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Handle touch move - mobile equivalent of mouseenter\r\n   * Uses document.elementFromPoint to find which node is under the finger\r\n   */\r\n  const handleTouchMove = useCallback(\r\n    (event: React.TouchEvent): void => {\r\n      if (!isMousePressedRef.current || isVisualizing) return;\r\n\r\n      const touch = event.touches[0];\r\n      const element = document.elementFromPoint(touch.clientX, touch.clientY);\r\n\r\n      if (!element) return;\r\n\r\n      // Find the node element (may be the element or a parent)\r\n      const nodeElement = element.closest(\"[data-row][data-col]\");\r\n      if (!nodeElement) return;\r\n\r\n      const row = parseInt(nodeElement.getAttribute(\"data-row\") || \"-1\", 10);\r\n      const col = parseInt(nodeElement.getAttribute(\"data-col\") || \"-1\", 10);\r\n\r\n      if (row < 0 || col < 0 || row >= rowCount || col >= colCount) return;\r\n\r\n      // Handle Start node dragging\r\n      if (isDraggingStartRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithStartMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle Finish node dragging\r\n      if (isDraggingFinishRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithFinishMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle wall drawing (always add walls on touch move)\r\n      setGrid((currentGrid) => getNewGridWithWallSet(currentGrid, row, col));\r\n    },\r\n    [setGrid, isVisualizing, rowCount, colCount]\r\n  );\r\n\r\n  /**\r\n   * Handle touch end - mobile equivalent of mouseup\r\n   */\r\n  const handleTouchEnd = useCallback((): void => {\r\n    isMousePressedRef.current = false;\r\n    isEraserModeRef.current = false;\r\n    isDraggingStartRef.current = false;\r\n    isDraggingFinishRef.current = false;\r\n    setIsMousePressed(false);\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Handle mouse up - stops all interactions (wall drawing/erasing, Start/Finish dragging)\r\n   * Resets all mode refs for the next interaction\r\n   */\r\n  const handleMouseUp = useCallback((): void => {\r\n    isMousePressedRef.current = false;\r\n    isEraserModeRef.current = false;\r\n    isDraggingStartRef.current = false;\r\n    isDraggingFinishRef.current = false;\r\n    setIsMousePressed(false);\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Global mouseup listener to handle edge cases where mouseup\r\n   * fires outside of any node (e.g., clicking on tile edges)\r\n   */\r\n  useEffect(() => {\r\n    const handleGlobalMouseUp = (): void => {\r\n      if (isMousePressedRef.current) {\r\n        isMousePressedRef.current = false;\r\n        isEraserModeRef.current = false;\r\n        isDraggingStartRef.current = false;\r\n        isDraggingFinishRef.current = false;\r\n        setIsMousePressed(false);\r\n      }\r\n    };\r\n\r\n    // Listen to mouseup on the entire document\r\n    document.addEventListener(\"mouseup\", handleGlobalMouseUp);\r\n\r\n    return () => {\r\n      document.removeEventListener(\"mouseup\", handleGlobalMouseUp);\r\n    };\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Prevent default drag behavior on the board\r\n   */\r\n  const handleDragStart = (e: React.DragEvent): void => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Prevent context menu on right-click or Ctrl+click\r\n   */\r\n  const handleContextMenu = (e: React.MouseEvent): void => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  // Dynamic grid styling with calculated node size\r\n  const boardStyle: React.CSSProperties = {\r\n    display: \"grid\",\r\n    gridTemplateColumns: `repeat(${colCount}, ${nodeSize}px)`,\r\n    gridTemplateRows: `repeat(${rowCount}, ${nodeSize}px)`,\r\n    // Set CSS variable for node components to use\r\n    [\"--node-size\" as string]: `${nodeSize}px`,\r\n  };\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={styles.boardContainer}\r\n      onMouseLeave={handleMouseUp}\r\n      onDragStart={handleDragStart}\r\n      onContextMenu={handleContextMenu}\r\n      onTouchMove={handleTouchMove}\r\n      onTouchEnd={handleTouchEnd}\r\n    >\r\n      {/* eslint-disable-next-line react/forbid-dom-props */}\r\n      <div\r\n        className={styles.board}\r\n        style={boardStyle}\r\n        role=\"presentation\"\r\n        aria-label=\"Pathfinding Grid\"\r\n      >\r\n        {grid.map((row) =>\r\n          row.map((node) => (\r\n            <NodeComponent\r\n              key={`${node.row}-${node.col}`}\r\n              row={node.row}\r\n              col={node.col}\r\n              isStart={node.isStart}\r\n              isFinish={node.isFinish}\r\n              isWall={node.isWall}\r\n              isVisited={node.isVisited}\r\n              onMouseDown={handleMouseDown}\r\n              onMouseEnter={handleMouseEnter}\r\n              onMouseUp={handleMouseUp}\r\n              onTouchStart={handleTouchStart}\r\n            />\r\n          ))\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Board;\r\n","/**\r\n * Accordion Component\r\n * Reusable collapsible section for grouped controls\r\n * \r\n * Features:\r\n * - Smooth expand/collapse animation\r\n * - Chevron icon rotation\r\n * - Dark minimalist styling\r\n * - Accessible keyboard navigation\r\n */\r\n\r\nimport React, { useState, useRef, useEffect } from 'react';\r\nimport styles from './Accordion.module.css';\r\n\r\ninterface AccordionProps {\r\n  title: string;\r\n  icon?: string;\r\n  children: React.ReactNode;\r\n  defaultOpen?: boolean;\r\n}\r\n\r\nconst Accordion: React.FC<AccordionProps> = ({ \r\n  title, \r\n  icon, \r\n  children, \r\n  defaultOpen = false \r\n}) => {\r\n  const [isOpen, setIsOpen] = useState(defaultOpen);\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [contentHeight, setContentHeight] = useState<number | undefined>(\r\n    defaultOpen ? undefined : 0\r\n  );\r\n\r\n  // Update height when content changes or accordion opens/closes\r\n  useEffect(() => {\r\n    if (contentRef.current) {\r\n      const height = contentRef.current.scrollHeight;\r\n      setContentHeight(isOpen ? height : 0);\r\n    }\r\n  }, [isOpen, children]);\r\n\r\n  const handleToggle = () => {\r\n    setIsOpen(!isOpen);\r\n  };\r\n\r\n  const handleKeyDown = (e: React.KeyboardEvent) => {\r\n    if (e.key === 'Enter' || e.key === ' ') {\r\n      e.preventDefault();\r\n      handleToggle();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.accordion} ${isOpen ? styles.open : ''}`}>\r\n      <button\r\n        className={styles.header}\r\n        onClick={handleToggle}\r\n        onKeyDown={handleKeyDown}\r\n        aria-expanded={isOpen ? \"true\" : \"false\"}\r\n        type=\"button\"\r\n      >\r\n        <span className={styles.titleWrapper}>\r\n          {icon && <span className={styles.icon}>{icon}</span>}\r\n          <span className={styles.title}>{title}</span>\r\n        </span>\r\n        <svg\r\n          className={`${styles.chevron} ${isOpen ? styles.chevronOpen : ''}`}\r\n          width=\"16\"\r\n          height=\"16\"\r\n          viewBox=\"0 0 16 16\"\r\n          fill=\"none\"\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n        >\r\n          <path\r\n            d=\"M4 6L8 10L12 6\"\r\n            stroke=\"currentColor\"\r\n            strokeWidth=\"2\"\r\n            strokeLinecap=\"round\"\r\n            strokeLinejoin=\"round\"\r\n          />\r\n        </svg>\r\n      </button>\r\n      <div\r\n        className={styles.contentWrapper}\r\n        style={{ height: contentHeight !== undefined ? `${contentHeight}px` : 'auto' }}\r\n      >\r\n        <div ref={contentRef} className={styles.content}>\r\n          {children}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Accordion;\r\n","/**\r\n * ControlPanel Component\r\n * Professional sidebar with grouped accordion sections\r\n *\r\n * Redesigned with clean, minimalist UI featuring:\r\n * - Collapsible accordion sections\r\n * - Logical grouping of controls\r\n * - Prominent primary CTA\r\n * - Dark theme with subtle accents\r\n */\r\n\r\nimport React from \"react\";\r\nimport { useGridContext } from \"../../context/GridContext\";\r\nimport { AlgorithmType, MazeType } from \"../../types\";\r\nimport Accordion from \"./Accordion\";\r\nimport styles from \"./ControlPanel.module.css\";\r\n\r\n/**\r\n * Props for the ControlPanel component\r\n */\r\ninterface ControlPanelProps {\r\n  onVisualize: () => void;\r\n  onClearPath: () => void;\r\n  onGenerateMaze: (mazeType: MazeType) => void;\r\n  onVisualizeRace: () => void;\r\n}\r\n\r\n/**\r\n * Algorithm options for the dropdown\r\n * Note: A* and Greedy Best-First use heuristics and should be disabled in Hidden Target Mode\r\n */\r\nconst ALGORITHM_OPTIONS: {\r\n  value: AlgorithmType;\r\n  label: string;\r\n  usesHeuristic: boolean;\r\n}[] = [\r\n  {\r\n    value: AlgorithmType.DIJKSTRA,\r\n    label: \"Dijkstra's Algorithm\",\r\n    usesHeuristic: false,\r\n  },\r\n  { value: AlgorithmType.ASTAR, label: \"A* Search\", usesHeuristic: true },\r\n  {\r\n    value: AlgorithmType.GREEDY_BEST_FIRST,\r\n    label: \"Greedy Best-First\",\r\n    usesHeuristic: true,\r\n  },\r\n  {\r\n    value: AlgorithmType.BFS,\r\n    label: \"Breadth-First Search\",\r\n    usesHeuristic: false,\r\n  },\r\n  {\r\n    value: AlgorithmType.DFS,\r\n    label: \"Depth-First Search\",\r\n    usesHeuristic: false,\r\n  },\r\n  {\r\n    value: AlgorithmType.BIDIRECTIONAL_BFS,\r\n    label: \"Bidirectional Swarm\",\r\n    usesHeuristic: true, // Needs target location to search from both ends\r\n  },\r\n  {\r\n    value: AlgorithmType.BIDIRECTIONAL_ASTAR,\r\n    label: \"Bidirectional A*\",\r\n    usesHeuristic: true,\r\n  },\r\n  {\r\n    value: AlgorithmType.JUMP_POINT_SEARCH,\r\n    label: \"Jump Point Search\",\r\n    usesHeuristic: true, // Uses heuristic like A*\r\n  },\r\n];\r\n\r\n/**\r\n * Maze generation options for the dropdown\r\n */\r\nconst MAZE_OPTIONS: { value: MazeType; label: string }[] = [\r\n  { value: MazeType.RECURSIVE_DIVISION, label: \"Recursive Division\" },\r\n  { value: MazeType.RANDOMIZED_DFS, label: \"Randomized DFS\" },\r\n  { value: MazeType.PRIMS, label: \"Prim's Algorithm\" },\r\n  { value: MazeType.SPIRAL, label: \"Spiral Pattern\" },\r\n  { value: MazeType.CELLULAR_AUTOMATA, label: \"Cellular Automata\" },\r\n];\r\n\r\n/**\r\n * ControlPanel - Redesigned sidebar with accordion groups\r\n */\r\nconst ControlPanel: React.FC<ControlPanelProps> = ({\r\n  onVisualize,\r\n  onClearPath,\r\n  onGenerateMaze,\r\n  onVisualizeRace,\r\n}) => {\r\n  const {\r\n    selectedAlgorithm,\r\n    setSelectedAlgorithm,\r\n    selectedMaze,\r\n    setSelectedMaze,\r\n    isVisualizing,\r\n    isRaceMode,\r\n    setIsRaceMode,\r\n    secondAlgorithm,\r\n    setSecondAlgorithm,\r\n    rowCount,\r\n    colCount,\r\n    resizeGrid,\r\n    resetBoard,\r\n    clearAllWalls,\r\n    animationSpeed,\r\n    setAnimationSpeed,\r\n    isHiddenTargetMode,\r\n    setIsHiddenTargetMode,\r\n  } = useGridContext();\r\n\r\n  // === Handlers ===\r\n\r\n  /**\r\n   * Helper to check if an algorithm needs visible target\r\n   * (heuristic-based or bidirectional algorithms that search from both ends)\r\n   */\r\n  const isHeuristicAlgorithm = (alg: AlgorithmType): boolean => {\r\n    return (\r\n      alg === AlgorithmType.ASTAR ||\r\n      alg === AlgorithmType.GREEDY_BEST_FIRST ||\r\n      alg === AlgorithmType.BIDIRECTIONAL_ASTAR ||\r\n      alg === AlgorithmType.BIDIRECTIONAL_BFS ||\r\n      alg === AlgorithmType.JUMP_POINT_SEARCH\r\n    );\r\n  };\r\n\r\n  const handleAlgorithmChange = (\r\n    e: React.ChangeEvent<HTMLSelectElement>\r\n  ): void => {\r\n    const newAlgorithm = e.target.value as AlgorithmType;\r\n    setSelectedAlgorithm(newAlgorithm);\r\n\r\n    // If hidden target mode is on and user selects a heuristic algorithm, switch to Dijkstra\r\n    if (isHiddenTargetMode && isHeuristicAlgorithm(newAlgorithm)) {\r\n      setSelectedAlgorithm(AlgorithmType.DIJKSTRA);\r\n    }\r\n  };\r\n\r\n  const handleSecondAlgorithmChange = (\r\n    e: React.ChangeEvent<HTMLSelectElement>\r\n  ): void => {\r\n    const newAlgorithm = e.target.value as AlgorithmType;\r\n    setSecondAlgorithm(newAlgorithm);\r\n\r\n    // If hidden target mode is on and user selects a heuristic algorithm, switch to BFS\r\n    if (isHiddenTargetMode && isHeuristicAlgorithm(newAlgorithm)) {\r\n      setSecondAlgorithm(AlgorithmType.BFS);\r\n    }\r\n  };\r\n\r\n  const handleHiddenTargetToggle = (): void => {\r\n    if (isVisualizing) return;\r\n    const newMode = !isHiddenTargetMode;\r\n    setIsHiddenTargetMode(newMode);\r\n\r\n    // If enabling hidden target mode and a heuristic algorithm is selected, switch to blind search\r\n    if (newMode) {\r\n      if (isHeuristicAlgorithm(selectedAlgorithm)) {\r\n        setSelectedAlgorithm(AlgorithmType.DIJKSTRA);\r\n      }\r\n      if (secondAlgorithm && isHeuristicAlgorithm(secondAlgorithm)) {\r\n        setSecondAlgorithm(AlgorithmType.BFS);\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleRaceModeToggle = (): void => {\r\n    if (isVisualizing) return;\r\n    const newRaceMode = !isRaceMode;\r\n    setIsRaceMode(newRaceMode);\r\n    if (newRaceMode && !secondAlgorithm) {\r\n      const defaultSecond =\r\n        selectedAlgorithm === AlgorithmType.DIJKSTRA\r\n          ? AlgorithmType.ASTAR\r\n          : AlgorithmType.DIJKSTRA;\r\n      setSecondAlgorithm(defaultSecond);\r\n    }\r\n  };\r\n\r\n  const handleVisualize = (): void => {\r\n    if (isRaceMode && secondAlgorithm) {\r\n      onVisualizeRace();\r\n    } else {\r\n      onVisualize();\r\n    }\r\n  };\r\n\r\n  const handleMazeChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {\r\n    const value = e.target.value as MazeType;\r\n    setSelectedMaze(value);\r\n  };\r\n\r\n  const handleGenerateMaze = (): void => {\r\n    onGenerateMaze(selectedMaze);\r\n  };\r\n\r\n  const handleRowChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newRows = parseInt(e.target.value, 10);\r\n    resizeGrid(newRows, colCount);\r\n  };\r\n\r\n  const handleColChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newCols = parseInt(e.target.value, 10);\r\n    resizeGrid(rowCount, newCols);\r\n  };\r\n\r\n  const handleSpeedChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newSpeed = parseInt(e.target.value, 10);\r\n    setAnimationSpeed(newSpeed);\r\n  };\r\n\r\n  const getSpeedLabel = (): string => {\r\n    if (animationSpeed <= 5) return \"Very Fast\";\r\n    if (animationSpeed <= 10) return \"Fast\";\r\n    if (animationSpeed <= 20) return \"Normal\";\r\n    if (animationSpeed <= 40) return \"Slow\";\r\n    return \"Very Slow\";\r\n  };\r\n\r\n  return (\r\n    <aside className={styles.panel}>\r\n      {/* Panel Header */}\r\n      <header className={styles.panelHeader}>\r\n        <h2 className={styles.panelTitle}>Controls</h2>\r\n        <p className={styles.panelSubtitle}>Configure & Visualize</p>\r\n      </header>\r\n\r\n      {/* Accordion Sections */}\r\n      <div className={styles.accordionContainer}>\r\n        {/* === Section 1: Pathfinding Algorithms === */}\r\n        <Accordion title=\"Pathfinding Algorithms\" icon=\"\" defaultOpen={true}>\r\n          {/* Algorithm Selection */}\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>Algorithm</label>\r\n            <select\r\n              value={selectedAlgorithm}\r\n              onChange={handleAlgorithmChange}\r\n              disabled={isVisualizing}\r\n              className={styles.select}\r\n              title=\"Select pathfinding algorithm\"\r\n            >\r\n              {ALGORITHM_OPTIONS.map((option) => {\r\n                // Disable heuristic algorithms in Hidden Target Mode (require known target)\r\n                const isDisabled = isHiddenTargetMode && option.usesHeuristic;\r\n                return (\r\n                  <option\r\n                    key={option.value}\r\n                    value={option.value}\r\n                    disabled={isDisabled}\r\n                  >\r\n                    {option.label}\r\n                    {isDisabled ? \" (Requires Visible Target)\" : \"\"}\r\n                  </option>\r\n                );\r\n              })}\r\n            </select>\r\n            {isHiddenTargetMode && (\r\n              <p className={styles.hint}>\r\n                 Heuristic algorithms disabled in Hidden Mode\r\n              </p>\r\n            )}\r\n          </div>\r\n\r\n          {/* Hidden Target Mode Toggle */}\r\n          <div className={styles.toggleRow}>\r\n            <span className={styles.toggleLabel}> Hidden Target</span>\r\n            <button\r\n              type=\"button\"\r\n              className={`${styles.toggle} ${\r\n                isHiddenTargetMode ? styles.toggleActive : \"\"\r\n              }`}\r\n              onClick={handleHiddenTargetToggle}\r\n              disabled={isVisualizing}\r\n              aria-pressed={isHiddenTargetMode}\r\n              title=\"Hide target node (Fog of War mode)\"\r\n            >\r\n              <span className={styles.toggleKnob} />\r\n            </button>\r\n          </div>\r\n\r\n          {/* Race Mode Toggle */}\r\n          <div className={styles.toggleRow}>\r\n            <span className={styles.toggleLabel}> Race Mode</span>\r\n            <button\r\n              type=\"button\"\r\n              className={`${styles.toggle} ${\r\n                isRaceMode ? styles.toggleActive : \"\"\r\n              }`}\r\n              onClick={handleRaceModeToggle}\r\n              disabled={isVisualizing}\r\n              aria-pressed={isRaceMode ? \"true\" : \"false\"}\r\n              title=\"Toggle race mode to compare two algorithms\"\r\n            >\r\n              <span className={styles.toggleKnob} />\r\n            </button>\r\n          </div>\r\n\r\n          {/* Second Algorithm (Race Mode) */}\r\n          {isRaceMode && (\r\n            <div className={styles.controlGroup}>\r\n              <label className={styles.labelSecondary}>Agent 2 Algorithm</label>\r\n              <select\r\n                value={secondAlgorithm || \"\"}\r\n                onChange={handleSecondAlgorithmChange}\r\n                disabled={isVisualizing}\r\n                className={`${styles.select} ${styles.selectSecondary}`}\r\n                title=\"Select second algorithm for race mode\"\r\n              >\r\n                {ALGORITHM_OPTIONS.map((option) => {\r\n                  const isSameAsAgent1 = option.value === selectedAlgorithm;\r\n                  const isDisabledByHiddenMode =\r\n                    isHiddenTargetMode && option.usesHeuristic;\r\n                  const isDisabled = isSameAsAgent1 || isDisabledByHiddenMode;\r\n\r\n                  return (\r\n                    <option\r\n                      key={option.value}\r\n                      value={option.value}\r\n                      disabled={isDisabled}\r\n                    >\r\n                      {option.label}\r\n                      {isSameAsAgent1 ? \" (Agent 1)\" : \"\"}\r\n                      {isDisabledByHiddenMode\r\n                        ? \" (Requires Visible Target)\"\r\n                        : \"\"}\r\n                    </option>\r\n                  );\r\n                })}\r\n              </select>\r\n            </div>\r\n          )}\r\n\r\n          {/* Primary CTA - Visualize Button */}\r\n          <button\r\n            onClick={handleVisualize}\r\n            disabled={isVisualizing || (isRaceMode && !secondAlgorithm)}\r\n            className={`${styles.buttonPrimary} ${\r\n              isRaceMode ? styles.buttonRace : \"\"\r\n            }`}\r\n          >\r\n            {isVisualizing ? (\r\n              <>\r\n                <span className={styles.spinner} />\r\n                Visualizing...\r\n              </>\r\n            ) : isRaceMode ? (\r\n              \" Start Race!\"\r\n            ) : (\r\n              \" Visualize!\"\r\n            )}\r\n          </button>\r\n        </Accordion>\r\n\r\n        {/* === Section 2: Maze Generation === */}\r\n        <Accordion title=\"Maze Generation\" icon=\"\">\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>Maze Type</label>\r\n            <select\r\n              value={selectedMaze || \"none\"}\r\n              onChange={handleMazeChange}\r\n              disabled={isVisualizing}\r\n              className={styles.select}\r\n              title=\"Select maze generation algorithm\"\r\n            >\r\n              {MAZE_OPTIONS.map((option) => (\r\n                <option key={option.value} value={option.value}>\r\n                  {option.label}\r\n                </option>\r\n              ))}\r\n            </select>\r\n          </div>\r\n\r\n          <button\r\n            onClick={handleGenerateMaze}\r\n            disabled={isVisualizing || !selectedMaze}\r\n            className={styles.buttonSecondary}\r\n          >\r\n             Generate Maze\r\n          </button>\r\n\r\n          <button\r\n            onClick={clearAllWalls}\r\n            disabled={isVisualizing}\r\n            className={styles.buttonGhost}\r\n          >\r\n             Clear All Walls\r\n          </button>\r\n        </Accordion>\r\n\r\n        {/* === Section 3: Grid Settings === */}\r\n        <Accordion title=\"Grid Settings\" icon=\"\">\r\n          {/* Speed Control */}\r\n          <div className={styles.controlGroup}>\r\n            <div className={styles.sliderHeader}>\r\n              <label className={styles.label}>Animation Speed</label>\r\n              <span className={styles.sliderValue}>{getSpeedLabel()}</span>\r\n            </div>\r\n            <input\r\n              type=\"range\"\r\n              min=\"1\"\r\n              max=\"50\"\r\n              value={animationSpeed}\r\n              onChange={handleSpeedChange}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Adjust animation speed\"\r\n            />\r\n            <div className={styles.sliderLabels}>\r\n              <span>Fast</span>\r\n              <span>Slow</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Row Count */}\r\n          <div className={styles.controlGroup}>\r\n            <div className={styles.sliderHeader}>\r\n              <label className={styles.label}>Rows</label>\r\n              <span className={styles.sliderValue}>{rowCount}</span>\r\n            </div>\r\n            <input\r\n              type=\"range\"\r\n              min=\"5\"\r\n              max=\"40\"\r\n              value={rowCount}\r\n              onChange={handleRowChange}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Adjust number of rows\"\r\n            />\r\n          </div>\r\n\r\n          {/* Column Count */}\r\n          <div className={styles.controlGroup}>\r\n            <div className={styles.sliderHeader}>\r\n              <label className={styles.label}>Columns</label>\r\n              <span className={styles.sliderValue}>{colCount}</span>\r\n            </div>\r\n            <input\r\n              type=\"range\"\r\n              min=\"5\"\r\n              max=\"60\"\r\n              value={colCount}\r\n              onChange={handleColChange}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Adjust number of columns\"\r\n            />\r\n          </div>\r\n\r\n          {/* Board Actions */}\r\n          <div className={styles.buttonRow}>\r\n            <button\r\n              onClick={onClearPath}\r\n              disabled={isVisualizing}\r\n              className={styles.buttonGhost}\r\n            >\r\n              Clear Path\r\n            </button>\r\n            <button\r\n              onClick={resetBoard}\r\n              disabled={isVisualizing}\r\n              className={styles.buttonGhost}\r\n            >\r\n              Reset Board\r\n            </button>\r\n          </div>\r\n        </Accordion>\r\n      </div>\r\n\r\n      {/* Footer Instructions */}\r\n      <footer className={styles.footer}>\r\n        <div className={styles.instructionTitle}>Quick Tips</div>\r\n        <ul className={styles.instructionList}>\r\n          <li>\r\n            <kbd>Click</kbd> + drag to draw walls\r\n          </li>\r\n          <li>\r\n            <kbd>Ctrl</kbd> + click to erase\r\n          </li>\r\n          <li>\r\n            Drag <span className={styles.nodeHint}></span> or{\" \"}\r\n            <span className={styles.nodeHint}></span> to move\r\n          </li>\r\n        </ul>\r\n      </footer>\r\n    </aside>\r\n  );\r\n};\r\n\r\nexport default ControlPanel;\r\n","/**\r\n * Legend Component\r\n * Displays color legend for grid node types\r\n *\r\n * Shows all possible node states with their corresponding colors\r\n */\r\n\r\nimport React from \"react\";\r\nimport styles from \"./Legend.module.css\";\r\n\r\ninterface LegendItem {\r\n  label: string;\r\n  color?: string;\r\n  gradient?: string;\r\n  border?: string;\r\n}\r\n\r\nconst legendItems: LegendItem[] = [\r\n  { label: \"Start\", color: \"#4caf50\", border: \"2px solid #2e7d32\" },\r\n  { label: \"Target\", color: \"#f44336\", border: \"2px solid #c62828\" },\r\n  { label: \"Wall\", color: \"#34495e\", border: \"2px solid #2c3e50\" },\r\n  {\r\n    label: \"Visited (A1)\",\r\n    gradient: \"linear-gradient(135deg, #00bcd4 0%, #9c27b0 100%)\",\r\n  },\r\n  {\r\n    label: \"Visited (A2)\",\r\n    gradient: \"linear-gradient(135deg, #ff9800 0%, #f44336 100%)\",\r\n  },\r\n  { label: \"Path (A1)\", color: \"#ffeb3b\", border: \"2px solid #f9a825\" },\r\n  { label: \"Path (A2)\", color: \"#00e5ff\", border: \"2px solid #00acc1\" },\r\n  { label: \"Overlap\", color: \"#76ff03\", border: \"2px solid #64dd17\" },\r\n];\r\n\r\ninterface LegendProps {\r\n  orientation?: \"horizontal\" | \"vertical\";\r\n  compact?: boolean;\r\n}\r\n\r\nconst Legend: React.FC<LegendProps> = ({\r\n  orientation = \"horizontal\",\r\n  compact = false,\r\n}) => {\r\n  return (\r\n    <div\r\n      className={`${styles.legend} ${styles[orientation]} ${\r\n        compact ? styles.compact : \"\"\r\n      }`}\r\n      role=\"region\"\r\n      aria-label=\"Color Legend\"\r\n    >\r\n      <span className={styles.title}>Legend:</span>\r\n      <div className={styles.items}>\r\n        {legendItems.map((item) => (\r\n          <div key={item.label} className={styles.item}>\r\n            {/* eslint-disable-next-line react/forbid-dom-props */}\r\n            <div\r\n              className={styles.colorBox}\r\n              style={{\r\n                background: item.gradient || item.color,\r\n                border: item.border || \"none\",\r\n              }}\r\n              aria-hidden=\"true\"\r\n            />\r\n            <span className={styles.label}>{item.label}</span>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Legend;\r\n","import { useEffect, useState } from \"react\";\r\nimport { useGrid } from \"../../context/GridContext\";\r\nimport styles from \"./Toast.module.css\";\r\n\r\n/**\r\n * Toast Notification Component\r\n * Displays slide-up notifications at bottom-center of screen\r\n * Auto-dismisses after 3 seconds with exit animation\r\n */\r\nconst Toast = () => {\r\n  const { toastMsg, clearToast } = useGrid();\r\n  const [isExiting, setIsExiting] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!toastMsg) {\r\n      setIsExiting(false);\r\n      return;\r\n    }\r\n\r\n    // Start exit animation after 2.7s, then clear after 3s total\r\n    const exitTimer = setTimeout(() => {\r\n      setIsExiting(true);\r\n    }, 2700);\r\n\r\n    const clearTimer = setTimeout(() => {\r\n      clearToast();\r\n      setIsExiting(false);\r\n    }, 3000);\r\n\r\n    return () => {\r\n      clearTimeout(exitTimer);\r\n      clearTimeout(clearTimer);\r\n    };\r\n  }, [toastMsg, clearToast]);\r\n\r\n  if (!toastMsg) return null;\r\n\r\n  // Determine toast type based on message content\r\n  const getToastType = (): \"error\" | \"warning\" | \"success\" | undefined => {\r\n    if (\r\n      toastMsg.toLowerCase().includes(\"unreachable\") ||\r\n      toastMsg.toLowerCase().includes(\"no path\")\r\n    ) {\r\n      return \"error\";\r\n    }\r\n    if (toastMsg.toLowerCase().includes(\"warning\")) {\r\n      return \"warning\";\r\n    }\r\n    if (\r\n      toastMsg.toLowerCase().includes(\"success\") ||\r\n      toastMsg.toLowerCase().includes(\"complete\")\r\n    ) {\r\n      return \"success\";\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  const toastType = getToastType();\r\n\r\n  // Icon based on type\r\n  const getIcon = () => {\r\n    switch (toastType) {\r\n      case \"error\":\r\n        return \"\";\r\n      case \"warning\":\r\n        return \"\";\r\n      case \"success\":\r\n        return \"\";\r\n      default:\r\n        return \"\";\r\n    }\r\n  };\r\n\r\n  const toastClasses = [\r\n    styles.toast,\r\n    toastType ? styles[toastType] : \"\",\r\n    isExiting ? styles.exiting : \"\",\r\n  ]\r\n    .filter(Boolean)\r\n    .join(\" \");\r\n\r\n  return (\r\n    <div className={styles.toastContainer}>\r\n      <div className={toastClasses} role=\"alert\" aria-live=\"polite\">\r\n        <span className={styles.icon}>{getIcon()}</span>\r\n        <span className={styles.message}>{toastMsg}</span>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Toast;\r\n","/**\r\n * useBenchmarking Hook\r\n * Bridge between Main Thread and Benchmark Web Worker\r\n *\r\n * Provides a clean API for running isolated, high-precision benchmarks\r\n * without blocking the UI thread.\r\n *\r\n * Features:\r\n * - Automatic worker lifecycle management\r\n * - Promise-based API for async/await usage\r\n * - Cleanup on unmount (prevents memory leaks)\r\n * - Error handling with fallback\r\n */\r\n\r\nimport { useRef, useCallback, useEffect } from \"react\";\r\nimport { Grid, AlgorithmType } from \"../types\";\r\n\r\n// === TYPE DEFINITIONS ===\r\n\r\nexport interface BenchmarkResult {\r\n  avgTime: number; // Average time per execution in ms\r\n  iterations: number; // Number of iterations completed\r\n  opsPerSec: number; // Operations per second\r\n  totalTime: number; // Total benchmark duration\r\n}\r\n\r\ninterface WorkerResponse {\r\n  success: boolean;\r\n  data?: BenchmarkResult;\r\n  error?: string;\r\n  requestId: number; // Unique ID to match request with response\r\n}\r\n\r\n// Serialized format for transfer to worker\r\ntype SerializedNode = {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n};\r\n\r\ntype SerializedGrid = SerializedNode[][];\r\n\r\n// === HOOK CONFIGURATION ===\r\n\r\nconst DEFAULT_MIN_DURATION = 200; // Run benchmark for at least 200ms\r\n\r\n// === MAIN HOOK ===\r\n\r\n// Counter for unique request IDs (outside hook to persist across re-renders)\r\nlet requestIdCounter = 0;\r\n\r\nexport function useBenchmarking() {\r\n  // Worker instance ref (persists across renders)\r\n  const workerRef = useRef<Worker | null>(null);\r\n  // Map of pending promise resolvers keyed by request ID\r\n  // This allows multiple concurrent benchmark requests (e.g., race mode)\r\n  const pendingRequests = useRef<\r\n    Map<\r\n      number,\r\n      {\r\n        resolve: (value: BenchmarkResult) => void;\r\n        reject: (error: Error) => void;\r\n      }\r\n    >\r\n  >(new Map());\r\n\r\n  /**\r\n   * Initialize the worker on first use\r\n   */\r\n  const getWorker = useCallback((): Worker => {\r\n    if (!workerRef.current) {\r\n      // Vite-specific syntax for module workers\r\n      workerRef.current = new Worker(\r\n        new URL(\"../workers/benchmark.worker.ts\", import.meta.url),\r\n        { type: \"module\" }\r\n      );\r\n\r\n      // Set up message handler\r\n      workerRef.current.onmessage = (event: MessageEvent<WorkerResponse>) => {\r\n        const { requestId, success, data, error } = event.data;\r\n        const pending = pendingRequests.current.get(requestId);\r\n\r\n        if (pending) {\r\n          if (success && data) {\r\n            pending.resolve(data);\r\n          } else {\r\n            pending.reject(new Error(error || \"Benchmark failed\"));\r\n          }\r\n          pendingRequests.current.delete(requestId);\r\n        }\r\n      };\r\n\r\n      // Handle worker errors (reject all pending requests)\r\n      workerRef.current.onerror = (error) => {\r\n        console.error(\"Benchmark worker error:\", error);\r\n        const errorObj = new Error(\"Worker error: \" + error.message);\r\n        pendingRequests.current.forEach((pending) => {\r\n          pending.reject(errorObj);\r\n        });\r\n        pendingRequests.current.clear();\r\n      };\r\n    }\r\n\r\n    return workerRef.current;\r\n  }, []);\r\n\r\n  /**\r\n   * Serialize grid for transfer to worker\r\n   * Removes circular references (previousNode) and resets state\r\n   */\r\n  const serializeGrid = useCallback((grid: Grid): SerializedGrid => {\r\n    return grid.map((row) =>\r\n      row.map((node) => ({\r\n        row: node.row,\r\n        col: node.col,\r\n        isStart: node.isStart,\r\n        isFinish: node.isFinish,\r\n        isWall: node.isWall,\r\n      }))\r\n    );\r\n  }, []);\r\n\r\n  /**\r\n   * Find start and finish positions in grid\r\n   */\r\n  const findPositions = useCallback(\r\n    (\r\n      grid: Grid\r\n    ): {\r\n      startPos: { row: number; col: number };\r\n      finishPos: { row: number; col: number };\r\n    } | null => {\r\n      let startPos: { row: number; col: number } | null = null;\r\n      let finishPos: { row: number; col: number } | null = null;\r\n\r\n      for (const row of grid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startPos = { row: node.row, col: node.col };\r\n          if (node.isFinish) finishPos = { row: node.row, col: node.col };\r\n        }\r\n      }\r\n\r\n      if (!startPos || !finishPos) return null;\r\n      return { startPos, finishPos };\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Run a benchmark for the specified algorithm\r\n   *\r\n   * @param algorithm - The algorithm to benchmark\r\n   * @param grid - The current grid state\r\n   * @param minDuration - Minimum benchmark duration (default: 200ms)\r\n   * @returns Promise resolving to benchmark results\r\n   */\r\n  const runBenchmark = useCallback(\r\n    async (\r\n      algorithm: AlgorithmType,\r\n      grid: Grid,\r\n      minDuration: number = DEFAULT_MIN_DURATION\r\n    ): Promise<BenchmarkResult> => {\r\n      const worker = getWorker();\r\n      const positions = findPositions(grid);\r\n\r\n      if (!positions) {\r\n        throw new Error(\"Start or Finish node not found\");\r\n      }\r\n\r\n      // Serialize grid for transfer (removes circular refs)\r\n      const serializedGrid = serializeGrid(grid);\r\n\r\n      // Generate unique request ID for this benchmark\r\n      const requestId = ++requestIdCounter;\r\n\r\n      return new Promise((resolve, reject) => {\r\n        // Store resolvers keyed by request ID\r\n        pendingRequests.current.set(requestId, { resolve, reject });\r\n\r\n        // Send benchmark request to worker with request ID\r\n        worker.postMessage({\r\n          requestId,\r\n          algorithmName: algorithm,\r\n          gridData: serializedGrid,\r\n          startPos: positions.startPos,\r\n          finishPos: positions.finishPos,\r\n          minDuration,\r\n        });\r\n      });\r\n    },\r\n    [getWorker, findPositions, serializeGrid]\r\n  );\r\n\r\n  /**\r\n   * Terminate the worker (for cleanup)\r\n   */\r\n  const terminateWorker = useCallback(() => {\r\n    if (workerRef.current) {\r\n      workerRef.current.terminate();\r\n      workerRef.current = null;\r\n    }\r\n    // Reject all pending requests\r\n    pendingRequests.current.forEach((pending) => {\r\n      pending.reject(new Error(\"Worker terminated\"));\r\n    });\r\n    pendingRequests.current.clear();\r\n  }, []);\r\n\r\n  /**\r\n   * Cleanup on unmount\r\n   */\r\n  useEffect(() => {\r\n    return () => {\r\n      terminateWorker();\r\n    };\r\n  }, [terminateWorker]);\r\n\r\n  return {\r\n    runBenchmark,\r\n    terminateWorker,\r\n  };\r\n}\r\n\r\nexport default useBenchmarking;\r\n","/**\r\n * useVisualization Hook\r\n * Phase B & C: Animation System for Pathfinding and Maze Generation\r\n *\r\n * ARCHITECTURE: Industrial-Grade Benchmarking with Web Worker Isolation\r\n * - Timing runs in dedicated Web Worker (zero UI interference)\r\n * - Main thread only handles animation (DOM manipulation)\r\n * - Scientific precision: adaptive sampling until 200ms elapsed\r\n *\r\n * Uses direct DOM manipulation for performance (1000+ nodes).\r\n * Does NOT use React setState inside animation loops.\r\n */\r\n\r\nimport { useCallback, useRef } from \"react\";\r\nimport { Grid, Node, MazeType, AlgorithmType } from \"../types\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/pathfinding/dijkstra\";\r\nimport {\r\n  astar,\r\n  getNodesInShortestPathOrder as getAstarPath,\r\n} from \"../algorithms/pathfinding/astar\";\r\nimport {\r\n  bfs,\r\n  getNodesInShortestPathOrder as getBfsPath,\r\n} from \"../algorithms/pathfinding/bfs\";\r\nimport {\r\n  dfs,\r\n  getNodesInShortestPathOrder as getDfsPath,\r\n} from \"../algorithms/pathfinding/dfs\";\r\nimport {\r\n  greedyBestFirst,\r\n  getNodesInShortestPathOrder as getGreedyPath,\r\n} from \"../algorithms/pathfinding/greedyBestFirst\";\r\nimport {\r\n  bidirectionalBFS,\r\n  getNodesInShortestPathOrder as getBidirectionalPath,\r\n} from \"../algorithms/pathfinding/bidirectionalBFS\";\r\nimport {\r\n  bidirectionalAStar,\r\n  getNodesInShortestPathOrder as getBidirectionalAStarPath,\r\n} from \"../algorithms/pathfinding/bidirectionalAStar\";\r\nimport {\r\n  jumpPointSearch,\r\n  getNodesInShortestPathOrder as getJPSPath,\r\n} from \"../algorithms/pathfinding/jumpPointSearch\";\r\nimport { getRecursiveDivisionMaze } from \"../algorithms/maze/recursiveDivision\";\r\nimport { getRandomizedDFSMaze } from \"../algorithms/maze/randomizedDFS\";\r\nimport { getPrimsMaze } from \"../algorithms/maze/prims\";\r\nimport { getSpiralMaze } from \"../algorithms/maze/spiralMaze\";\r\nimport { getCellularAutomataMaze } from \"../algorithms/maze/cellularAutomata\";\r\nimport { resetGridForPathfinding, clearWalls } from \"../utils/gridUtils\";\r\nimport { AlgorithmStats, RaceStats } from \"../components/Modals/StatsModal\";\r\nimport { useBenchmarking } from \"./useBenchmarking\";\r\nimport { RunRecord } from \"../types\";\r\n\r\n/**\r\n * Callbacks for stats and scroll behavior\r\n */\r\ninterface StatsCallbacks {\r\n  setVisualizationStats: React.Dispatch<\r\n    React.SetStateAction<AlgorithmStats | RaceStats | null>\r\n  >;\r\n  scrollToStats: () => void;\r\n  showToast?: (msg: string) => void;\r\n  addRunRecord?: (record: Omit<RunRecord, \"id\" | \"timestamp\" | \"date\">) => void;\r\n  gridSize?: string; // e.g., \"20x30\"\r\n}\r\n\r\n/**\r\n * Return type for the useVisualization hook\r\n */\r\ninterface UseVisualizationReturn {\r\n  visualizePathfinding: (\r\n    algorithm: AlgorithmType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number,\r\n    statsCallbacks?: StatsCallbacks\r\n  ) => void;\r\n  visualizeRace: (\r\n    algo1: AlgorithmType,\r\n    algo2: AlgorithmType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number,\r\n    statsCallbacks?: StatsCallbacks\r\n  ) => void;\r\n  generateMaze: (\r\n    mazeType: MazeType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number\r\n  ) => void;\r\n  clearVisualization: (\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>\r\n  ) => void;\r\n  isAnimating: React.MutableRefObject<boolean>;\r\n}\r\n\r\n/**\r\n * Custom hook for managing pathfinding visualization animations\r\n *\r\n * Key Design Decisions:\r\n * - Direct DOM manipulation via getElementById (bypasses React for performance)\r\n * - setTimeout-based animation queue (non-blocking UI)\r\n * - CSS class toggling for visual effects\r\n * - Ref-based animation state to prevent stale closures\r\n */\r\nexport const useVisualization = (): UseVisualizationReturn => {\r\n  // Track animation state with ref (not state - to avoid stale closures)\r\n  const isAnimating = useRef<boolean>(false);\r\n  // Store timeout IDs for cleanup\r\n  const timeoutIds = useRef<ReturnType<typeof setTimeout>[]>([]);\r\n\r\n  // === WEB WORKER BENCHMARKING ===\r\n  // Industrial-grade timing isolated from UI thread\r\n  const { runBenchmark } = useBenchmarking();\r\n\r\n  // Benchmark duration: run algorithm repeatedly for 1 second to get stable average\r\n  const BENCHMARK_MIN_DURATION = 1000;\r\n\r\n  /**\r\n   * Clears all pending animation timeouts\r\n   */\r\n  const clearAllTimeouts = useCallback((): void => {\r\n    timeoutIds.current.forEach((id) => clearTimeout(id));\r\n    timeoutIds.current = [];\r\n  }, []);\r\n\r\n  /**\r\n   * Removes visualization CSS classes from all nodes via DOM\r\n   * SIMPLIFIED: Only handles basic visited/path classes\r\n   */\r\n  const clearVisualizationClasses = useCallback((): void => {\r\n    // Remove visited and path classes from all nodes (both agents)\r\n    const visitedNodes = document.querySelectorAll(\".node-visited\");\r\n    const pathNodes = document.querySelectorAll(\".node-path\");\r\n    const visitedNodesSecond = document.querySelectorAll(\r\n      \".node-visited-second\"\r\n    );\r\n    const pathNodesSecond = document.querySelectorAll(\".node-path-second\");\r\n    const overlapNodes = document.querySelectorAll(\".node-visited-overlap\");\r\n    // Simple path overlap class (for mixed color)\r\n    const pathOverlapNodes = document.querySelectorAll(\".node-path-overlap\");\r\n\r\n    visitedNodes.forEach((node) => {\r\n      node.classList.remove(\"node-visited\");\r\n    });\r\n\r\n    pathNodes.forEach((node) => {\r\n      node.classList.remove(\"node-path\");\r\n    });\r\n\r\n    visitedNodesSecond.forEach((node) => {\r\n      node.classList.remove(\"node-visited-second\");\r\n    });\r\n\r\n    pathNodesSecond.forEach((node) => {\r\n      node.classList.remove(\"node-path-second\");\r\n    });\r\n\r\n    overlapNodes.forEach((node) => {\r\n      node.classList.remove(\"node-visited-overlap\");\r\n    });\r\n\r\n    // Clear simple path overlap class\r\n    pathOverlapNodes.forEach((node) => {\r\n      node.classList.remove(\"node-path-overlap\");\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Clears the visualization (both DOM and React state)\r\n   */\r\n  const clearVisualization = useCallback(\r\n    (grid: Grid, setGrid: React.Dispatch<React.SetStateAction<Grid>>): void => {\r\n      // Stop any ongoing animation\r\n      clearAllTimeouts();\r\n      isAnimating.current = false;\r\n\r\n      // Clear DOM classes\r\n      clearVisualizationClasses();\r\n\r\n      // Reset React state (distance, previousNode, isVisited)\r\n      setGrid(resetGridForPathfinding(grid));\r\n    },\r\n    [clearAllTimeouts, clearVisualizationClasses]\r\n  );\r\n\r\n  /**\r\n   * Animates the visited nodes one by one\r\n   * Uses setTimeout with increasing delays based on index\r\n   */\r\n  const animateVisitedNodes = useCallback(\r\n    (\r\n      visitedNodesInOrder: Node[],\r\n      speed: number,\r\n      onComplete: () => void\r\n    ): void => {\r\n      for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n\r\n          // Skip Start and Finish nodes (preserve their colors)\r\n          if (node.isStart || node.isFinish) {\r\n            // If this is the last node, trigger path animation\r\n            if (i === visitedNodesInOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation for performance\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            element.classList.add(\"node-visited\");\r\n          }\r\n\r\n          // If this is the last node, trigger path animation\r\n          if (i === visitedNodesInOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Animates the shortest path nodes\r\n   * Called after visited animation completes\r\n   */\r\n  const animateShortestPath = useCallback(\r\n    (\r\n      nodesInShortestPathOrder: Node[],\r\n      speed: number,\r\n      onComplete: () => void\r\n    ): void => {\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n\r\n          // Skip Start and Finish nodes (preserve their colors)\r\n          if (node.isStart || node.isFinish) {\r\n            if (i === nodesInShortestPathOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            // Remove visited class first, then add path class\r\n            element.classList.remove(\"node-visited\");\r\n            element.classList.add(\"node-path\");\r\n          }\r\n\r\n          // If this is the last node, mark animation as complete\r\n          if (i === nodesInShortestPathOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * (speed * 3)); // Path animation is slower (3x)\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Helper function to run an algorithm and get results\r\n   * Extracted for reuse in benchmarking and race mode\r\n   */\r\n  const runAlgorithm = useCallback(\r\n    (\r\n      algorithm: AlgorithmType,\r\n      algorithmGrid: Grid,\r\n      startNode: Node,\r\n      finishNode: Node\r\n    ): { visitedNodes: Node[]; pathNodes: Node[] } => {\r\n      let visitedNodes: Node[] = [];\r\n      let pathNodes: Node[] = [];\r\n\r\n      switch (algorithm) {\r\n        case AlgorithmType.ASTAR:\r\n          visitedNodes = astar(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getAstarPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BFS:\r\n          visitedNodes = bfs(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getBfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DFS:\r\n          visitedNodes = dfs(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getDfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.GREEDY_BEST_FIRST:\r\n          visitedNodes = greedyBestFirst(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getGreedyPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BIDIRECTIONAL_BFS:\r\n          visitedNodes = bidirectionalBFS(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getBidirectionalPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BIDIRECTIONAL_ASTAR:\r\n          visitedNodes = bidirectionalAStar(\r\n            algorithmGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          pathNodes = getBidirectionalAStarPath(finishNode);\r\n          break;\r\n        case AlgorithmType.JUMP_POINT_SEARCH:\r\n          visitedNodes = jumpPointSearch(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getJPSPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DIJKSTRA:\r\n        default:\r\n          visitedNodes = dijkstra(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getNodesInShortestPathOrder(finishNode);\r\n          break;\r\n      }\r\n\r\n      return { visitedNodes, pathNodes };\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Main visualization function for pathfinding algorithms\r\n   *\r\n   * ARCHITECTURE: Web Worker Isolation for Scientific Timing\r\n   * - Phase 1: ASYNC BENCHMARK - Run in Web Worker (isolated from UI thread)\r\n   * - Phase 2: LOCAL EXECUTION - Run once on main thread for animation data\r\n   * - Phase 3: ANIMATION - DOM manipulation for visual feedback\r\n   * - Phase 4: CLEANUP - Reset animation state\r\n   *\r\n   * The timing number comes from the Worker (rock-solid stable).\r\n   * The animation data comes from a single main-thread run (visual only).\r\n   */\r\n  const visualizePathfinding = useCallback(\r\n    async (\r\n      algorithm: AlgorithmType,\r\n      grid: Grid,\r\n      _setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number,\r\n      statsCallbacks?: StatsCallbacks\r\n    ): Promise<void> => {\r\n      // Prevent multiple visualizations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous visualization (DOM classes)\r\n      clearAllTimeouts();\r\n      clearVisualizationClasses();\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // === PHASE 1: WEB WORKER BENCHMARK (Isolated Thread) ===\r\n      // This runs in a separate thread - no UI interference\r\n      let benchmarkResult: { avgTime: number } | null = null;\r\n      try {\r\n        benchmarkResult = await runBenchmark(\r\n          algorithm,\r\n          grid,\r\n          BENCHMARK_MIN_DURATION\r\n        );\r\n      } catch (error) {\r\n        console.warn(\"Worker benchmark failed, using fallback:\", error);\r\n        // Fallback: single measurement on main thread\r\n        benchmarkResult = null;\r\n      }\r\n\r\n      // === PHASE 2: LOCAL EXECUTION (For Animation Data) ===\r\n      // Run algorithm once on main thread to get visitedNodes for animation\r\n      // This execution time is NOT reported - only used for visual data\r\n      const algorithmGrid: Grid = grid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          isVisited: false,\r\n          distance: Infinity,\r\n          previousNode: null,\r\n        }))\r\n      );\r\n\r\n      let startNode: Node | null = null;\r\n      let finishNode: Node | null = null;\r\n      for (const row of algorithmGrid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode = node;\r\n          if (node.isFinish) finishNode = node;\r\n        }\r\n      }\r\n\r\n      if (!startNode || !finishNode) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n        return;\r\n      }\r\n\r\n      // Fallback timing if worker failed\r\n      const fallbackStart = performance.now();\r\n      const { visitedNodes, pathNodes } = runAlgorithm(\r\n        algorithm,\r\n        algorithmGrid,\r\n        startNode,\r\n        finishNode\r\n      );\r\n      const fallbackTime = performance.now() - fallbackStart;\r\n\r\n      // Use worker time if available, otherwise fallback\r\n      const executionTime = benchmarkResult?.avgTime ?? fallbackTime;\r\n\r\n      const visitedNodesInOrder = visitedNodes;\r\n      const nodesInShortestPathOrder = pathNodes;\r\n\r\n      // Check if path was found\r\n      const pathFound = nodesInShortestPathOrder.length > 1;\r\n\r\n      // Capture stats\r\n      const stats: AlgorithmStats = {\r\n        algorithm,\r\n        executionTime,\r\n        visitedCount: visitedNodesInOrder.length,\r\n        pathLength: pathFound ? nodesInShortestPathOrder.length : -1,\r\n      };\r\n\r\n      // === PHASE 3: ANIMATION (DOM Manipulation) ===\r\n      animateVisitedNodes(visitedNodesInOrder, speed, () => {\r\n        if (!pathFound) {\r\n          isAnimating.current = false;\r\n          setIsVisualizing(false);\r\n\r\n          if (statsCallbacks) {\r\n            statsCallbacks.setVisualizationStats(stats);\r\n            // Add to run history\r\n            if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n              statsCallbacks.addRunRecord({\r\n                mode: \"Single\",\r\n                algorithm1: stats.algorithm,\r\n                gridSize: statsCallbacks.gridSize,\r\n                time1: stats.executionTime,\r\n                pathLength1: stats.pathLength,\r\n                visitedCount1: stats.visitedCount,\r\n              });\r\n            }\r\n            if (statsCallbacks.showToast) {\r\n              statsCallbacks.showToast(\r\n                \"Target is unreachable! No path exists.\"\r\n              );\r\n            }\r\n            setTimeout(() => {\r\n              statsCallbacks.scrollToStats();\r\n            }, 500);\r\n          }\r\n          return;\r\n        }\r\n\r\n        const pathDelay = setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder, speed, () => {\r\n            // === PHASE 4: CLEANUP ===\r\n            isAnimating.current = false;\r\n            setIsVisualizing(false);\r\n\r\n            if (statsCallbacks) {\r\n              statsCallbacks.setVisualizationStats(stats);\r\n              // Add to run history\r\n              if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n                statsCallbacks.addRunRecord({\r\n                  mode: \"Single\",\r\n                  algorithm1: stats.algorithm,\r\n                  gridSize: statsCallbacks.gridSize,\r\n                  time1: stats.executionTime,\r\n                  pathLength1: stats.pathLength,\r\n                  visitedCount1: stats.visitedCount,\r\n                });\r\n              }\r\n              setTimeout(() => {\r\n                statsCallbacks.scrollToStats();\r\n              }, 500);\r\n            }\r\n          });\r\n        }, 50);\r\n        timeoutIds.current.push(pathDelay);\r\n      });\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      animateVisitedNodes,\r\n      animateShortestPath,\r\n      runAlgorithm,\r\n      runBenchmark,\r\n      BENCHMARK_MIN_DURATION,\r\n    ]\r\n  );\r\n\r\n  /**\r\n   * Removes wall CSS classes from all nodes via DOM\r\n   */\r\n  const clearWallClasses = useCallback((): void => {\r\n    const wallNodes = document.querySelectorAll(\".node-wall\");\r\n    wallNodes.forEach((node) => {\r\n      node.classList.remove(\"node-wall\");\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Animates maze wall generation\r\n   * Uses setTimeout to sequentially add walls for visual effect\r\n   * Protects Start/Finish nodes from being turned into walls\r\n   */\r\n  const animateMazeWalls = useCallback(\r\n    (wallsInOrder: Node[], speed: number, onComplete: () => void): void => {\r\n      for (let i = 0; i < wallsInOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = wallsInOrder[i];\r\n\r\n          // PROTECTION: Skip Start and Finish nodes (never turn them into walls)\r\n          if (node.isStart || node.isFinish) {\r\n            // If this is the last wall, trigger completion\r\n            if (i === wallsInOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation for wall animation\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            element.classList.add(\"node-wall\");\r\n          }\r\n\r\n          // If this is the last wall, trigger completion\r\n          if (i === wallsInOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n\r\n      // Handle empty walls array\r\n      if (wallsInOrder.length === 0) {\r\n        onComplete();\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Main maze generation function\r\n   *\r\n   * Steps:\r\n   * A. Clear any existing visualization and walls\r\n   * B. Get maze walls from algorithm\r\n   * C. Animate wall building\r\n   * D. Sync React state with final walls\r\n   */\r\n  const generateMaze = useCallback(\r\n    (\r\n      mazeType: MazeType,\r\n      grid: Grid,\r\n      setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number\r\n    ): void => {\r\n      // Prevent multiple generations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous animations and timeouts\r\n      clearAllTimeouts();\r\n\r\n      // === DOM SAFETY NET ===\r\n      // Explicitly clear ALL visualization classes from DOM before starting\r\n      // This ensures a clean slate even if React state and DOM are out of sync\r\n      clearVisualizationClasses(); // Removes .node-visited and .node-path\r\n      clearWallClasses(); // Removes .node-wall\r\n\r\n      // Step A: Clear walls AND pathfinding state from React state\r\n      // First reset pathfinding (isVisited, distance, previousNode)\r\n      const resetGrid = resetGridForPathfinding(grid);\r\n      // Then clear walls\r\n      const clearedGrid = clearWalls(resetGrid);\r\n      setGrid(clearedGrid);\r\n\r\n      // Find Start and Finish nodes\r\n      let startNode: Node | null = null;\r\n      let finishNode: Node | null = null;\r\n\r\n      for (const row of clearedGrid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode = node;\r\n          if (node.isFinish) finishNode = node;\r\n        }\r\n      }\r\n\r\n      // Safety check\r\n      if (!startNode || !finishNode) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        return;\r\n      }\r\n\r\n      // Step B: Get maze walls based on algorithm type\r\n      let wallsInOrder: Node[] = [];\r\n      let animationSpeed = speed;\r\n\r\n      switch (mazeType) {\r\n        case MazeType.RECURSIVE_DIVISION:\r\n          wallsInOrder = getRecursiveDivisionMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          break;\r\n        case MazeType.RANDOMIZED_DFS:\r\n          wallsInOrder = getRandomizedDFSMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          // DFS generates many walls - use faster animation (5ms min)\r\n          animationSpeed = Math.max(5, speed / 3);\r\n          break;\r\n        case MazeType.PRIMS:\r\n          wallsInOrder = getPrimsMaze(clearedGrid, startNode, finishNode);\r\n          // Prim's generates many walls - use faster animation\r\n          animationSpeed = Math.max(5, speed / 3);\r\n          break;\r\n        case MazeType.SPIRAL:\r\n          wallsInOrder = getSpiralMaze(clearedGrid, startNode, finishNode);\r\n          break;\r\n        case MazeType.CELLULAR_AUTOMATA:\r\n          wallsInOrder = getCellularAutomataMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          // Cellular automata generates many walls - use faster animation\r\n          animationSpeed = Math.max(5, speed / 3);\r\n          break;\r\n        default:\r\n          console.error(\"Unknown maze type:\", mazeType);\r\n          return;\r\n      }\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // Step C: Animate wall building\r\n      // Use setTimeout to allow React to process the grid state update first\r\n      // This ensures isVisited=false is rendered before animation starts\r\n      setTimeout(() => {\r\n        animateMazeWalls(wallsInOrder, animationSpeed, () => {\r\n          // Step D: Sync React state with walls\r\n          // This is CRUCIAL - without this, Dijkstra won't see the walls\r\n          setGrid((currentGrid) => {\r\n            const newGrid = currentGrid.map((row) =>\r\n              row.map((node) => ({ ...node }))\r\n            );\r\n\r\n            // Mark all walls in the grid state\r\n            for (const wall of wallsInOrder) {\r\n              if (\r\n                !newGrid[wall.row][wall.col].isStart &&\r\n                !newGrid[wall.row][wall.col].isFinish\r\n              ) {\r\n                newGrid[wall.row][wall.col].isWall = true;\r\n              }\r\n            }\r\n\r\n            return newGrid;\r\n          });\r\n\r\n          // Animation complete\r\n          isAnimating.current = false;\r\n          setIsVisualizing(false);\r\n        });\r\n      }, 50); // Small delay to let React re-render with cleared state\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      clearWallClasses,\r\n      animateMazeWalls,\r\n    ]\r\n  );\r\n\r\n  /**\r\n   * Race Mode: Run two algorithms simultaneously and animate them together\r\n   *\r\n   * ARCHITECTURE: Web Worker Isolation for Scientific Timing (Both Algorithms)\r\n   * - Phase 1: ASYNC BENCHMARK - Run both algorithms in Web Worker (parallel)\r\n   * - Phase 2: LOCAL EXECUTION - Run once each on main thread for animation data\r\n   * - Phase 3: ANIMATION - DOM manipulation for visual feedback\r\n   * - Phase 4: CLEANUP - Reset animation state\r\n   */\r\n  const visualizeRace = useCallback(\r\n    async (\r\n      algo1: AlgorithmType,\r\n      algo2: AlgorithmType,\r\n      grid: Grid,\r\n      _setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number,\r\n      statsCallbacks?: StatsCallbacks\r\n    ): Promise<void> => {\r\n      // Prevent multiple visualizations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous visualization\r\n      clearAllTimeouts();\r\n      clearVisualizationClasses();\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // === PHASE 1: WEB WORKER BENCHMARK (Both Algorithms in Parallel) ===\r\n      let benchmark1Result: { avgTime: number } | null = null;\r\n      let benchmark2Result: { avgTime: number } | null = null;\r\n\r\n      try {\r\n        // Run both benchmarks in parallel for efficiency\r\n        const [b1, b2] = await Promise.all([\r\n          runBenchmark(algo1, grid, BENCHMARK_MIN_DURATION),\r\n          runBenchmark(algo2, grid, BENCHMARK_MIN_DURATION),\r\n        ]);\r\n        benchmark1Result = b1;\r\n        benchmark2Result = b2;\r\n      } catch (error) {\r\n        console.warn(\"Worker benchmark failed, using fallback:\", error);\r\n      }\r\n\r\n      // === PHASE 2: LOCAL EXECUTION (For Animation Data) ===\r\n      const createGridCopy = (): Grid =>\r\n        grid.map((row) =>\r\n          row.map((node) => ({\r\n            ...node,\r\n            isVisited: false,\r\n            distance: Infinity,\r\n            previousNode: null,\r\n          }))\r\n        );\r\n\r\n      const findNodes = (g: Grid): { start: Node; finish: Node } | null => {\r\n        let start: Node | null = null;\r\n        let finish: Node | null = null;\r\n        for (const row of g) {\r\n          for (const node of row) {\r\n            if (node.isStart) start = node;\r\n            if (node.isFinish) finish = node;\r\n          }\r\n        }\r\n        if (!start || !finish) return null;\r\n        return { start, finish };\r\n      };\r\n\r\n      // Run algo1 for animation data\r\n      const grid1 = createGridCopy();\r\n      const nodes1 = findNodes(grid1);\r\n      if (!nodes1) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n        return;\r\n      }\r\n\r\n      const fallback1Start = performance.now();\r\n      const result1 = runAlgorithm(algo1, grid1, nodes1.start, nodes1.finish);\r\n      const fallback1Time = performance.now() - fallback1Start;\r\n\r\n      // Run algo2 for animation data\r\n      const grid2 = createGridCopy();\r\n      const nodes2 = findNodes(grid2);\r\n      if (!nodes2) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n        return;\r\n      }\r\n\r\n      const fallback2Start = performance.now();\r\n      const result2 = runAlgorithm(algo2, grid2, nodes2.start, nodes2.finish);\r\n      const fallback2Time = performance.now() - fallback2Start;\r\n\r\n      // Use worker times if available\r\n      const executionTime1 = benchmark1Result?.avgTime ?? fallback1Time;\r\n      const executionTime2 = benchmark2Result?.avgTime ?? fallback2Time;\r\n\r\n      const visited1 = result1.visitedNodes;\r\n      const visited2 = result2.visitedNodes;\r\n      const path1 = result1.pathNodes;\r\n      const path2 = result2.pathNodes;\r\n\r\n      // Check if paths were found\r\n      const path1Found = path1.length > 1;\r\n      const path2Found = path2.length > 1;\r\n\r\n      // Capture stats\r\n      const stats1: AlgorithmStats = {\r\n        algorithm: algo1,\r\n        executionTime: executionTime1,\r\n        visitedCount: visited1.length,\r\n        pathLength: path1Found ? path1.length : -1,\r\n      };\r\n\r\n      const stats2: AlgorithmStats = {\r\n        algorithm: algo2,\r\n        executionTime: executionTime2,\r\n        visitedCount: visited2.length,\r\n        pathLength: path2Found ? path2.length : -1,\r\n      };\r\n\r\n      // Determine winner\r\n      let winner: \"agent1\" | \"agent2\" | \"tie\" = \"tie\";\r\n      if (path1Found && path2Found) {\r\n        if (path1.length < path2.length) {\r\n          winner = \"agent1\";\r\n        } else if (path2.length < path1.length) {\r\n          winner = \"agent2\";\r\n        } else if (stats1.executionTime < stats2.executionTime) {\r\n          winner = \"agent1\";\r\n        } else if (stats2.executionTime < stats1.executionTime) {\r\n          winner = \"agent2\";\r\n        }\r\n      } else if (path1Found) {\r\n        winner = \"agent1\";\r\n      } else if (path2Found) {\r\n        winner = \"agent2\";\r\n      }\r\n\r\n      const raceStats: RaceStats = {\r\n        agent1: stats1,\r\n        agent2: stats2,\r\n        winner,\r\n      };\r\n\r\n      // Track which nodes have been visited by which agent\r\n      const visitedByAgent1 = new Set<string>();\r\n      const visitedByAgent2 = new Set<string>();\r\n\r\n      // === PHASE 2: PARALLEL ANIMATION ===\r\n      const maxVisitedLen = Math.max(visited1.length, visited2.length);\r\n\r\n      for (let i = 0; i < maxVisitedLen; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          // Agent 1 animation\r\n          if (i < visited1.length) {\r\n            const node1 = visited1[i];\r\n            if (!node1.isStart && !node1.isFinish) {\r\n              const key1 = `${node1.row}-${node1.col}`;\r\n              const element1 = document.getElementById(\r\n                `node-${node1.row}-${node1.col}`\r\n              );\r\n              if (element1) {\r\n                visitedByAgent1.add(key1);\r\n                // Check if Agent 2 already visited this node\r\n                if (visitedByAgent2.has(key1)) {\r\n                  element1.classList.remove(\"node-visited-second\");\r\n                  element1.classList.add(\"node-visited-overlap\");\r\n                } else {\r\n                  element1.classList.add(\"node-visited\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Agent 2 animation\r\n          if (i < visited2.length) {\r\n            const node2 = visited2[i];\r\n            if (!node2.isStart && !node2.isFinish) {\r\n              const key2 = `${node2.row}-${node2.col}`;\r\n              const element2 = document.getElementById(\r\n                `node-${node2.row}-${node2.col}`\r\n              );\r\n              if (element2) {\r\n                visitedByAgent2.add(key2);\r\n                // Check if Agent 1 already visited this node\r\n                if (visitedByAgent1.has(key2)) {\r\n                  element2.classList.remove(\"node-visited\");\r\n                  element2.classList.add(\"node-visited-overlap\");\r\n                } else {\r\n                  element2.classList.add(\"node-visited-second\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // After last visited node, animate paths\r\n          if (i === maxVisitedLen - 1) {\r\n            const pathDelay = setTimeout(() => {\r\n              // Create a Set for path1 nodes for O(1) lookup (to detect overlaps)\r\n              const path1Keys = new Set<string>();\r\n              for (const node of path1) {\r\n                path1Keys.add(`${node.row}-${node.col}`);\r\n              }\r\n\r\n              // Create a Set for path2 nodes for O(1) lookup\r\n              const path2Keys = new Set<string>();\r\n              for (const node of path2) {\r\n                path2Keys.add(`${node.row}-${node.col}`);\r\n              }\r\n\r\n              // SIMPLIFIED: Path animation uses simple CSS classes\r\n              // Complex SVG overlay will be added in a future component\r\n              const maxPathLen = Math.max(path1.length, path2.length);\r\n\r\n              for (let j = 0; j < maxPathLen; j++) {\r\n                const pathTimeoutId = setTimeout(() => {\r\n                  // Path 1 animation (Agent 1 - Yellow)\r\n                  if (j < path1.length) {\r\n                    const pathNode1 = path1[j];\r\n                    if (!pathNode1.isStart && !pathNode1.isFinish) {\r\n                      const key1 = `${pathNode1.row}-${pathNode1.col}`;\r\n                      const element = document.getElementById(\r\n                        `node-${pathNode1.row}-${pathNode1.col}`\r\n                      );\r\n                      if (element) {\r\n                        element.classList.remove(\r\n                          \"node-visited\",\r\n                          \"node-visited-second\",\r\n                          \"node-visited-overlap\"\r\n                        );\r\n                        // Check if this node is also in path2 (overlap)\r\n                        if (path2Keys.has(key1)) {\r\n                          // Simple overlap class (lime green for now)\r\n                          element.classList.add(\"node-path-overlap\");\r\n                        } else {\r\n                          element.classList.add(\"node-path\");\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  // Path 2 animation (Agent 2 - Cyan)\r\n                  if (j < path2.length) {\r\n                    const pathNode2 = path2[j];\r\n                    if (!pathNode2.isStart && !pathNode2.isFinish) {\r\n                      const key2 = `${pathNode2.row}-${pathNode2.col}`;\r\n                      const element = document.getElementById(\r\n                        `node-${pathNode2.row}-${pathNode2.col}`\r\n                      );\r\n                      if (element) {\r\n                        element.classList.remove(\r\n                          \"node-visited\",\r\n                          \"node-visited-second\",\r\n                          \"node-visited-overlap\",\r\n                          \"node-path\"\r\n                        );\r\n                        // Check if this node is also in path1 (overlap)\r\n                        if (path1Keys.has(key2)) {\r\n                          // Simple overlap class (lime green for now)\r\n                          element.classList.add(\"node-path-overlap\");\r\n                        } else {\r\n                          element.classList.add(\"node-path-second\");\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  // After both paths complete\r\n                  if (j === maxPathLen - 1) {\r\n                    isAnimating.current = false;\r\n                    setIsVisualizing(false);\r\n\r\n                    // Update stats and scroll to statistics section\r\n                    if (statsCallbacks) {\r\n                      statsCallbacks.setVisualizationStats(raceStats);\r\n                      // Add to run history\r\n                      if (\r\n                        statsCallbacks.addRunRecord &&\r\n                        statsCallbacks.gridSize\r\n                      ) {\r\n                        const winnerName =\r\n                          raceStats.winner === \"agent1\"\r\n                            ? raceStats.agent1.algorithm\r\n                            : raceStats.winner === \"agent2\"\r\n                            ? raceStats.agent2.algorithm\r\n                            : raceStats.winner === \"tie\"\r\n                            ? \"Tie\"\r\n                            : \"Both Failed\";\r\n                        statsCallbacks.addRunRecord({\r\n                          mode: \"Race\",\r\n                          algorithm1: raceStats.agent1.algorithm,\r\n                          algorithm2: raceStats.agent2.algorithm,\r\n                          gridSize: statsCallbacks.gridSize,\r\n                          time1: raceStats.agent1.executionTime,\r\n                          pathLength1: raceStats.agent1.pathLength,\r\n                          visitedCount1: raceStats.agent1.visitedCount,\r\n                          time2: raceStats.agent2.executionTime,\r\n                          pathLength2: raceStats.agent2.pathLength,\r\n                          visitedCount2: raceStats.agent2.visitedCount,\r\n                          winner: winnerName,\r\n                        });\r\n                      }\r\n                      setTimeout(() => {\r\n                        statsCallbacks.scrollToStats();\r\n                      }, 500);\r\n                    }\r\n                  }\r\n                }, j * (speed * 3));\r\n\r\n                timeoutIds.current.push(pathTimeoutId);\r\n              }\r\n\r\n              // Handle case where both paths are empty\r\n              if (maxPathLen === 0) {\r\n                isAnimating.current = false;\r\n                setIsVisualizing(false);\r\n\r\n                // Update stats and scroll even if no paths found\r\n                if (statsCallbacks) {\r\n                  statsCallbacks.setVisualizationStats(raceStats);\r\n                  // Add to run history\r\n                  if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n                    const winnerName =\r\n                      raceStats.winner === \"agent1\"\r\n                        ? raceStats.agent1.algorithm\r\n                        : raceStats.winner === \"agent2\"\r\n                        ? raceStats.agent2.algorithm\r\n                        : raceStats.winner === \"tie\"\r\n                        ? \"Tie\"\r\n                        : \"Both Failed\";\r\n                    statsCallbacks.addRunRecord({\r\n                      mode: \"Race\",\r\n                      algorithm1: raceStats.agent1.algorithm,\r\n                      algorithm2: raceStats.agent2.algorithm,\r\n                      gridSize: statsCallbacks.gridSize,\r\n                      time1: raceStats.agent1.executionTime,\r\n                      pathLength1: raceStats.agent1.pathLength,\r\n                      visitedCount1: raceStats.agent1.visitedCount,\r\n                      time2: raceStats.agent2.executionTime,\r\n                      pathLength2: raceStats.agent2.pathLength,\r\n                      visitedCount2: raceStats.agent2.visitedCount,\r\n                      winner: winnerName,\r\n                    });\r\n                  }\r\n                  // Show toast if neither algorithm found a path\r\n                  if (!path1Found && !path2Found && statsCallbacks.showToast) {\r\n                    statsCallbacks.showToast(\r\n                      \"Target is unreachable! Neither algorithm found a path.\"\r\n                    );\r\n                  }\r\n                  setTimeout(() => {\r\n                    statsCallbacks.scrollToStats();\r\n                  }, 500);\r\n                }\r\n              }\r\n            }, 50);\r\n\r\n            timeoutIds.current.push(pathDelay);\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n\r\n      // Handle case where both visited arrays are empty\r\n      if (maxVisitedLen === 0) {\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n\r\n        // Update stats and scroll even if nothing was visited\r\n        if (statsCallbacks) {\r\n          statsCallbacks.setVisualizationStats(raceStats);\r\n          // Add to run history\r\n          if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n            const winnerName =\r\n              raceStats.winner === \"agent1\"\r\n                ? raceStats.agent1.algorithm\r\n                : raceStats.winner === \"agent2\"\r\n                ? raceStats.agent2.algorithm\r\n                : raceStats.winner === \"tie\"\r\n                ? \"Tie\"\r\n                : \"Both Failed\";\r\n            statsCallbacks.addRunRecord({\r\n              mode: \"Race\",\r\n              algorithm1: raceStats.agent1.algorithm,\r\n              algorithm2: raceStats.agent2.algorithm,\r\n              gridSize: statsCallbacks.gridSize,\r\n              time1: raceStats.agent1.executionTime,\r\n              pathLength1: raceStats.agent1.pathLength,\r\n              visitedCount1: raceStats.agent1.visitedCount,\r\n              time2: raceStats.agent2.executionTime,\r\n              pathLength2: raceStats.agent2.pathLength,\r\n              visitedCount2: raceStats.agent2.visitedCount,\r\n              winner: winnerName,\r\n            });\r\n          }\r\n          setTimeout(() => {\r\n            statsCallbacks.scrollToStats();\r\n          }, 500);\r\n        }\r\n      }\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      runAlgorithm,\r\n      runBenchmark,\r\n      BENCHMARK_MIN_DURATION,\r\n    ]\r\n  );\r\n\r\n  return {\r\n    visualizePathfinding,\r\n    visualizeRace,\r\n    generateMaze,\r\n    clearVisualization,\r\n    isAnimating,\r\n  };\r\n};\r\n\r\nexport default useVisualization;\r\n","import React, {\r\n  useRef,\r\n  useCallback,\r\n  useState,\r\n  lazy,\r\n  Suspense,\r\n  useEffect,\r\n} from \"react\";\r\nimport { GridProvider, useGridContext } from \"./context/GridContext\";\r\nimport Board from \"./components/Board\";\r\nimport { ControlPanel } from \"./components/Controls\";\r\nimport { Legend } from \"./components/Legend\";\r\nimport Toast from \"./components/UI/Toast\";\r\nimport { useVisualization } from \"./hooks/useVisualization\";\r\nimport { MazeType } from \"./types\";\r\nimport styles from \"./App.module.css\";\r\n\r\n// Lazy load the Statistics and History sections to reduce initial bundle size\r\n// These components are below the fold and not needed for initial render\r\nconst StatisticsSection = lazy(\r\n  () => import(\"./components/Statistics/StatisticsSection\")\r\n);\r\nconst HistorySection = lazy(\r\n  () => import(\"./components/History/HistorySection\")\r\n);\r\n\r\n/**\r\n * MainContent Component - Two-Page Scroll Layout\r\n * Section 1: Visualizer (Board + Controls)\r\n * Section 2: Statistics Dashboard\r\n */\r\nconst MainContent: React.FC = () => {\r\n  const {\r\n    grid,\r\n    setGrid,\r\n    setIsVisualizing,\r\n    animationSpeed,\r\n    selectedAlgorithm,\r\n    secondAlgorithm,\r\n    isRaceMode,\r\n    clearAllWalls,\r\n    visualizationStats,\r\n    setVisualizationStats,\r\n    showToast,\r\n    selectedMaze,\r\n    runHistory,\r\n    clearRunHistory,\r\n    deleteRunRecord,\r\n    addRunRecord,\r\n    rowCount,\r\n    colCount,\r\n  } = useGridContext();\r\n\r\n  const {\r\n    visualizePathfinding,\r\n    visualizeRace,\r\n    generateMaze,\r\n    clearVisualization,\r\n  } = useVisualization();\r\n\r\n  // Ref for the stats section to enable programmatic scrolling\r\n  const statsSectionRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Mobile sidebar state\r\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false);\r\n\r\n  // Track if initial maze has been generated\r\n  const [hasGeneratedInitialMaze, setHasGeneratedInitialMaze] = useState(false);\r\n\r\n  // Auto-generate maze on mount for better first paint experience\r\n  useEffect(() => {\r\n    if (hasGeneratedInitialMaze) return;\r\n\r\n    // Small delay to ensure DOM is fully ready and grid is mounted\r\n    const timer = setTimeout(() => {\r\n      generateMaze(\r\n        selectedMaze,\r\n        grid,\r\n        setGrid,\r\n        setIsVisualizing,\r\n        Math.max(15, animationSpeed / 2)\r\n      );\r\n      setHasGeneratedInitialMaze(true);\r\n    }, 300);\r\n\r\n    return () => clearTimeout(timer);\r\n  }, [hasGeneratedInitialMaze]); // Only depend on the flag to run once\r\n\r\n  // Toggle mobile sidebar\r\n  const toggleSidebar = useCallback(() => {\r\n    setIsSidebarOpen((prev) => !prev);\r\n  }, []);\r\n\r\n  // Close sidebar (for overlay click)\r\n  const closeSidebar = useCallback(() => {\r\n    setIsSidebarOpen(false);\r\n  }, []);\r\n\r\n  // Scroll to stats section\r\n  const scrollToStats = useCallback(() => {\r\n    statsSectionRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n  }, []);\r\n\r\n  // Stats callbacks for visualization hooks\r\n  const statsCallbacks = {\r\n    setVisualizationStats,\r\n    scrollToStats,\r\n    showToast,\r\n    addRunRecord,\r\n    gridSize: `${rowCount}x${colCount}`,\r\n  };\r\n\r\n  // Handler for visualize button (single algorithm)\r\n  const handleVisualize = (): void => {\r\n    visualizePathfinding(\r\n      selectedAlgorithm,\r\n      grid,\r\n      setGrid,\r\n      setIsVisualizing,\r\n      animationSpeed,\r\n      statsCallbacks\r\n    );\r\n  };\r\n\r\n  // Handler for race mode visualization (two algorithms)\r\n  const handleVisualizeRace = (): void => {\r\n    if (secondAlgorithm) {\r\n      visualizeRace(\r\n        selectedAlgorithm,\r\n        secondAlgorithm,\r\n        grid,\r\n        setGrid,\r\n        setIsVisualizing,\r\n        animationSpeed,\r\n        statsCallbacks\r\n      );\r\n    }\r\n  };\r\n\r\n  // Handler for clear path button\r\n  const handleClearPath = (): void => {\r\n    clearVisualization(grid, setGrid);\r\n  };\r\n\r\n  // Handler for generate maze button\r\n  const handleGenerateMaze = (mazeType: MazeType): void => {\r\n    handleClearPath();\r\n    clearAllWalls();\r\n\r\n    requestAnimationFrame(() => {\r\n      setTimeout(() => {\r\n        generateMaze(\r\n          mazeType,\r\n          grid,\r\n          setGrid,\r\n          setIsVisualizing,\r\n          Math.max(15, animationSpeed / 2)\r\n        );\r\n      }, 50);\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div className={styles.snapContainer}>\r\n      {/* Section 1: Visualizer */}\r\n      <div className={`${styles.snapSection} ${styles.visualizerSection}`}>\r\n        {/* Mobile Menu Toggle Button */}\r\n        <button\r\n          className={styles.mobileMenuToggle}\r\n          onClick={toggleSidebar}\r\n          aria-label={isSidebarOpen ? \"Close menu\" : \"Open menu\"}\r\n          aria-expanded={isSidebarOpen}\r\n        >\r\n          <span className={styles.hamburgerIcon}>\r\n            {isSidebarOpen ? \"\" : \"\"}\r\n          </span>\r\n        </button>\r\n\r\n        {/* Mobile Overlay */}\r\n        {isSidebarOpen && (\r\n          <div\r\n            className={styles.sidebarOverlay}\r\n            onClick={closeSidebar}\r\n            aria-hidden=\"true\"\r\n          />\r\n        )}\r\n\r\n        {/* Control Panel Sidebar - Fixed width, full height */}\r\n        <aside\r\n          className={`${styles.controlPanelSidebar} ${\r\n            isSidebarOpen ? styles.sidebarOpen : \"\"\r\n          }`}\r\n        >\r\n          <ControlPanel\r\n            onVisualize={handleVisualize}\r\n            onClearPath={handleClearPath}\r\n            onGenerateMaze={handleGenerateMaze}\r\n            onVisualizeRace={handleVisualizeRace}\r\n          />\r\n        </aside>\r\n\r\n        {/* Game Area - Takes remaining space */}\r\n        <div className={styles.gameArea}>\r\n          {/* Header - Fixed height */}\r\n          <header className={styles.header}>\r\n            <h1 className={styles.title}>Maze & Pathfinding Visualizer</h1>\r\n            <p className={styles.subtitle}>\r\n              Visualize pathfinding algorithms on an interactive grid\r\n            </p>\r\n          </header>\r\n\r\n          {/* Board Container - Takes all remaining vertical space */}\r\n          <div className={styles.boardContainer}>\r\n            <Board />\r\n          </div>\r\n\r\n          {/* Legend - Fixed height */}\r\n          <div className={styles.legendArea}>\r\n            <Legend orientation=\"horizontal\" compact />\r\n          </div>\r\n\r\n          {/* Scroll Indicator - Fixed height */}\r\n          <footer className={styles.footer}>\r\n            <div className={styles.scrollIndicator} onClick={scrollToStats}>\r\n              <span>View Statistics</span>\r\n              <span></span>\r\n            </div>\r\n          </footer>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Section 2: Statistics */}\r\n      <div className={styles.snapSection} ref={statsSectionRef}>\r\n        <Suspense\r\n          fallback={\r\n            <div className={styles.statsLoading}>Loading Statistics...</div>\r\n          }\r\n        >\r\n          <StatisticsSection\r\n            stats={visualizationStats}\r\n            isRaceMode={isRaceMode}\r\n          />\r\n        </Suspense>\r\n      </div>\r\n\r\n      {/* Section 3: Run History */}\r\n      <div className={styles.snapSection}>\r\n        <Suspense\r\n          fallback={\r\n            <div className={styles.statsLoading}>Loading History...</div>\r\n          }\r\n        >\r\n          <HistorySection\r\n            history={runHistory}\r\n            onClearHistory={clearRunHistory}\r\n            onDeleteRecord={deleteRunRecord}\r\n          />\r\n        </Suspense>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n/**\r\n * Main Application Component\r\n * Wraps the entire app with GridProvider for global state management.\r\n */\r\nconst App: React.FC = () => {\r\n  return (\r\n    <GridProvider>\r\n      <MainContent />\r\n      <Toast />\r\n    </GridProvider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom/client';\r\nimport App from './App';\r\nimport './styles/variables.css';\r\n\r\n/**\r\n * Application Entry Point\r\n * \r\n * Renders the root App component into the DOM\r\n */\r\nReactDOM.createRoot(document.getElementById('root')!).render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>\r\n);\r\n"],"file":"assets/index-DDngb6H_.js"}