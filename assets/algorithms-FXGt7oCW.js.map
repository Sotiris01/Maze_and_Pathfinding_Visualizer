{"version":3,"file":"algorithms-FXGt7oCW.js","sources":["../../src/algorithms/pathfinding/dijkstra.ts","../../src/algorithms/pathfinding/astar.ts","../../src/algorithms/pathfinding/bfs.ts","../../src/algorithms/pathfinding/dfs.ts","../../src/algorithms/pathfinding/greedyBestFirst.ts","../../src/algorithms/pathfinding/bidirectionalBFS.ts","../../src/algorithms/pathfinding/bidirectionalAStar.ts","../../src/algorithms/pathfinding/jumpPointSearch.ts","../../src/algorithms/maze/recursiveDivision.ts","../../src/algorithms/maze/randomizedDFS.ts","../../src/algorithms/maze/prims.ts","../../src/algorithms/maze/spiralMaze.ts","../../src/algorithms/maze/cellularAutomata.ts","../../src/utils/perlinNoise.ts","../../src/algorithms/maze/terrainMap.ts"],"sourcesContent":["/**\r\n * Dijkstra's Algorithm Implementation\r\n * Phase B: Basic Pathfinding\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n * - decreaseKey: O(log n)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  private getKey(node: Node): string {\r\n    return `${node.row}-${node.col}`;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Update existing node (decrease key)\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (this.heap[idx].distance >= this.heap[parentIdx].distance) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.heap[leftIdx].distance < this.heap[smallest].distance\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.heap[rightIdx].distance < this.heap[smallest].distance\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Dijkstra's Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Performs Dijkstra's algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize start node distance to 0 (all others are Infinity)\r\n * 2. Insert start node into min-heap priority queue\r\n * 3. Loop while heap is not empty:\r\n *    - Extract node with minimum distance\r\n *    - If already visited → skip\r\n *    - If wall → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - If finish → done\r\n *    - Relax all unvisited neighbors (update distances if shorter)\r\n */\r\nexport function dijkstra(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const visited = new Set<string>();\r\n\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize start node distance\r\n  startNode.distance = 0;\r\n\r\n  // Min-heap priority queue\r\n  const minHeap = new MinHeap();\r\n  minHeap.insert(startNode);\r\n\r\n  while (!minHeap.isEmpty()) {\r\n    // Extract node with minimum distance\r\n    const closestNode = minHeap.extractMin()!;\r\n    const closestKey = getKey(closestNode);\r\n\r\n    // Skip if already visited\r\n    if (visited.has(closestKey)) {\r\n      continue;\r\n    }\r\n\r\n    // Skip walls - they are not traversable\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If closest node has Infinity distance, we're trapped\r\n    if (closestNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    visited.add(closestKey);\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Relax all unvisited neighbors\r\n    const neighbors = getUnvisitedNeighbors(closestNode, grid, visited);\r\n    for (const neighbor of neighbors) {\r\n      // Use neighbor's weight as the traversal cost (1 = normal, higher = heavier terrain)\r\n      const newDistance = closestNode.distance + neighbor.weight;\r\n\r\n      // Standard Dijkstra relaxation: only update if shorter\r\n      if (newDistance < neighbor.distance) {\r\n        neighbor.distance = newDistance;\r\n        neighbor.previousNode = closestNode;\r\n        minHeap.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by dijkstra)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(\r\n  node: Node,\r\n  grid: Grid,\r\n  visited: Set<string>\r\n): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited, non-wall neighbors\r\n  return neighbors.filter((neighbor) => {\r\n    const key = `${neighbor.row}-${neighbor.col}`;\r\n    return !visited.has(key) && !neighbor.isWall;\r\n  });\r\n}\r\n","/**\r\n * A* (A-Star) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * A* is an informed search algorithm that uses a heuristic to guide\r\n * its search towards the goal, making it more efficient than Dijkstra\r\n * for pathfinding problems.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n *\r\n * Uses a binary min-heap priority queue for O(n log n) performance.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n * - decreaseKey (via re-insert): O(log n)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private getKey: (node: Node) => string;\r\n  private getPriority: (node: Node) => number;\r\n  private positionMap: Map<string, number> = new Map(); // Track node positions for O(1) contains check\r\n\r\n  constructor(\r\n    getKey: (node: Node) => string,\r\n    getPriority: (node: Node) => number\r\n  ) {\r\n    this.getKey = getKey;\r\n    this.getPriority = getPriority;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  contains(node: Node): boolean {\r\n    return this.positionMap.has(this.getKey(node));\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Node already exists - update its position (decrease key operation)\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      // New node\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | null {\r\n    if (this.heap.length === 0) return null;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (\r\n        this.getPriority(this.heap[idx]) >=\r\n        this.getPriority(this.heap[parentIdx])\r\n      ) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.getPriority(this.heap[leftIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.getPriority(this.heap[rightIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// A* Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement (up, down, left, right), the Manhattan distance\r\n * provides an admissible heuristic (never overestimates the actual cost).\r\n *\r\n * @param nodeA - First node\r\n * @param nodeB - Second node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize gScore (distance from start) and fScore (gScore + heuristic)\r\n * 2. Add startNode to Open Set (min-heap priority queue)\r\n * 3. Loop while Open Set is not empty:\r\n *    - Extract node with lowest fScore (O(log n))\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each neighbor:\r\n *      - Calculate tentative gScore\r\n *      - If tentative < neighbor's gScore:\r\n *        - Update neighbor's previousNode, gScore, fScore\r\n *        - Insert/update in Open Set (O(log n))\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n */\r\nexport function astar(grid: Grid, startNode: Node, finishNode: Node): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Use Maps to track scores (avoid mutating Node objects in React state)\r\n  // Key: \"row-col\", Value: score\r\n  const gScore = new Map<string, number>();\r\n  const fScore = new Map<string, number>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScore.set(key, Infinity);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScore.set(startKey, 0);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n\r\n  // Open Set - min-heap priority queue sorted by fScore\r\n  const openSet = new MinHeap(\r\n    getKey,\r\n    (node: Node) => fScore.get(getKey(node)) ?? Infinity\r\n  );\r\n  openSet.insert(startNode);\r\n\r\n  while (!openSet.isEmpty()) {\r\n    // Extract node with lowest fScore - O(log n)\r\n    const current = openSet.extractMin()!;\r\n    const currentKey = getKey(current);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (current.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Check if we're trapped (no path exists)\r\n    const currentGScore = gScore.get(currentKey) ?? Infinity;\r\n    if (currentGScore === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Calculate tentative gScore using neighbor's weight as traversal cost\r\n      // (1 = normal terrain, higher = heavier terrain like mud/hills)\r\n      const tentativeGScore = currentGScore + neighbor.weight;\r\n\r\n      // If this path is better than any previous one\r\n      const neighborGScore = gScore.get(neighborKey) ?? Infinity;\r\n      if (tentativeGScore < neighborGScore) {\r\n        // Update the path - this is the best path to this neighbor so far\r\n        neighbor.previousNode = current;\r\n        gScore.set(neighborKey, tentativeGScore);\r\n        fScore.set(\r\n          neighborKey,\r\n          tentativeGScore + manhattanDistance(neighbor, finishNode)\r\n        );\r\n\r\n        // Insert or update in open set - O(log n)\r\n        openSet.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Reuses the same logic as Dijkstra since both use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by astar)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nexport default astar;\r\n","/**\r\n * Breadth-First Search (BFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * BFS explores nodes layer by layer, guaranteeing the shortest path\r\n * in an unweighted graph (all edges have equal cost).\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n *\r\n * Uses an O(1) dequeue implementation for optimal performance.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// O(1) Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Simple queue with O(1) enqueue and dequeue operations.\r\n * Uses a head pointer instead of Array.shift() which is O(n).\r\n */\r\nclass Queue<T> {\r\n  private items: T[] = [];\r\n  private head: number = 0;\r\n\r\n  enqueue(item: T): void {\r\n    this.items.push(item);\r\n  }\r\n\r\n  dequeue(): T | undefined {\r\n    if (this.isEmpty()) return undefined;\r\n    const item = this.items[this.head];\r\n    this.head++;\r\n    // Periodically compact the array to prevent memory bloat\r\n    if (this.head > 1000 && this.head > this.items.length / 2) {\r\n      this.items = this.items.slice(this.head);\r\n      this.head = 0;\r\n    }\r\n    return item;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.head >= this.items.length;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.items.length - this.head;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// BFS Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Performs Breadth-First Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize a queue with the start node\r\n * 2. Mark start node as visited\r\n * 3. While queue is not empty:\r\n *    - Dequeue the first node (FIFO) - O(1)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Get all unvisited neighbors (up, down, left, right)\r\n *    - For each neighbor:\r\n *      - Mark as visited\r\n *      - Set previousNode pointer\r\n *      - Enqueue the neighbor\r\n *      - Add to visitedNodesInOrder\r\n * 4. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Time Complexity: O(V + E) where V = vertices, E = edges\r\n * Space Complexity: O(V)\r\n */\r\nexport function bfs(grid: Grid, startNode: Node, finishNode: Node): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Queue for BFS - FIFO with O(1) operations\r\n  const queue = new Queue<Node>();\r\n\r\n  // Initialize: mark start as visited and enqueue\r\n  startNode.isVisited = true;\r\n  startNode.distance = 0;\r\n  queue.enqueue(startNode);\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  while (!queue.isEmpty()) {\r\n    // Dequeue the first node (FIFO) - O(1)\r\n    const currentNode = queue.dequeue()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Mark as visited\r\n      neighbor.isVisited = true;\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Set distance (optional for BFS, but useful for consistency)\r\n      neighbor.distance = currentNode.distance + 1;\r\n\r\n      // Enqueue the neighbor - O(1)\r\n      queue.enqueue(neighbor);\r\n\r\n      // Record visit order for animation\r\n      visitedNodesInOrder.push(neighbor);\r\n\r\n      // Early exit: if we just added the finish node, we can return\r\n      if (neighbor === finishNode) {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Identical to Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by bfs)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default bfs;\r\n","/**\r\n * Depth-First Search (DFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * DFS explores as far as possible along each branch before backtracking.\r\n * Unlike BFS, DFS does NOT guarantee the shortest path.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Depth-First Search to find a path (not necessarily shortest).\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps (Iterative):\r\n * 1. Initialize a stack with the start node\r\n * 2. While stack is not empty:\r\n *    - Pop the last node (LIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If already visited → skip\r\n *    - Mark as visited and add to visitedNodesInOrder\r\n *    - Get all unvisited neighbors\r\n *    - For each neighbor:\r\n *      - Set previousNode pointer\r\n *      - Push to stack\r\n * 3. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path (explores depth-first)\r\n * - Uses a Stack (LIFO) data structure\r\n * - Memory efficient for deep paths\r\n * - Creates a \"snake-like\" movement pattern\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function dfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Stack for DFS - LIFO (Last In, First Out)\r\n  const stack: Node[] = [];\r\n\r\n  // Initialize: push start node onto stack\r\n  stack.push(startNode);\r\n\r\n  while (stack.length > 0) {\r\n    // Pop the last node (LIFO)\r\n    const currentNode = stack.pop()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (currentNode.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n\r\n    // Record visit order for animation\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    // Order: Up, Right, Down, Left\r\n    // Since stack is LIFO, we push in reverse order so Up is explored first\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Skip already visited\r\n      if (neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Push to stack\r\n      stack.push(neighbor);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n * (Identical to BFS/Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by dfs)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n * Warning: For DFS, this path is NOT necessarily the shortest!\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n *\r\n * Order: Up, Right, Down, Left (reversed for stack to create consistent movement)\r\n * Since stack is LIFO, the last pushed neighbor is explored first.\r\n * We push Left, Down, Right, Up so that Up is explored first.\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Push in reverse order for LIFO stack: Left, Down, Right, Up\r\n  // This makes DFS explore in order: Up, Right, Down, Left\r\n\r\n  // Left (pushed first, explored last)\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  // Up (pushed last, explored first)\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default dfs;\r\n","/**\r\n * Greedy Best-First Search Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Greedy Best-First Search is an informed search algorithm that selects\r\n * nodes based solely on their heuristic value (estimated distance to goal).\r\n *\r\n * Key Difference from A*:\r\n * - A* uses: fScore = gScore + hScore (actual distance + estimated remaining)\r\n * - Greedy uses: fScore = hScore only (ignores actual distance traveled)\r\n *\r\n * This makes Greedy faster but does NOT guarantee the shortest path.\r\n * It's useful when you want to find \"a\" path quickly, not necessarily the best one.\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n *\r\n * Note: Since this algorithm uses heuristics (needs to know target location),\r\n * it should be DISABLED in Hidden Target Mode.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private getKey: (node: Node) => string;\r\n  private getPriority: (node: Node) => number;\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  constructor(\r\n    getKey: (node: Node) => string,\r\n    getPriority: (node: Node) => number\r\n  ) {\r\n    this.getKey = getKey;\r\n    this.getPriority = getPriority;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Update existing node's position\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (\r\n        this.getPriority(this.heap[idx]) >=\r\n        this.getPriority(this.heap[parentIdx])\r\n      ) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.getPriority(this.heap[leftIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.getPriority(this.heap[rightIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Greedy Best-First Search Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides\r\n * the estimated distance to the goal.\r\n *\r\n * @param nodeA - Current node\r\n * @param nodeB - Target node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Greedy Best-First Search to find a path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize priority = heuristic (distance to goal only)\r\n * 2. Add startNode to min-heap priority queue\r\n * 3. Loop while heap is not empty:\r\n *    - Extract node with lowest heuristic (closest to goal)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall or visited → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each unvisited neighbor:\r\n *      - Set previousNode for path reconstruction\r\n *      - Calculate priority = heuristic only (no gScore!)\r\n *      - Add to heap\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path\r\n * - Very fast for simple mazes (beelines toward goal)\r\n * - Can get \"stuck\" in dead ends with complex mazes\r\n * - Explores far fewer nodes than BFS/Dijkstra in best case\r\n */\r\nexport function greedyBestFirst(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const visited = new Set<string>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Store heuristic values for heap priority\r\n  const hScore = new Map<string, number>();\r\n\r\n  // Min-heap priority queue using heuristic only\r\n  const openSet = new MinHeap(\r\n    getKey,\r\n    (node: Node) => hScore.get(getKey(node)) ?? Infinity\r\n  );\r\n\r\n  // Initialize start node with heuristic only (no gScore)\r\n  const startKey = getKey(startNode);\r\n  hScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n  openSet.insert(startNode);\r\n\r\n  while (!openSet.isEmpty()) {\r\n    const current = openSet.extractMin()!;\r\n    const currentKey = getKey(current);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (visited.has(currentKey)) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    visited.add(currentKey);\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || visited.has(neighborKey)) {\r\n        continue;\r\n      }\r\n\r\n      // Set the path pointer for backtracking\r\n      neighbor.previousNode = current;\r\n\r\n      // GREEDY: priority = heuristic ONLY (no gScore!)\r\n      // This is the key difference from A*\r\n      hScore.set(neighborKey, manhattanDistance(neighbor, finishNode));\r\n\r\n      // Add to open set\r\n      openSet.insert(neighbor);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by greedyBestFirst)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: This path is NOT guaranteed to be the shortest!\r\n * Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n","/**\r\n * Bidirectional BFS (Breadth-First Search) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional BFS searches from both the start and finish nodes simultaneously,\r\n * meeting somewhere in the middle. This can be significantly faster than\r\n * unidirectional BFS as it explores roughly half the search space.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path in unweighted graphs\r\n * - Explores from both ends simultaneously\r\n * - Meeting point detection when frontiers intersect\r\n * - Uses O(1) queue operations for optimal performance\r\n *\r\n * Time Complexity: O(V + E) with efficient queue\r\n * Space Complexity: O(V)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// O(1) Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Efficient FIFO Queue with O(1) enqueue and dequeue operations.\r\n * Uses a head pointer instead of Array.shift() to avoid O(n) operations.\r\n */\r\nclass Queue<T> {\r\n  private items: T[] = [];\r\n  private head: number = 0;\r\n\r\n  enqueue(item: T): void {\r\n    this.items.push(item);\r\n  }\r\n\r\n  dequeue(): T | undefined {\r\n    if (this.head >= this.items.length) return undefined;\r\n    const item = this.items[this.head];\r\n    this.head++;\r\n    // Compact when more than half the array is dead space\r\n    if (this.head > this.items.length / 2 && this.head > 100) {\r\n      this.items = this.items.slice(this.head);\r\n      this.head = 0;\r\n    }\r\n    return item;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.items.length - this.head;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.head >= this.items.length;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Bidirectional BFS Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Performs Bidirectional BFS to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited (alternating from both sides)\r\n */\r\nexport function bidirectionalBFS(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Parent maps for path reconstruction\r\n  const parentFromStart = new Map<string, Node | null>();\r\n  const parentFromFinish = new Map<string, Node | null>();\r\n\r\n  // Visited sets for each direction\r\n  const visitedFromStart = new Set<string>();\r\n  const visitedFromFinish = new Set<string>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // Initialize O(1) queues\r\n  const startQueue = new Queue<Node>();\r\n  const finishQueue = new Queue<Node>();\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  visitedFromStart.add(startKey);\r\n  parentFromStart.set(startKey, null);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n  startQueue.enqueue(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  visitedFromFinish.add(finishKey);\r\n  parentFromFinish.set(finishKey, null);\r\n  finishQueue.enqueue(finishNode);\r\n\r\n  // Track meeting point\r\n  let meetingKey: string | null = null;\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  // Main loop - alternate between expanding from start and finish\r\n  while (!startQueue.isEmpty() && !finishQueue.isEmpty()) {\r\n    // Expand from start side\r\n    if (!startQueue.isEmpty()) {\r\n      const currentNode = startQueue.dequeue()!;\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from start\r\n        if (visitedFromStart.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from start\r\n        visitedFromStart.add(neighborKey);\r\n        parentFromStart.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from finish - INTERSECTION!\r\n        if (visitedFromFinish.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        startQueue.enqueue(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n\r\n    // Expand from finish side\r\n    if (!finishQueue.isEmpty() && !meetingKey) {\r\n      const currentNode = finishQueue.dequeue()!;\r\n\r\n      // Add finish node to visited order on first expansion\r\n      if (currentNode === finishNode) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from finish\r\n        if (visitedFromFinish.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from finish\r\n        visitedFromFinish.add(neighborKey);\r\n        parentFromFinish.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from start - INTERSECTION!\r\n        if (visitedFromStart.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        finishQueue.enqueue(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n  }\r\n\r\n  // Reconstruct path if meeting point found\r\n  if (meetingKey) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine and set up previousNode chain\r\n    const fullPath = [...pathFromStart, ...pathToFinish];\r\n    for (let i = 1; i < fullPath.length; i++) {\r\n      fullPath[i].previousNode = fullPath[i - 1];\r\n    }\r\n\r\n    // Mark finish as having a valid path\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalBFS.\r\n * Uses the previousNode chain set up during path reconstruction.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Bidirectional A* (A-Star) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional A* combines the efficiency of A* heuristic search with\r\n * bidirectional search strategy. It searches from both start and finish\r\n * nodes simultaneously, using heuristics from both ends.\r\n *\r\n * Key Characteristics:\r\n * - Uses min-heap priority queues for O(log n) operations\r\n * - Two heuristics: startOpenSet → finishNode, finishOpenSet → startNode\r\n * - Meeting point detection when frontiers intersect\r\n * - Guarantees shortest path with consistent heuristics\r\n * - Correct early termination: μ ≤ min(topFStart, topFFinish)\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n * - peekMin: O(1)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private getKey: (node: Node) => string;\r\n  private getPriority: (node: Node) => number;\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  constructor(\r\n    getKey: (node: Node) => string,\r\n    getPriority: (node: Node) => number\r\n  ) {\r\n    this.getKey = getKey;\r\n    this.getPriority = getPriority;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  peekMin(): Node | undefined {\r\n    return this.heap[0];\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Update existing node's position (decrease key)\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (\r\n        this.getPriority(this.heap[idx]) >=\r\n        this.getPriority(this.heap[parentIdx])\r\n      ) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.getPriority(this.heap[leftIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.getPriority(this.heap[rightIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Bidirectional A* Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides an\r\n * admissible and consistent heuristic.\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Bidirectional A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm:\r\n * 1. Initialize two min-heaps - one from start, one from finish\r\n * 2. Alternate expansions, tracking best meeting point\r\n * 3. Terminate when: μ ≤ min(topFStart, topFFinish)\r\n *    where μ = best path cost found so far\r\n * 4. Reconstruct path through meeting point\r\n */\r\nexport function bidirectionalAStar(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // === START SIDE DATA STRUCTURES ===\r\n  const gScoreStart = new Map<string, number>();\r\n  const fScoreStart = new Map<string, number>();\r\n  const parentFromStart = new Map<string, Node | null>();\r\n  const visitedFromStart = new Set<string>();\r\n\r\n  // === FINISH SIDE DATA STRUCTURES ===\r\n  const gScoreFinish = new Map<string, number>();\r\n  const fScoreFinish = new Map<string, number>();\r\n  const parentFromFinish = new Map<string, Node | null>();\r\n  const visitedFromFinish = new Set<string>();\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScoreStart.set(key, Infinity);\r\n      fScoreStart.set(key, Infinity);\r\n      gScoreFinish.set(key, Infinity);\r\n      fScoreFinish.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScoreStart.set(startKey, 0);\r\n  fScoreStart.set(startKey, manhattanDistance(startNode, finishNode));\r\n  parentFromStart.set(startKey, null);\r\n  visitedFromStart.add(startKey);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  gScoreFinish.set(finishKey, 0);\r\n  fScoreFinish.set(finishKey, manhattanDistance(finishNode, startNode));\r\n  parentFromFinish.set(finishKey, null);\r\n  visitedFromFinish.add(finishKey);\r\n\r\n  // Min-heap priority queues\r\n  const openSetStart = new MinHeap(\r\n    getKey,\r\n    (node: Node) => fScoreStart.get(getKey(node)) ?? Infinity\r\n  );\r\n  const openSetFinish = new MinHeap(\r\n    getKey,\r\n    (node: Node) => fScoreFinish.get(getKey(node)) ?? Infinity\r\n  );\r\n\r\n  openSetStart.insert(startNode);\r\n  openSetFinish.insert(finishNode);\r\n\r\n  // Track best meeting point\r\n  let meetingKey: string | null = null;\r\n  let bestPathCost = Infinity; // μ in the literature\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  // Main loop - expand from the side with smaller minimum f-score\r\n  // This optimization reduces unnecessary exploration while maintaining correctness\r\n  while (!openSetStart.isEmpty() && !openSetFinish.isEmpty()) {\r\n    // === TERMINATION CHECK ===\r\n    // Standard bidirectional A* termination:\r\n    // Stop when μ ≤ min(top fScore from both sides)\r\n    const topFStart =\r\n      fScoreStart.get(getKey(openSetStart.peekMin()!)) ?? Infinity;\r\n    const topFFinish =\r\n      fScoreFinish.get(getKey(openSetFinish.peekMin()!)) ?? Infinity;\r\n\r\n    if (bestPathCost <= Math.min(topFStart, topFFinish)) {\r\n      break;\r\n    }\r\n\r\n    // === CHOOSE WHICH SIDE TO EXPAND ===\r\n    // Always expand from the side with smaller minimum f-score\r\n    // This balances the search and reduces total nodes explored\r\n    const expandFromStart = topFStart <= topFFinish;\r\n\r\n    if (expandFromStart) {\r\n      // === EXPAND FROM START SIDE ===\r\n      const current = openSetStart.extractMin()!;\r\n      const currentKey = getKey(current);\r\n\r\n      if (current.isWall) continue;\r\n\r\n      // Check for intersection with finish side\r\n      if (visitedFromFinish.has(currentKey)) {\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n        // Use neighbor's weight as traversal cost (1 = normal, higher = heavier terrain)\r\n        const tentativeGScore =\r\n          (gScoreStart.get(currentKey) ?? Infinity) + neighbor.weight;\r\n        const neighborGScore = gScoreStart.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          parentFromStart.set(neighborKey, current);\r\n          gScoreStart.set(neighborKey, tentativeGScore);\r\n          fScoreStart.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, finishNode)\r\n          );\r\n\r\n          openSetStart.insert(neighbor);\r\n\r\n          if (!visitedFromStart.has(neighborKey)) {\r\n            visitedFromStart.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check for better meeting point\r\n            if (visitedFromFinish.has(neighborKey)) {\r\n              const pathCost =\r\n                tentativeGScore + (gScoreFinish.get(neighborKey) ?? Infinity);\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // === EXPAND FROM FINISH SIDE ===\r\n      const current = openSetFinish.extractMin()!;\r\n      const currentKey = getKey(current);\r\n\r\n      if (current.isWall) continue;\r\n\r\n      // Add finish node to visited on first expansion\r\n      if (current === finishNode && !visitedNodesInOrder.includes(finishNode)) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      // Check for intersection with start side\r\n      if (visitedFromStart.has(currentKey)) {\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n        // Use neighbor's weight as traversal cost (1 = normal, higher = heavier terrain)\r\n        const tentativeGScore =\r\n          (gScoreFinish.get(currentKey) ?? Infinity) + neighbor.weight;\r\n        const neighborGScore = gScoreFinish.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          parentFromFinish.set(neighborKey, current);\r\n          gScoreFinish.set(neighborKey, tentativeGScore);\r\n          fScoreFinish.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, startNode)\r\n          );\r\n\r\n          openSetFinish.insert(neighbor);\r\n\r\n          if (!visitedFromFinish.has(neighborKey)) {\r\n            visitedFromFinish.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check for better meeting point\r\n            if (visitedFromStart.has(neighborKey)) {\r\n              const pathCost =\r\n                (gScoreStart.get(neighborKey) ?? Infinity) + tentativeGScore;\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reconstruct path through meeting point\r\n  if (meetingKey !== null) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine and set up previousNode chain\r\n    const fullPath = [...pathFromStart, ...pathToFinish];\r\n    for (let i = 1; i < fullPath.length; i++) {\r\n      fullPath[i].previousNode = fullPath[i - 1];\r\n    }\r\n\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalAStar.\r\n * Uses the previousNode chain set up during path reconstruction.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Jump Point Search (JPS) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Jump Point Search is an optimization over A* for uniform-cost grids.\r\n * It dramatically reduces the number of nodes that need to be examined\r\n * by \"jumping\" over intermediate nodes in straight lines and only\r\n * considering nodes that are \"forced neighbors\" or corner points.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path (same as A*)\r\n * - Only works on uniform-cost grids (all edge weights equal)\r\n * - Exploits grid structure to skip intermediate nodes\r\n * - Typically 10-100x faster than A* in open spaces\r\n * - Falls back to A*-like behavior in dense obstacle environments\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n *\r\n * Note: This implementation is for 4-directional movement (cardinal only).\r\n * For 8-directional (with diagonals), the forced neighbor rules differ.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\ninterface JumpPointEntry {\r\n  row: number;\r\n  col: number;\r\n  dirRow: number;\r\n  dirCol: number;\r\n  fScore: number;\r\n}\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n */\r\nclass MinHeap {\r\n  private heap: JumpPointEntry[] = [];\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  private getKey(entry: JumpPointEntry): string {\r\n    return `${entry.row}-${entry.col}`;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  insert(entry: JumpPointEntry): void {\r\n    const key = this.getKey(entry);\r\n    if (this.positionMap.has(key)) {\r\n      const idx = this.positionMap.get(key)!;\r\n      if (entry.fScore < this.heap[idx].fScore) {\r\n        this.heap[idx] = entry;\r\n        this.bubbleUp(idx);\r\n        this.bubbleDown(idx);\r\n      }\r\n    } else {\r\n      this.heap.push(entry);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): JumpPointEntry | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const entry = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(entry));\r\n      return entry;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.positionMap.has(key);\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (this.heap[idx].fScore >= this.heap[parentIdx].fScore) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.heap[leftIdx].fScore < this.heap[smallest].fScore\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.heap[rightIdx].fScore < this.heap[smallest].fScore\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Jump Point Search Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Direction vectors for 4-directional movement\r\n * [row delta, col delta]\r\n */\r\nconst DIRECTIONS: [number, number][] = [\r\n  [-1, 0], // Up\r\n  [1, 0], // Down\r\n  [0, -1], // Left\r\n  [0, 1], // Right\r\n];\r\n\r\n/**\r\n * Performs Jump Point Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n */\r\nexport function jumpPointSearch(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Helper to get node key\r\n  const getKey = (row: number, col: number): string => `${row}-${col}`;\r\n\r\n  // Check if a position is valid and not a wall\r\n  const isWalkable = (row: number, col: number): boolean => {\r\n    if (row < 0 || row >= numRows || col < 0 || col >= numCols) return false;\r\n    return !grid[row][col].isWall;\r\n  };\r\n\r\n  // Use Maps to track scores (lazy initialization)\r\n  const gScore = new Map<string, number>();\r\n  const cameFrom = new Map<string, string | null>();\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode.row, startNode.col);\r\n  gScore.set(startKey, 0);\r\n  cameFrom.set(startKey, null);\r\n\r\n  // Min-heap priority queue\r\n  const openSet = new MinHeap();\r\n\r\n  // Add start node with all directions (no parent direction)\r\n  openSet.insert({\r\n    row: startNode.row,\r\n    col: startNode.col,\r\n    dirRow: 0,\r\n    dirCol: 0,\r\n    fScore: manhattanDistance(startNode, finishNode),\r\n  });\r\n\r\n  /**\r\n   * Jump function - the core of JPS (iterative to avoid stack overflow)\r\n   * Jumps in a direction until it finds:\r\n   * 1. The goal node\r\n   * 2. A jump point (forced neighbor exists)\r\n   * 3. A wall or boundary (returns null)\r\n   */\r\n  const jump = (\r\n    startRow: number,\r\n    startCol: number,\r\n    dirRow: number,\r\n    dirCol: number\r\n  ): { row: number; col: number } | null => {\r\n    let row = startRow + dirRow;\r\n    let col = startCol + dirCol;\r\n\r\n    while (true) {\r\n      // Hit wall or boundary\r\n      if (!isWalkable(row, col)) {\r\n        return null;\r\n      }\r\n\r\n      // Found the goal!\r\n      if (row === finishNode.row && col === finishNode.col) {\r\n        return { row, col };\r\n      }\r\n\r\n      // Check for forced neighbors (4-directional rules)\r\n      // Horizontal movement (dirRow === 0)\r\n      if (dirRow === 0) {\r\n        if (\r\n          (!isWalkable(row - 1, col - dirCol) && isWalkable(row - 1, col)) ||\r\n          (!isWalkable(row + 1, col - dirCol) && isWalkable(row + 1, col))\r\n        ) {\r\n          return { row, col };\r\n        }\r\n      }\r\n\r\n      // Vertical movement (dirCol === 0)\r\n      if (dirCol === 0) {\r\n        if (\r\n          (!isWalkable(row - dirRow, col - 1) && isWalkable(row, col - 1)) ||\r\n          (!isWalkable(row - dirRow, col + 1) && isWalkable(row, col + 1))\r\n        ) {\r\n          return { row, col };\r\n        }\r\n      }\r\n\r\n      // Continue jumping in the same direction\r\n      row += dirRow;\r\n      col += dirCol;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Identify successors (jump points) from a node\r\n   */\r\n  const identifySuccessors = (\r\n    row: number,\r\n    col: number,\r\n    parentDirRow: number,\r\n    parentDirCol: number\r\n  ): { row: number; col: number }[] => {\r\n    const successors: { row: number; col: number }[] = [];\r\n\r\n    // Determine which directions to explore based on parent direction\r\n    let directionsToCheck: [number, number][];\r\n\r\n    if (parentDirRow === 0 && parentDirCol === 0) {\r\n      // Start node - check all directions\r\n      directionsToCheck = DIRECTIONS;\r\n    } else if (parentDirRow === 0) {\r\n      // Horizontal movement - continue horizontal + check perpendicular if forced\r\n      directionsToCheck = [[0, parentDirCol]];\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - 1, col - parentDirCol) &&\r\n        isWalkable(row - 1, col)\r\n      ) {\r\n        directionsToCheck.push([-1, 0]);\r\n      }\r\n      if (\r\n        !isWalkable(row + 1, col - parentDirCol) &&\r\n        isWalkable(row + 1, col)\r\n      ) {\r\n        directionsToCheck.push([1, 0]);\r\n      }\r\n    } else {\r\n      // Vertical movement - continue vertical + check perpendicular if forced\r\n      directionsToCheck = [[parentDirRow, 0]];\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - parentDirRow, col - 1) &&\r\n        isWalkable(row, col - 1)\r\n      ) {\r\n        directionsToCheck.push([0, -1]);\r\n      }\r\n      if (\r\n        !isWalkable(row - parentDirRow, col + 1) &&\r\n        isWalkable(row, col + 1)\r\n      ) {\r\n        directionsToCheck.push([0, 1]);\r\n      }\r\n    }\r\n\r\n    // Jump in each valid direction\r\n    for (const [dRow, dCol] of directionsToCheck) {\r\n      const jumpPoint = jump(row, col, dRow, dCol);\r\n      if (jumpPoint) {\r\n        successors.push(jumpPoint);\r\n      }\r\n    }\r\n\r\n    return successors;\r\n  };\r\n\r\n  // Main loop\r\n  while (!openSet.isEmpty()) {\r\n    const current = openSet.extractMin()!;\r\n    const currentKey = getKey(current.row, current.col);\r\n    const currentNode = grid[current.row][current.col];\r\n\r\n    // Skip if already visited\r\n    if (currentNode.isVisited) continue;\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // Found the goal!\r\n    if (current.row === finishNode.row && current.col === finishNode.col) {\r\n      // Reconstruct path using previousNode pointers\r\n      reconstructPath(grid, cameFrom, finishNode);\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get successors (jump points)\r\n    const successors = identifySuccessors(\r\n      current.row,\r\n      current.col,\r\n      current.dirRow,\r\n      current.dirCol\r\n    );\r\n\r\n    for (const successor of successors) {\r\n      const successorKey = getKey(successor.row, successor.col);\r\n      const successorNode = grid[successor.row][successor.col];\r\n\r\n      if (successorNode.isVisited) continue;\r\n\r\n      // Calculate tentative gScore (actual distance, not just 1)\r\n      const tentativeGScore =\r\n        (gScore.get(currentKey) ?? Infinity) +\r\n        manhattanDistance(currentNode, successorNode);\r\n\r\n      if (tentativeGScore < (gScore.get(successorKey) ?? Infinity)) {\r\n        // Found a better path\r\n        cameFrom.set(successorKey, currentKey);\r\n        gScore.set(successorKey, tentativeGScore);\r\n\r\n        const fScoreValue =\r\n          tentativeGScore + manhattanDistance(successorNode, finishNode);\r\n\r\n        // Calculate direction from current to successor\r\n        const dirRow =\r\n          successor.row === current.row\r\n            ? 0\r\n            : successor.row > current.row\r\n            ? 1\r\n            : -1;\r\n        const dirCol =\r\n          successor.col === current.col\r\n            ? 0\r\n            : successor.col > current.col\r\n            ? 1\r\n            : -1;\r\n\r\n        openSet.insert({\r\n          row: successor.row,\r\n          col: successor.col,\r\n          dirRow,\r\n          dirCol,\r\n          fScore: fScoreValue,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Reconstructs the path by setting previousNode pointers\r\n * JPS jumps over nodes, so we need to fill in the gaps\r\n */\r\nfunction reconstructPath(\r\n  grid: Grid,\r\n  cameFrom: Map<string, string | null>,\r\n  finishNode: Node\r\n): void {\r\n  const path: Node[] = [];\r\n  let currentKey: string | null = `${finishNode.row}-${finishNode.col}`;\r\n\r\n  // Collect jump points from finish to start\r\n  const jumpPoints: Node[] = [];\r\n  while (currentKey !== null) {\r\n    const [row, col] = currentKey.split(\"-\").map(Number);\r\n    jumpPoints.unshift(grid[row][col]);\r\n    currentKey = cameFrom.get(currentKey) ?? null;\r\n  }\r\n\r\n  // Fill in intermediate nodes between jump points\r\n  for (let i = 0; i < jumpPoints.length - 1; i++) {\r\n    const from = jumpPoints[i];\r\n    const to = jumpPoints[i + 1];\r\n\r\n    // Add intermediate nodes\r\n    let currentRow = from.row;\r\n    let currentCol = from.col;\r\n\r\n    while (currentRow !== to.row || currentCol !== to.col) {\r\n      const node = grid[currentRow][currentCol];\r\n      if (path.length > 0) {\r\n        node.previousNode = path[path.length - 1];\r\n      }\r\n      path.push(node);\r\n\r\n      // Move towards target\r\n      if (currentRow < to.row) currentRow++;\r\n      else if (currentRow > to.row) currentRow--;\r\n      else if (currentCol < to.col) currentCol++;\r\n      else if (currentCol > to.col) currentCol--;\r\n    }\r\n  }\r\n\r\n  // Add the finish node\r\n  if (jumpPoints.length > 0) {\r\n    finishNode.previousNode = path.length > 0 ? path[path.length - 1] : null;\r\n    path.push(finishNode);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by Jump Point Search.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Recursive Division Maze Generation Algorithm\r\n * Phase C: Maze Generation\r\n *\r\n * This algorithm creates a maze by recursively dividing the grid into chambers\r\n * and adding walls with gaps to ensure a solvable path.\r\n *\r\n * Key Concepts:\r\n * - Start with empty grid (no walls)\r\n * - Recursively divide into smaller chambers\r\n * - Each division adds a wall with exactly one gap\r\n * - Orientation based on chamber dimensions (height > width = horizontal)\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Orientation enum for wall placement\r\n */\r\nenum Orientation {\r\n  HORIZONTAL = 'horizontal',\r\n  VERTICAL = 'vertical',\r\n}\r\n\r\n/**\r\n * Main function to generate a Recursive Division maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must not be overwritten)\r\n * @param finishNode - The finish node (must not be overwritten)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getRecursiveDivisionMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const wallsInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Start recursive division on the full grid (no border walls)\r\n  divide(\r\n    grid,\r\n    0, // startRow (full grid)\r\n    numRows - 1, // endRow (full grid)\r\n    0, // startCol (full grid)\r\n    numCols - 1, // endCol (full grid)\r\n    chooseOrientation(numRows, numCols),\r\n    wallsInOrder,\r\n    startNode,\r\n    finishNode\r\n  );\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Recursive division function\r\n * Divides a chamber by adding a wall with a gap\r\n */\r\nfunction divide(\r\n  grid: Grid,\r\n  startRow: number,\r\n  endRow: number,\r\n  startCol: number,\r\n  endCol: number,\r\n  orientation: Orientation,\r\n  wallsInOrder: Node[],\r\n  startNode: Node,\r\n  finishNode: Node\r\n): void {\r\n  // Calculate chamber dimensions\r\n  const height = endRow - startRow + 1;\r\n  const width = endCol - startCol + 1;\r\n\r\n  // Base case: chamber too small to divide\r\n  if (height < 3 || width < 3) {\r\n    return;\r\n  }\r\n\r\n  // Choose where to place the wall and the gap\r\n  if (orientation === Orientation.HORIZONTAL) {\r\n    // Horizontal wall - pick a row (must be even to align with passages)\r\n    const possibleRows = getEvenNumbers(startRow + 1, endRow - 1);\r\n    if (possibleRows.length === 0) return;\r\n\r\n    const wallRow = possibleRows[Math.floor(Math.random() * possibleRows.length)];\r\n\r\n    // Pick a gap position (must be odd to align with passages)\r\n    const possibleGaps = getOddNumbers(startCol, endCol);\r\n    if (possibleGaps.length === 0) return;\r\n\r\n    const gapCol = possibleGaps[Math.floor(Math.random() * possibleGaps.length)];\r\n\r\n    // Build the wall with a gap\r\n    for (let col = startCol; col <= endCol; col++) {\r\n      if (col === gapCol) continue; // Leave the gap\r\n      if (isStartOrFinish(wallRow, col, startNode, finishNode)) continue;\r\n\r\n      wallsInOrder.push(grid[wallRow][col]);\r\n    }\r\n\r\n    // Recursively divide the two new chambers\r\n    // Top chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      wallRow - 1,\r\n      startCol,\r\n      endCol,\r\n      chooseOrientation(wallRow - 1 - startRow + 1, width),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n\r\n    // Bottom chamber\r\n    divide(\r\n      grid,\r\n      wallRow + 1,\r\n      endRow,\r\n      startCol,\r\n      endCol,\r\n      chooseOrientation(endRow - (wallRow + 1) + 1, width),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  } else {\r\n    // Vertical wall - pick a column (must be even to align with passages)\r\n    const possibleCols = getEvenNumbers(startCol + 1, endCol - 1);\r\n    if (possibleCols.length === 0) return;\r\n\r\n    const wallCol = possibleCols[Math.floor(Math.random() * possibleCols.length)];\r\n\r\n    // Pick a gap position (must be odd to align with passages)\r\n    const possibleGaps = getOddNumbers(startRow, endRow);\r\n    if (possibleGaps.length === 0) return;\r\n\r\n    const gapRow = possibleGaps[Math.floor(Math.random() * possibleGaps.length)];\r\n\r\n    // Build the wall with a gap\r\n    for (let row = startRow; row <= endRow; row++) {\r\n      if (row === gapRow) continue; // Leave the gap\r\n      if (isStartOrFinish(row, wallCol, startNode, finishNode)) continue;\r\n\r\n      wallsInOrder.push(grid[row][wallCol]);\r\n    }\r\n\r\n    // Recursively divide the two new chambers\r\n    // Left chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      endRow,\r\n      startCol,\r\n      wallCol - 1,\r\n      chooseOrientation(height, wallCol - 1 - startCol + 1),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n\r\n    // Right chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      endRow,\r\n      wallCol + 1,\r\n      endCol,\r\n      chooseOrientation(height, endCol - (wallCol + 1) + 1),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Chooses wall orientation based on chamber dimensions\r\n * Prefers to divide along the longer axis\r\n */\r\nfunction chooseOrientation(height: number, width: number): Orientation {\r\n  if (height > width) {\r\n    return Orientation.HORIZONTAL;\r\n  } else if (width > height) {\r\n    return Orientation.VERTICAL;\r\n  } else {\r\n    // Square chamber - random choice\r\n    return Math.random() < 0.5 ? Orientation.HORIZONTAL : Orientation.VERTICAL;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets all even numbers in a range (inclusive)\r\n */\r\nfunction getEvenNumbers(start: number, end: number): number[] {\r\n  const result: number[] = [];\r\n  for (let i = start; i <= end; i++) {\r\n    if (i % 2 === 0) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Gets all odd numbers in a range (inclusive)\r\n */\r\nfunction getOddNumbers(start: number, end: number): number[] {\r\n  const result: number[] = [];\r\n  for (let i = start; i <= end; i++) {\r\n    if (i % 2 !== 0) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks if a position is the start or finish node\r\n */\r\nfunction isStartOrFinish(\r\n  row: number,\r\n  col: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean {\r\n  return (\r\n    (row === startNode.row && col === startNode.col) ||\r\n    (row === finishNode.row && col === finishNode.col)\r\n  );\r\n}\r\n\r\nexport default getRecursiveDivisionMaze;\r\n","/**\r\n * Randomized DFS (Recursive Backtracker) Maze Generation Algorithm\r\n * Phase C: Maze Generation\r\n *\r\n * This algorithm creates a maze by \"carving\" passages through a grid of walls.\r\n * It uses depth-first search with random neighbor selection to create\r\n * organic, winding passages with long corridors.\r\n *\r\n * Key Concepts:\r\n * - Start with a grid conceptually full of walls\r\n * - Carve passages using DFS with random neighbor order\r\n * - Each step moves 2 cells to leave room for walls between passages\r\n * - Results in a \"perfect maze\" (exactly one path between any two points)\r\n *\r\n * Time Complexity: O(V) where V = number of cells\r\n * Space Complexity: O(V) for visited grid and stack\r\n *\r\n * Output: Returns array of wall nodes for animation (inverse of carved passages)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Tracks which cells have been visited during maze generation\r\n * true = passage (carved), false = wall (uncarved)\r\n */\r\ntype VisitedGrid = boolean[][];\r\n\r\n/**\r\n * Main function to generate a Randomized DFS maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain accessible)\r\n * @param finishNode - The finish node (must remain accessible)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getRandomizedDFSMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Initialize visited grid - all false (all walls)\r\n  const visited: VisitedGrid = Array.from({ length: numRows }, () =>\r\n    Array(numCols).fill(false)\r\n  );\r\n\r\n  // Track the order of carved passages (for potential future use)\r\n  const passagesInOrder: Node[] = [];\r\n\r\n  // Start carving from position (0, 0) - full grid without border\r\n  const startRow = 0;\r\n  const startCol = 0;\r\n\r\n  // Carve the maze using iterative DFS (avoids stack overflow)\r\n  carveIterative(\r\n    grid,\r\n    startRow,\r\n    startCol,\r\n    numRows,\r\n    numCols,\r\n    visited,\r\n    passagesInOrder\r\n  );\r\n\r\n  // Ensure start and finish nodes are passages and connected to maze\r\n  ensureConnected(startNode, visited, numRows, numCols);\r\n  ensureConnected(finishNode, visited, numRows, numCols);\r\n\r\n  // Build the walls array - all non-passage cells become walls\r\n  const wallsInOrder: Node[] = [];\r\n\r\n  // Add all walls (cells that weren't carved as passages) - no border frame\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      if (!visited[row][col]) {\r\n        // This cell is a wall (not carved)\r\n        if (!isStartOrFinish(row, col, startNode, finishNode)) {\r\n          wallsInOrder.push(grid[row][col]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Iterative carving function using explicit stack (no recursion)\r\n * Carves passages by visiting cells 2 steps apart\r\n * This avoids stack overflow on large grids\r\n */\r\nfunction carveIterative(\r\n  grid: Grid,\r\n  startRow: number,\r\n  startCol: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  visited: VisitedGrid,\r\n  passagesInOrder: Node[]\r\n): void {\r\n  // Stack holds [row, col] positions to process\r\n  const stack: [number, number][] = [[startRow, startCol]];\r\n\r\n  // Mark starting cell as passage\r\n  visited[startRow][startCol] = true;\r\n  passagesInOrder.push(grid[startRow][startCol]);\r\n\r\n  while (stack.length > 0) {\r\n    const [row, col] = stack[stack.length - 1]; // Peek top\r\n\r\n    // Get unvisited neighbors 2 cells away\r\n    const neighbors = getUnvisitedNeighbors(\r\n      row,\r\n      col,\r\n      numRows,\r\n      numCols,\r\n      visited\r\n    );\r\n\r\n    if (neighbors.length === 0) {\r\n      // No unvisited neighbors - backtrack\r\n      stack.pop();\r\n    } else {\r\n      // Pick a random neighbor\r\n      const randomIndex = Math.floor(Math.random() * neighbors.length);\r\n      const [nextRow, nextCol] = neighbors[randomIndex];\r\n\r\n      // Carve the wall between current and neighbor\r\n      const wallRow = row + (nextRow - row) / 2;\r\n      const wallCol = col + (nextCol - col) / 2;\r\n      visited[wallRow][wallCol] = true;\r\n      passagesInOrder.push(grid[wallRow][wallCol]);\r\n\r\n      // Mark neighbor as visited and push to stack\r\n      visited[nextRow][nextCol] = true;\r\n      passagesInOrder.push(grid[nextRow][nextCol]);\r\n      stack.push([nextRow, nextCol]);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gets unvisited neighbors 2 cells away\r\n * Used to ensure walls remain between passages\r\n */\r\nfunction getUnvisitedNeighbors(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  visited: VisitedGrid\r\n): [number, number][] {\r\n  const neighbors: [number, number][] = [];\r\n\r\n  // Check 2 cells in each direction\r\n  const directions: [number, number][] = [\r\n    [-2, 0], // Up\r\n    [2, 0], // Down\r\n    [0, -2], // Left\r\n    [0, 2], // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = row + dRow;\r\n    const newCol = col + dCol;\r\n\r\n    // Check bounds (allow full grid edges)\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      if (!visited[newRow][newCol]) {\r\n        neighbors.push([newRow, newCol]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\n/**\r\n * Ensures a node is a passage and connected to the main maze\r\n * Uses BFS to find nearest passage and carves a path to it\r\n */\r\nfunction ensureConnected(\r\n  node: Node,\r\n  visited: VisitedGrid,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  // If already a passage, we're done\r\n  if (visited[node.row][node.col]) {\r\n    return;\r\n  }\r\n\r\n  // Mark the node itself as passage\r\n  visited[node.row][node.col] = true;\r\n\r\n  // BFS to find nearest existing passage\r\n  const bfsVisited = new Set<string>();\r\n  const queue: [number, number, [number, number][]][] = [\r\n    [node.row, node.col, []],\r\n  ];\r\n  bfsVisited.add(`${node.row}-${node.col}`);\r\n\r\n  const directions: [number, number][] = [\r\n    [-1, 0],\r\n    [1, 0],\r\n    [0, -1],\r\n    [0, 1],\r\n  ];\r\n\r\n  while (queue.length > 0) {\r\n    // Use index-based dequeue to avoid O(n) shift\r\n    const [row, col, path] = queue.shift()!;\r\n\r\n    // Check if this cell is part of the main maze (already a passage)\r\n    if (visited[row][col] && path.length > 0) {\r\n      // Carve the path to connect to the maze\r\n      for (const [pRow, pCol] of path) {\r\n        visited[pRow][pCol] = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Explore neighbors\r\n    for (const [dRow, dCol] of directions) {\r\n      const newRow = row + dRow;\r\n      const newCol = col + dCol;\r\n      const key = `${newRow}-${newCol}`;\r\n\r\n      if (\r\n        newRow >= 0 &&\r\n        newRow < numRows &&\r\n        newCol >= 0 &&\r\n        newCol < numCols &&\r\n        !bfsVisited.has(key)\r\n      ) {\r\n        bfsVisited.add(key);\r\n        queue.push([newRow, newCol, [...path, [newRow, newCol]]]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a position is the start or finish node\r\n */\r\nfunction isStartOrFinish(\r\n  row: number,\r\n  col: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean {\r\n  return (\r\n    (row === startNode.row && col === startNode.col) ||\r\n    (row === finishNode.row && col === finishNode.col)\r\n  );\r\n}\r\n\r\nexport default getRandomizedDFSMaze;\r\n","/**\r\n * Prim's Maze Generation Algorithm (Randomized)\r\n * Phase F: Extensions & History\r\n *\r\n * Creates a maze using a randomized version of Prim's minimum spanning tree algorithm.\r\n * Unlike Recursive Division (which starts empty and adds walls), Prim's starts with\r\n * ALL walls and carves passages.\r\n *\r\n * Key Characteristics:\r\n * - Produces \"organic\" looking mazes with many dead ends\r\n * - Different feel from Recursive Division (more cave-like, less structured)\r\n * - Guaranteed to create a perfect maze (exactly one path between any two cells)\r\n *\r\n * Algorithm (Randomized Prim's):\r\n * 1. Start with a grid full of walls\r\n * 2. Pick a starting cell, mark it as a passage\r\n * 3. Add its wall neighbors to a \"frontier\" list\r\n * 4. While frontier is not empty:\r\n *    a. Pick a random cell from the frontier\r\n *    b. Find its neighbors that are already passages\r\n *    c. Connect to ONE random passage neighbor (carve the wall between them)\r\n *    d. Mark the frontier cell as a passage\r\n *    e. Add the frontier cell's wall neighbors to the frontier\r\n * 5. Ensure start and finish nodes are passages\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Main function to generate a Prim's maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain open)\r\n * @param finishNode - The finish node (must remain open)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getPrimsMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Create a passage map: true = passage, false = wall\r\n  // We'll use this to track the maze state during generation\r\n  const isPassage: boolean[][] = Array.from({ length: numRows }, () =>\r\n    Array(numCols).fill(false)\r\n  );\r\n\r\n  // Set to track cells in frontier\r\n  const inFrontier = new Set<string>();\r\n\r\n  // Frontier list - cells to potentially become passages\r\n  const frontier: [number, number][] = [];\r\n\r\n  // Helper to get cell key\r\n  const getKey = (row: number, col: number): string => `${row}-${col}`;\r\n\r\n  // Start position - use a cell near the start node\r\n  // Using odd coordinates ensures proper maze structure\r\n  const startRow = Math.max(1, Math.min(numRows - 2, startNode.row | 1)); // Ensure odd\r\n  const startCol = Math.max(1, Math.min(numCols - 2, startNode.col | 1)); // Ensure odd\r\n\r\n  // Mark starting cell as passage\r\n  isPassage[startRow][startCol] = true;\r\n\r\n  // Add initial frontier cells (neighbors 2 steps away, within bounds)\r\n  addFrontier(\r\n    startRow,\r\n    startCol,\r\n    numRows,\r\n    numCols,\r\n    isPassage,\r\n    frontier,\r\n    inFrontier\r\n  );\r\n\r\n  // Main loop - process frontier cells\r\n  while (frontier.length > 0) {\r\n    // Pick a random cell from the frontier\r\n    const randomIndex = Math.floor(Math.random() * frontier.length);\r\n    const [row, col] = frontier[randomIndex];\r\n\r\n    // Remove from frontier\r\n    frontier.splice(randomIndex, 1);\r\n    inFrontier.delete(getKey(row, col));\r\n\r\n    // Skip if already a passage (can happen due to multiple additions)\r\n    if (isPassage[row][col]) {\r\n      continue;\r\n    }\r\n\r\n    // Find passage neighbors (cells 2 steps away that are passages)\r\n    const passageNeighbors = getPassageNeighbors(\r\n      row,\r\n      col,\r\n      numRows,\r\n      numCols,\r\n      isPassage\r\n    );\r\n\r\n    if (passageNeighbors.length > 0) {\r\n      // Pick a random passage neighbor to connect to\r\n      const [neighborRow, neighborCol] =\r\n        passageNeighbors[Math.floor(Math.random() * passageNeighbors.length)];\r\n\r\n      // Carve passage: mark current cell as passage\r\n      isPassage[row][col] = true;\r\n\r\n      // Carve the wall between current cell and the passage neighbor\r\n      const wallRow = (row + neighborRow) / 2;\r\n      const wallCol = (col + neighborCol) / 2;\r\n      isPassage[wallRow][wallCol] = true;\r\n\r\n      // Add new frontier cells from this newly opened cell\r\n      addFrontier(row, col, numRows, numCols, isPassage, frontier, inFrontier);\r\n    }\r\n  }\r\n\r\n  // Ensure start and finish nodes are passages\r\n  ensureNodeIsPassage(startNode, isPassage, numRows, numCols);\r\n  ensureNodeIsPassage(finishNode, isPassage, numRows, numCols);\r\n\r\n  // Ensure path from start to nearest passage\r\n  connectToNearestPassage(\r\n    startNode.row,\r\n    startNode.col,\r\n    isPassage,\r\n    numRows,\r\n    numCols\r\n  );\r\n  connectToNearestPassage(\r\n    finishNode.row,\r\n    finishNode.col,\r\n    isPassage,\r\n    numRows,\r\n    numCols\r\n  );\r\n\r\n  // Convert passage map to walls list for animation\r\n  // Walls are cells where isPassage is false\r\n  const wallsInOrder: Node[] = [];\r\n\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      // Skip start and finish nodes\r\n      if (\r\n        (row === startNode.row && col === startNode.col) ||\r\n        (row === finishNode.row && col === finishNode.col)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // If it's a wall (not a passage), add to walls list\r\n      if (!isPassage[row][col]) {\r\n        wallsInOrder.push(grid[row][col]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shuffle walls for more interesting animation\r\n  shuffleArray(wallsInOrder);\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Adds frontier cells from a given position\r\n * Frontier cells are walls 2 steps away (in cardinal directions)\r\n */\r\nfunction addFrontier(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  isPassage: boolean[][],\r\n  frontier: [number, number][],\r\n  inFrontier: Set<string>\r\n): void {\r\n  const directions = [\r\n    [-2, 0], // Up\r\n    [2, 0], // Down\r\n    [0, -2], // Left\r\n    [0, 2], // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = row + dRow;\r\n    const newCol = col + dCol;\r\n\r\n    // Check bounds (leave 1 cell border)\r\n    if (\r\n      newRow >= 1 &&\r\n      newRow < numRows - 1 &&\r\n      newCol >= 1 &&\r\n      newCol < numCols - 1\r\n    ) {\r\n      const key = `${newRow}-${newCol}`;\r\n\r\n      // Add to frontier if it's a wall and not already in frontier\r\n      if (!isPassage[newRow][newCol] && !inFrontier.has(key)) {\r\n        frontier.push([newRow, newCol]);\r\n        inFrontier.add(key);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gets passage neighbors (cells 2 steps away that are passages)\r\n */\r\nfunction getPassageNeighbors(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  isPassage: boolean[][]\r\n): [number, number][] {\r\n  const neighbors: [number, number][] = [];\r\n  const directions = [\r\n    [-2, 0], // Up\r\n    [2, 0], // Down\r\n    [0, -2], // Left\r\n    [0, 2], // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = row + dRow;\r\n    const newCol = col + dCol;\r\n\r\n    // Check bounds\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      if (isPassage[newRow][newCol]) {\r\n        neighbors.push([newRow, newCol]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\n/**\r\n * Ensures a specific node is marked as a passage\r\n */\r\nfunction ensureNodeIsPassage(\r\n  node: Node,\r\n  isPassage: boolean[][],\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  if (\r\n    node.row >= 0 &&\r\n    node.row < numRows &&\r\n    node.col >= 0 &&\r\n    node.col < numCols\r\n  ) {\r\n    isPassage[node.row][node.col] = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Connects a cell to the nearest passage by carving a path\r\n */\r\nfunction connectToNearestPassage(\r\n  startRow: number,\r\n  startCol: number,\r\n  isPassage: boolean[][],\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  // BFS to find nearest passage\r\n  const visited = new Set<string>();\r\n  const queue: [number, number, [number, number][]][] = [\r\n    [startRow, startCol, []],\r\n  ];\r\n  visited.add(`${startRow}-${startCol}`);\r\n\r\n  const directions = [\r\n    [-1, 0], // Up\r\n    [1, 0], // Down\r\n    [0, -1], // Left\r\n    [0, 1], // Right\r\n  ];\r\n\r\n  while (queue.length > 0) {\r\n    const [row, col, path] = queue.shift()!;\r\n\r\n    // Found a passage - carve the path to it\r\n    if (isPassage[row][col] && path.length > 0) {\r\n      for (const [pRow, pCol] of path) {\r\n        isPassage[pRow][pCol] = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Explore neighbors\r\n    for (const [dRow, dCol] of directions) {\r\n      const newRow = row + dRow;\r\n      const newCol = col + dCol;\r\n      const key = `${newRow}-${newCol}`;\r\n\r\n      if (\r\n        newRow >= 0 &&\r\n        newRow < numRows &&\r\n        newCol >= 0 &&\r\n        newCol < numCols &&\r\n        !visited.has(key)\r\n      ) {\r\n        visited.add(key);\r\n        queue.push([newRow, newCol, [...path, [newRow, newCol]]]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Fisher-Yates shuffle for random wall animation order\r\n */\r\nfunction shuffleArray<T>(array: T[]): void {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n}\r\n","/**\r\n * Spiral Maze Generation Algorithm\r\n * Phase F: Extensions & History\r\n *\r\n * Creates a maze with walls arranged in a spiral pattern from outside to inside.\r\n * The spiral creates a long winding path that forces traversal through the entire\r\n * maze structure.\r\n *\r\n * Key Characteristics:\r\n * - Visually distinctive spiral pattern\r\n * - Creates a deterministic, predictable maze shape\r\n * - Gaps at each ring transition allow entering inner layers\r\n * - Great for demonstrating how algorithms handle long paths\r\n *\r\n * Algorithm:\r\n * 1. Start from the outermost ring of the grid\r\n * 2. Add walls along each side of the ring (top, right, bottom, left)\r\n * 3. Leave a gap for passage to the inner ring\r\n * 4. Move to the next inner ring and repeat\r\n * 5. Continue until center is reached\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Direction enum for spiral traversal\r\n */\r\nenum Direction {\r\n  RIGHT = 0,\r\n  DOWN = 1,\r\n  LEFT = 2,\r\n  UP = 3,\r\n}\r\n\r\n/**\r\n * Main function to generate a spiral maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain open)\r\n * @param finishNode - The finish node (must remain open)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getSpiralMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const wallsInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Set to track which cells should NOT become walls\r\n  const protectedCells = new Set<string>();\r\n  protectedCells.add(`${startNode.row}-${startNode.col}`);\r\n  protectedCells.add(`${finishNode.row}-${finishNode.col}`);\r\n\r\n  // Also protect adjacent cells to start/finish to ensure accessibility\r\n  protectAdjacentCells(\r\n    startNode.row,\r\n    startNode.col,\r\n    numRows,\r\n    numCols,\r\n    protectedCells\r\n  );\r\n  protectAdjacentCells(\r\n    finishNode.row,\r\n    finishNode.col,\r\n    numRows,\r\n    numCols,\r\n    protectedCells\r\n  );\r\n\r\n  /**\r\n   * Helper to check if a cell can become a wall\r\n   */\r\n  const canBeWall = (row: number, col: number): boolean => {\r\n    // Check bounds\r\n    if (row < 0 || row >= numRows || col < 0 || col >= numCols) return false;\r\n    // Check if protected\r\n    if (protectedCells.has(`${row}-${col}`)) return false;\r\n    // Check if it's start or finish\r\n    if (grid[row][col].isStart || grid[row][col].isFinish) return false;\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Add a wall if valid\r\n   */\r\n  const addWall = (row: number, col: number): void => {\r\n    if (canBeWall(row, col)) {\r\n      wallsInOrder.push(grid[row][col]);\r\n    }\r\n  };\r\n\r\n  // Step 1: Add outer border walls (to prevent edge shortcuts)\r\n  // Top border\r\n  for (let col = 0; col < numCols; col++) {\r\n    addWall(0, col);\r\n  }\r\n  // Bottom border\r\n  for (let col = 0; col < numCols; col++) {\r\n    addWall(numRows - 1, col);\r\n  }\r\n  // Left border\r\n  for (let row = 1; row < numRows - 1; row++) {\r\n    addWall(row, 0);\r\n  }\r\n  // Right border\r\n  for (let row = 1; row < numRows - 1; row++) {\r\n    addWall(row, numCols - 1);\r\n  }\r\n\r\n  // Step 2: Generate spiral walls from outside to inside\r\n  // Each \"ring\" is a rectangular frame of walls with a gap to enter\r\n  let top = 2;\r\n  let bottom = numRows - 3;\r\n  let left = 2;\r\n  let right = numCols - 3;\r\n  let ringCount = 0;\r\n\r\n  while (top < bottom - 1 && left < right - 1) {\r\n    // Calculate gap position - alternate sides for each ring to create winding path\r\n    // Gap rotates: top -> right -> bottom -> left\r\n    const gapSide = ringCount % 4;\r\n\r\n    // Top wall (left to right) with gap\r\n    for (let col = left; col <= right; col++) {\r\n      const isGap = gapSide === 0 && col === Math.floor((left + right) / 2);\r\n      if (!isGap) {\r\n        addWall(top, col);\r\n      }\r\n    }\r\n\r\n    // Right wall (top+1 to bottom) with gap\r\n    for (let row = top + 1; row <= bottom; row++) {\r\n      const isGap = gapSide === 1 && row === Math.floor((top + bottom) / 2);\r\n      if (!isGap) {\r\n        addWall(row, right);\r\n      }\r\n    }\r\n\r\n    // Bottom wall (right-1 to left) with gap\r\n    for (let col = right - 1; col >= left; col--) {\r\n      const isGap = gapSide === 2 && col === Math.floor((left + right) / 2);\r\n      if (!isGap) {\r\n        addWall(bottom, col);\r\n      }\r\n    }\r\n\r\n    // Left wall (bottom-1 to top+1) with gap - this is the entrance to next ring\r\n    for (let row = bottom - 1; row > top; row--) {\r\n      const isGap = gapSide === 3 && row === Math.floor((top + bottom) / 2);\r\n      if (!isGap) {\r\n        addWall(row, left);\r\n      }\r\n    }\r\n\r\n    // Move to inner ring\r\n    top += 2;\r\n    bottom -= 2;\r\n    left += 2;\r\n    right -= 2;\r\n    ringCount++;\r\n  }\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Protect cells adjacent to start/finish to ensure they're accessible\r\n */\r\nfunction protectAdjacentCells(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  protectedCells: Set<string>\r\n): void {\r\n  const directions = [\r\n    [-1, 0], // Up\r\n    [1, 0], // Down\r\n    [0, -1], // Left\r\n    [0, 1], // Right\r\n  ];\r\n\r\n  for (const [dr, dc] of directions) {\r\n    const newRow = row + dr;\r\n    const newCol = col + dc;\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      protectedCells.add(`${newRow}-${newCol}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Alternative spiral pattern: Clockwise inward spiral path\r\n * Creates walls everywhere EXCEPT the spiral path\r\n */\r\nexport function getSpiralPathMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const wallsInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Track which cells are part of the spiral path\r\n  const isPath = new Set<string>();\r\n\r\n  // Start position (near top-left corner)\r\n  let row = 1;\r\n  let col = 1;\r\n  let direction: Direction = Direction.RIGHT;\r\n\r\n  // Boundaries for spiral\r\n  let minRow = 1;\r\n  let maxRow = numRows - 2;\r\n  let minCol = 1;\r\n  let maxCol = numCols - 2;\r\n\r\n  // Carve spiral path\r\n  while (minRow <= maxRow && minCol <= maxCol) {\r\n    // Move in current direction until hitting boundary\r\n    switch (direction) {\r\n      case Direction.RIGHT:\r\n        while (col <= maxCol) {\r\n          isPath.add(`${row}-${col}`);\r\n          col++;\r\n        }\r\n        col--;\r\n        minRow++;\r\n        break;\r\n\r\n      case Direction.DOWN:\r\n        while (row <= maxRow) {\r\n          isPath.add(`${row}-${col}`);\r\n          row++;\r\n        }\r\n        row--;\r\n        maxCol--;\r\n        break;\r\n\r\n      case Direction.LEFT:\r\n        while (col >= minCol) {\r\n          isPath.add(`${row}-${col}`);\r\n          col--;\r\n        }\r\n        col++;\r\n        maxRow--;\r\n        break;\r\n\r\n      case Direction.UP:\r\n        while (row >= minRow) {\r\n          isPath.add(`${row}-${col}`);\r\n          row--;\r\n        }\r\n        row++;\r\n        minCol++;\r\n        break;\r\n    }\r\n\r\n    // Turn clockwise\r\n    direction = (direction + 1) % 4;\r\n  }\r\n\r\n  // Connect start and finish to the spiral path\r\n  connectToPath(startNode.row, startNode.col, isPath, numRows, numCols);\r\n  connectToPath(finishNode.row, finishNode.col, isPath, numRows, numCols);\r\n\r\n  // Add walls for all non-path cells\r\n  for (let r = 0; r < numRows; r++) {\r\n    for (let c = 0; c < numCols; c++) {\r\n      if (!isPath.has(`${r}-${c}`)) {\r\n        const node = grid[r][c];\r\n        if (!node.isStart && !node.isFinish) {\r\n          wallsInOrder.push(node);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shuffle walls for more interesting animation\r\n  shuffleArray(wallsInOrder);\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Connects a cell to the nearest point on the existing path using BFS\r\n * Carves a passage from the cell to the path\r\n */\r\nfunction connectToPath(\r\n  startRow: number,\r\n  startCol: number,\r\n  isPath: Set<string>,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  const startKey = `${startRow}-${startCol}`;\r\n\r\n  // If already on the path, nothing to do\r\n  if (isPath.has(startKey)) {\r\n    return;\r\n  }\r\n\r\n  // BFS to find nearest path cell\r\n  const visited = new Set<string>();\r\n  const parent = new Map<string, string | null>();\r\n\r\n  // Queue: [row, col]\r\n  const queue: [number, number][] = [[startRow, startCol]];\r\n  visited.add(startKey);\r\n  parent.set(startKey, null);\r\n\r\n  const directions = [\r\n    [-1, 0],\r\n    [1, 0],\r\n    [0, -1],\r\n    [0, 1],\r\n  ];\r\n\r\n  let foundKey: string | null = null;\r\n\r\n  while (queue.length > 0) {\r\n    const [r, c] = queue.shift()!;\r\n    const currentKey = `${r}-${c}`;\r\n\r\n    // Found the path - stop searching\r\n    if (isPath.has(currentKey) && currentKey !== startKey) {\r\n      foundKey = currentKey;\r\n      break;\r\n    }\r\n\r\n    // Explore neighbors\r\n    for (const [dr, dc] of directions) {\r\n      const newRow = r + dr;\r\n      const newCol = c + dc;\r\n      const newKey = `${newRow}-${newCol}`;\r\n\r\n      if (\r\n        newRow >= 0 &&\r\n        newRow < numRows &&\r\n        newCol >= 0 &&\r\n        newCol < numCols &&\r\n        !visited.has(newKey)\r\n      ) {\r\n        visited.add(newKey);\r\n        parent.set(newKey, currentKey);\r\n        queue.push([newRow, newCol]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Carve the path from start to the found path cell\r\n  if (foundKey !== null) {\r\n    let currentKey: string | null = foundKey;\r\n    while (currentKey !== null) {\r\n      isPath.add(currentKey);\r\n      currentKey = parent.get(currentKey) ?? null;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Fisher-Yates shuffle algorithm\r\n */\r\nfunction shuffleArray<T>(array: T[]): void {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n}\r\n","/**\r\n * Cellular Automata Maze Generation Algorithm\r\n * Phase F: Extensions & History\r\n *\r\n * Creates a maze using cellular automata rules inspired by Conway's Game of Life.\r\n * This produces organic, cave-like patterns that differ from traditional maze algorithms.\r\n *\r\n * Key Characteristics:\r\n * - Creates natural-looking cave systems\r\n * - Non-deterministic (random initial state + rules = unique mazes)\r\n * - May create isolated regions (not guaranteed solvable without post-processing)\r\n * - Smooth, organic wall patterns unlike grid-based mazes\r\n *\r\n * Algorithm:\r\n * 1. Initialize grid with random walls (configurable density)\r\n * 2. Apply cellular automata rules for several generations:\r\n *    - Birth: Empty cell becomes wall if it has >= birthLimit wall neighbors\r\n *    - Death: Wall cell becomes empty if it has < deathLimit wall neighbors\r\n * 3. Ensure start and finish nodes are clear\r\n * 4. Ensure a path exists between start and finish (flood fill + carve if needed)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Configuration for the cellular automata\r\n */\r\ninterface CellularAutomataConfig {\r\n  initialWallChance: number; // 0.0 to 1.0 - probability of initial wall\r\n  birthLimit: number; // Neighbors needed for empty cell to become wall\r\n  deathLimit: number; // Neighbors needed for wall cell to stay wall\r\n  generations: number; // Number of simulation steps\r\n}\r\n\r\n/**\r\n * Default configuration - produces good cave-like mazes\r\n * Tuned for 4-directional pathfinding grids\r\n */\r\nconst DEFAULT_CONFIG: CellularAutomataConfig = {\r\n  initialWallChance: 0.4, // 40% initial walls (reduced for more open caves)\r\n  birthLimit: 4, // Empty becomes wall if >= 5 wall neighbors (harder to create walls)\r\n  deathLimit: 4, // Wall dies if < 4 wall neighbors (easier to remove walls)\r\n  generations: 1, // 1 simulation step (fewer to preserve openness)\r\n};\r\n\r\n/**\r\n * Main function to generate a Cellular Automata maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain open)\r\n * @param finishNode - The finish node (must remain open)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getCellularAutomataMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n  const config = DEFAULT_CONFIG;\r\n\r\n  // Create a 2D array to track wall state (true = wall)\r\n  let wallState: boolean[][] = initializeRandomWalls(\r\n    numRows,\r\n    numCols,\r\n    config.initialWallChance,\r\n    startNode,\r\n    finishNode\r\n  );\r\n\r\n  // Run cellular automata simulation\r\n  for (let gen = 0; gen < config.generations; gen++) {\r\n    wallState = simulateGeneration(\r\n      wallState,\r\n      numRows,\r\n      numCols,\r\n      config.birthLimit,\r\n      config.deathLimit\r\n    );\r\n  }\r\n\r\n  // Ensure start and finish are clear along with their neighbors\r\n  clearAroundNode(wallState, startNode.row, startNode.col, numRows, numCols);\r\n  clearAroundNode(wallState, finishNode.row, finishNode.col, numRows, numCols);\r\n\r\n  // Ensure path exists between start and finish\r\n  ensurePathExists(\r\n    wallState,\r\n    startNode.row,\r\n    startNode.col,\r\n    finishNode.row,\r\n    finishNode.col,\r\n    numRows,\r\n    numCols\r\n  );\r\n\r\n  // Keep border walls for nice appearance\r\n  addBorderWalls(wallState, numRows, numCols, startNode, finishNode);\r\n\r\n  // Convert wall state to Node array for animation\r\n  const wallsInOrder: Node[] = [];\r\n\r\n  // Collect walls in a visually interesting order (spiral from outside in)\r\n  const visited = new Set<string>();\r\n  const getKey = (r: number, c: number) => `${r}-${c}`;\r\n\r\n  // Add walls layer by layer from outside\r\n  for (let layer = 0; layer < Math.max(numRows, numCols) / 2; layer++) {\r\n    // Top row of this layer\r\n    for (let c = layer; c < numCols - layer; c++) {\r\n      const r = layer;\r\n      if (r < numRows && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n    // Right column\r\n    for (let r = layer + 1; r < numRows - layer; r++) {\r\n      const c = numCols - 1 - layer;\r\n      if (c >= 0 && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n    // Bottom row\r\n    for (let c = numCols - 2 - layer; c >= layer; c--) {\r\n      const r = numRows - 1 - layer;\r\n      if (r >= 0 && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n    // Left column\r\n    for (let r = numRows - 2 - layer; r > layer; r--) {\r\n      const c = layer;\r\n      if (c < numCols && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Initialize grid with random walls\r\n */\r\nfunction initializeRandomWalls(\r\n  numRows: number,\r\n  numCols: number,\r\n  wallChance: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean[][] {\r\n  const walls: boolean[][] = [];\r\n\r\n  for (let r = 0; r < numRows; r++) {\r\n    const row: boolean[] = [];\r\n    for (let c = 0; c < numCols; c++) {\r\n      // Never place walls on start/finish\r\n      if (\r\n        (r === startNode.row && c === startNode.col) ||\r\n        (r === finishNode.row && c === finishNode.col)\r\n      ) {\r\n        row.push(false);\r\n      } else {\r\n        row.push(Math.random() < wallChance);\r\n      }\r\n    }\r\n    walls.push(row);\r\n  }\r\n\r\n  return walls;\r\n}\r\n\r\n/**\r\n * Simulate one generation of cellular automata\r\n */\r\nfunction simulateGeneration(\r\n  currentState: boolean[][],\r\n  numRows: number,\r\n  numCols: number,\r\n  birthLimit: number,\r\n  deathLimit: number\r\n): boolean[][] {\r\n  const newState: boolean[][] = [];\r\n\r\n  for (let r = 0; r < numRows; r++) {\r\n    const row: boolean[] = [];\r\n    for (let c = 0; c < numCols; c++) {\r\n      const wallNeighbors = countWallNeighbors(\r\n        currentState,\r\n        r,\r\n        c,\r\n        numRows,\r\n        numCols\r\n      );\r\n\r\n      if (currentState[r][c]) {\r\n        // Cell is currently a wall\r\n        // It survives if it has enough wall neighbors\r\n        row.push(wallNeighbors >= deathLimit);\r\n      } else {\r\n        // Cell is currently empty\r\n        // It becomes a wall if it has enough wall neighbors\r\n        row.push(wallNeighbors >= birthLimit);\r\n      }\r\n    }\r\n    newState.push(row);\r\n  }\r\n\r\n  return newState;\r\n}\r\n\r\n/**\r\n * Count wall neighbors (8-directional including diagonals)\r\n */\r\nfunction countWallNeighbors(\r\n  state: boolean[][],\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number\r\n): number {\r\n  let count = 0;\r\n\r\n  for (let dr = -1; dr <= 1; dr++) {\r\n    for (let dc = -1; dc <= 1; dc++) {\r\n      if (dr === 0 && dc === 0) continue; // Skip self\r\n\r\n      const nr = row + dr;\r\n      const nc = col + dc;\r\n\r\n      // Out-of-bounds counts as empty (prevents border from filling everything)\r\n      if (nr < 0 || nr >= numRows || nc < 0 || nc >= numCols) {\r\n        // Don't count out-of-bounds as walls\r\n        continue;\r\n      } else if (state[nr][nc]) {\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\n/**\r\n * Clear cells around a node (ensure it's accessible)\r\n */\r\nfunction clearAroundNode(\r\n  state: boolean[][],\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  // Clear the node itself and its 4-directional neighbors\r\n  state[row][col] = false;\r\n\r\n  const directions = [\r\n    [-1, 0],\r\n    [1, 0],\r\n    [0, -1],\r\n    [0, 1],\r\n  ];\r\n\r\n  for (const [dr, dc] of directions) {\r\n    const nr = row + dr;\r\n    const nc = col + dc;\r\n    if (nr >= 0 && nr < numRows && nc >= 0 && nc < numCols) {\r\n      state[nr][nc] = false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure a path exists between start and finish using flood fill\r\n * If no path exists, carve a winding path\r\n */\r\nfunction ensurePathExists(\r\n  state: boolean[][],\r\n  startRow: number,\r\n  startCol: number,\r\n  finishRow: number,\r\n  finishCol: number,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  // Flood fill from start to find all reachable cells\r\n  const reachable = new Set<string>();\r\n  const getKey = (r: number, c: number) => `${r}-${c}`;\r\n\r\n  const queue: [number, number][] = [[startRow, startCol]];\r\n  reachable.add(getKey(startRow, startCol));\r\n\r\n  while (queue.length > 0) {\r\n    const [r, c] = queue.shift()!;\r\n\r\n    const directions = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, -1],\r\n      [0, 1],\r\n    ];\r\n\r\n    for (const [dr, dc] of directions) {\r\n      const nr = r + dr;\r\n      const nc = c + dc;\r\n      const key = getKey(nr, nc);\r\n\r\n      if (\r\n        nr >= 0 &&\r\n        nr < numRows &&\r\n        nc >= 0 &&\r\n        nc < numCols &&\r\n        !state[nr][nc] &&\r\n        !reachable.has(key)\r\n      ) {\r\n        reachable.add(key);\r\n        queue.push([nr, nc]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check if finish is reachable\r\n  if (reachable.has(getKey(finishRow, finishCol))) {\r\n    return; // Path exists!\r\n  }\r\n\r\n  // No path exists - carve a winding path with some randomness\r\n  carveWindingPath(\r\n    state,\r\n    startRow,\r\n    startCol,\r\n    finishRow,\r\n    finishCol,\r\n    numRows,\r\n    numCols\r\n  );\r\n}\r\n\r\n/**\r\n * Carve a winding path between two points (more organic than straight line)\r\n */\r\nfunction carveWindingPath(\r\n  state: boolean[][],\r\n  startRow: number,\r\n  startCol: number,\r\n  endRow: number,\r\n  endCol: number,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  let r = startRow;\r\n  let c = startCol;\r\n\r\n  // Clear starting area\r\n  state[r][c] = false;\r\n\r\n  while (r !== endRow || c !== endCol) {\r\n    // Clear current cell and some neighbors for wider passages\r\n    state[r][c] = false;\r\n\r\n    // Randomly widen the path occasionally\r\n    if (Math.random() < 0.3) {\r\n      const directions = [\r\n        [-1, 0],\r\n        [1, 0],\r\n        [0, -1],\r\n        [0, 1],\r\n      ];\r\n      const [dr, dc] =\r\n        directions[Math.floor(Math.random() * directions.length)];\r\n      const nr = r + dr;\r\n      const nc = c + dc;\r\n      if (nr > 0 && nr < numRows - 1 && nc > 0 && nc < numCols - 1) {\r\n        state[nr][nc] = false;\r\n      }\r\n    }\r\n\r\n    // Decide direction with some randomness\r\n    const moveVertical = Math.random() < 0.5;\r\n\r\n    if (moveVertical && r !== endRow) {\r\n      r += r < endRow ? 1 : -1;\r\n    } else if (c !== endCol) {\r\n      c += c < endCol ? 1 : -1;\r\n    } else if (r !== endRow) {\r\n      r += r < endRow ? 1 : -1;\r\n    }\r\n  }\r\n\r\n  // Clear the end point and area around it\r\n  state[endRow][endCol] = false;\r\n}\r\n\r\n/**\r\n * Add border walls for a clean look\r\n */\r\nfunction addBorderWalls(\r\n  state: boolean[][],\r\n  numRows: number,\r\n  numCols: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): void {\r\n  // Top and bottom borders\r\n  for (let c = 0; c < numCols; c++) {\r\n    if (\r\n      !(startNode.row === 0 && startNode.col === c) &&\r\n      !(finishNode.row === 0 && finishNode.col === c)\r\n    ) {\r\n      state[0][c] = true;\r\n    }\r\n    if (\r\n      !(startNode.row === numRows - 1 && startNode.col === c) &&\r\n      !(finishNode.row === numRows - 1 && finishNode.col === c)\r\n    ) {\r\n      state[numRows - 1][c] = true;\r\n    }\r\n  }\r\n\r\n  // Left and right borders\r\n  for (let r = 0; r < numRows; r++) {\r\n    if (\r\n      !(startNode.row === r && startNode.col === 0) &&\r\n      !(finishNode.row === r && finishNode.col === 0)\r\n    ) {\r\n      state[r][0] = true;\r\n    }\r\n    if (\r\n      !(startNode.row === r && startNode.col === numCols - 1) &&\r\n      !(finishNode.row === r && finishNode.col === numCols - 1)\r\n    ) {\r\n      state[r][numCols - 1] = true;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Perlin Noise Implementation\r\n * Phase G: Weighted Terrain Generation\r\n *\r\n * A pure TypeScript implementation of 2D Perlin Noise for terrain generation.\r\n * No external dependencies - implements the algorithm directly.\r\n *\r\n * Based on Ken Perlin's improved noise algorithm (2002).\r\n *\r\n * Usage:\r\n *   const value = noise(x, y);  // Returns 0.0 to 1.0\r\n */\r\n\r\n// ============================================================================\r\n// Permutation Table\r\n// ============================================================================\r\n\r\n/**\r\n * Standard permutation table used in Perlin noise.\r\n * This is a shuffled array of 0-255, doubled for wrapping.\r\n */\r\nconst PERMUTATION: number[] = [\r\n  151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,\r\n  36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234,\r\n  75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237,\r\n  149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\r\n  27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105,\r\n  92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73,\r\n  209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,\r\n  164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38,\r\n  147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189,\r\n  28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101,\r\n  155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232,\r\n  178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\r\n  191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31,\r\n  181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\r\n  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215,\r\n  61, 156, 180,\r\n];\r\n\r\n// Double the permutation table to avoid overflow\r\nconst p: number[] = [...PERMUTATION, ...PERMUTATION];\r\n\r\n// ============================================================================\r\n// Gradient Vectors\r\n// ============================================================================\r\n\r\n/**\r\n * 2D gradient vectors for Perlin noise.\r\n * These are unit vectors pointing in 8 directions.\r\n */\r\nconst GRADIENTS_2D: [number, number][] = [\r\n  [1, 1],\r\n  [-1, 1],\r\n  [1, -1],\r\n  [-1, -1],\r\n  [1, 0],\r\n  [-1, 0],\r\n  [0, 1],\r\n  [0, -1],\r\n];\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Fade function (6t^5 - 15t^4 + 10t^3)\r\n * Provides smooth interpolation curve.\r\n * This is Ken Perlin's improved smoothstep function.\r\n */\r\nfunction fade(t: number): number {\r\n  return t * t * t * (t * (t * 6 - 15) + 10);\r\n}\r\n\r\n/**\r\n * Linear interpolation between a and b\r\n */\r\nfunction lerp(t: number, a: number, b: number): number {\r\n  return a + t * (b - a);\r\n}\r\n\r\n/**\r\n * Calculate dot product of gradient vector and distance vector\r\n */\r\nfunction grad(hash: number, x: number, y: number): number {\r\n  const gradient = GRADIENTS_2D[hash & 7];\r\n  return gradient[0] * x + gradient[1] * y;\r\n}\r\n\r\n// ============================================================================\r\n// Main Noise Function\r\n// ============================================================================\r\n\r\n/**\r\n * 2D Perlin Noise function\r\n *\r\n * @param x - X coordinate\r\n * @param y - Y coordinate\r\n * @returns Noise value between 0 and 1 (normalized from -1 to 1)\r\n *\r\n * Algorithm:\r\n * 1. Find unit grid cell containing point\r\n * 2. Get relative coordinates within cell (0-1)\r\n * 3. Compute fade curves for interpolation\r\n * 4. Hash grid corners to get gradient indices\r\n * 5. Calculate dot products of gradients and distance vectors\r\n * 6. Interpolate between corner values\r\n * 7. Normalize to 0-1 range\r\n */\r\nexport function noise(x: number, y: number): number {\r\n  // Find unit grid cell containing point\r\n  const X = Math.floor(x) & 255;\r\n  const Y = Math.floor(y) & 255;\r\n\r\n  // Get relative x, y coordinates within cell\r\n  const xf = x - Math.floor(x);\r\n  const yf = y - Math.floor(y);\r\n\r\n  // Compute fade curves for each coordinate\r\n  const u = fade(xf);\r\n  const v = fade(yf);\r\n\r\n  // Hash coordinates of the 4 corners\r\n  const aa = p[p[X] + Y];\r\n  const ab = p[p[X] + Y + 1];\r\n  const ba = p[p[X + 1] + Y];\r\n  const bb = p[p[X + 1] + Y + 1];\r\n\r\n  // Calculate gradient dot products for each corner\r\n  const gradAA = grad(aa, xf, yf);\r\n  const gradBA = grad(ba, xf - 1, yf);\r\n  const gradAB = grad(ab, xf, yf - 1);\r\n  const gradBB = grad(bb, xf - 1, yf - 1);\r\n\r\n  // Interpolate along x\r\n  const x1 = lerp(u, gradAA, gradBA);\r\n  const x2 = lerp(u, gradAB, gradBB);\r\n\r\n  // Interpolate along y\r\n  const result = lerp(v, x1, x2);\r\n\r\n  // Normalize from [-1, 1] to [0, 1]\r\n  return (result + 1) / 2;\r\n}\r\n\r\n/**\r\n * Fractal Brownian Motion (fBm) - Multi-octave noise\r\n *\r\n * Combines multiple layers of noise at different frequencies\r\n * to create more natural-looking terrain.\r\n *\r\n * @param x - X coordinate\r\n * @param y - Y coordinate\r\n * @param octaves - Number of noise layers (default: 4)\r\n * @param persistence - Amplitude multiplier per octave (default: 0.5)\r\n * @param lacunarity - Frequency multiplier per octave (default: 2.0)\r\n * @returns Noise value between 0 and 1\r\n */\r\nexport function fbm(\r\n  x: number,\r\n  y: number,\r\n  octaves: number = 4,\r\n  persistence: number = 0.5,\r\n  lacunarity: number = 2.0\r\n): number {\r\n  let total = 0;\r\n  let frequency = 1;\r\n  let amplitude = 1;\r\n  let maxValue = 0;\r\n\r\n  for (let i = 0; i < octaves; i++) {\r\n    total += noise(x * frequency, y * frequency) * amplitude;\r\n    maxValue += amplitude;\r\n    amplitude *= persistence;\r\n    frequency *= lacunarity;\r\n  }\r\n\r\n  // Normalize to [0, 1]\r\n  return total / maxValue;\r\n}\r\n\r\n/**\r\n * Seeded random shuffle for reproducible results\r\n * Can be used to reseed the permutation table\r\n */\r\nexport function seedNoise(seed: number): void {\r\n  // Simple LCG random number generator\r\n  let s = seed;\r\n  const random = (): number => {\r\n    s = (s * 1664525 + 1013904223) % 4294967296;\r\n    return s / 4294967296;\r\n  };\r\n\r\n  // Fisher-Yates shuffle\r\n  const perm = [...PERMUTATION];\r\n  for (let i = perm.length - 1; i > 0; i--) {\r\n    const j = Math.floor(random() * (i + 1));\r\n    [perm[i], perm[j]] = [perm[j], perm[i]];\r\n  }\r\n\r\n  // Update permutation table\r\n  for (let i = 0; i < 256; i++) {\r\n    p[i] = perm[i];\r\n    p[i + 256] = perm[i];\r\n  }\r\n}\r\n","/**\r\n * Terrain Map Generation using Perlin Noise\r\n * Phase G: Weighted Terrain & Advanced Algorithms\r\n *\r\n * Generates organic \"terrain maps\" where grid weights vary smoothly\r\n * like hills and valleys. Uses 2D Perlin Noise for natural-looking\r\n * height distributions.\r\n *\r\n * Key Characteristics:\r\n * - Smooth, organic weight transitions (no jagged edges)\r\n * - Configurable frequency for terrain scale\r\n * - Full weight range 1-10 using contrast stretching\r\n * - Valleys (low noise values) become plains (1-3)\r\n * - Hills (medium noise values) become medium terrain (4-7)\r\n * - Peaks (high noise values) become heavy terrain (8-10)\r\n *\r\n * Weight Distribution Strategy:\r\n * - Uses contrast stretching on fbm output (typically 0.25-0.75)\r\n * - Linearly maps stretched values to weights 1-10\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\nimport { fbm, seedNoise } from \"../../utils/perlinNoise\";\r\n\r\n// ============================================================================\r\n// Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Terrain generation configuration\r\n */\r\ninterface TerrainConfig {\r\n  /** Base frequency - lower = larger terrain features (default: 0.12) */\r\n  frequency: number;\r\n  /** Number of noise octaves for detail (default: 3) */\r\n  octaves: number;\r\n  /** How much each octave contributes (default: 0.5) */\r\n  persistence: number;\r\n  /** Frequency multiplier per octave (default: 2.0) */\r\n  lacunarity: number;\r\n  /** Whether to use animation frames (default: true) */\r\n  animated: boolean;\r\n  /** Intensity bias - lower = more peaks, higher = more valleys (default: 0.7) */\r\n  intensity: number;\r\n}\r\n\r\nconst DEFAULT_CONFIG: TerrainConfig = {\r\n  frequency: 0.12,\r\n  octaves: 3,\r\n  persistence: 0.5,\r\n  lacunarity: 2.0,\r\n  animated: true,\r\n  intensity: 0.7,\r\n};\r\n\r\n// ============================================================================\r\n// Weight Mapping\r\n// ============================================================================\r\n\r\n/**\r\n * Maps noise value (0-1) to terrain weight (1-10)\r\n *\r\n * Uses contrast enhancement to stretch the typical fbm output range\r\n * (which clusters around 0.3-0.7) to the full 0-1 range, then maps\r\n * with a bias toward higher weights.\r\n *\r\n * @param noiseValue - Noise value between 0 and 1\r\n * @param intensity - Power curve exponent (lower = more peaks, higher = more valleys)\r\n * @returns Weight between 1 and 10\r\n */\r\nfunction mapNoiseToWeight(noiseValue: number, intensity: number): number {\r\n  // FBM output typically clusters around 0.3-0.7\r\n  // Apply aggressive contrast stretching to push more values to extremes\r\n  // Map 0.3-0.65 to 0-1, then clamp (narrower range = more extremes)\r\n  const stretched = (noiseValue - 0.3) * 2.85;\r\n  const n = Math.max(0, Math.min(1, stretched));\r\n\r\n  // Apply power curve to bias toward higher weights\r\n  // Lower intensity (e.g., 0.5) = more peaks (weight 10s)\r\n  // Higher intensity (e.g., 1.0) = more valleys (weight 1s)\r\n  const biased = Math.pow(n, intensity);\r\n\r\n  // Linear mapping to weights 1-10\r\n  return Math.floor(biased * 9) + 1;\r\n}\r\n\r\n// ============================================================================\r\n// Terrain Generation\r\n// ============================================================================\r\n\r\n/**\r\n * Represents a terrain modification for animation\r\n */\r\ninterface TerrainNode {\r\n  row: number;\r\n  col: number;\r\n  weight: number;\r\n}\r\n\r\n/**\r\n * Generates a terrain map using Perlin Noise\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (kept at weight 1)\r\n * @param finishNode - The finish node (kept at weight 1)\r\n * @param config - Optional terrain configuration\r\n * @returns Array of terrain nodes in animation order\r\n *\r\n * Animation Order: Radial expansion from center for visual effect\r\n */\r\nexport function generateTerrainMap(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node,\r\n  config: Partial<TerrainConfig> = {}\r\n): TerrainNode[] {\r\n  const cfg = { ...DEFAULT_CONFIG, ...config };\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Seed noise with current time for variety\r\n  seedNoise(Date.now() % 1000000);\r\n\r\n  // Generate terrain data\r\n  const terrainData: TerrainNode[] = [];\r\n\r\n  // Calculate center for radial animation\r\n  const centerRow = Math.floor(numRows / 2);\r\n  const centerCol = Math.floor(numCols / 2);\r\n\r\n  // Generate all terrain values\r\n  const noiseGrid: number[][] = [];\r\n  for (let row = 0; row < numRows; row++) {\r\n    noiseGrid[row] = [];\r\n    for (let col = 0; col < numCols; col++) {\r\n      // Use fBm (fractal Brownian motion) for more natural terrain\r\n      const noiseValue = fbm(\r\n        col * cfg.frequency,\r\n        row * cfg.frequency,\r\n        cfg.octaves,\r\n        cfg.persistence,\r\n        cfg.lacunarity\r\n      );\r\n      noiseGrid[row][col] = noiseValue;\r\n    }\r\n  }\r\n\r\n  // Collect all cells with their distance from center\r\n  const cells: { row: number; col: number; distance: number }[] = [];\r\n\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      // Skip start and finish nodes\r\n      if (\r\n        (row === startNode.row && col === startNode.col) ||\r\n        (row === finishNode.row && col === finishNode.col)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const distance = Math.sqrt(\r\n        Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2)\r\n      );\r\n\r\n      cells.push({ row, col, distance });\r\n    }\r\n  }\r\n\r\n  // Sort by distance for radial animation effect\r\n  cells.sort((a, b) => a.distance - b.distance);\r\n\r\n  // Create terrain nodes in animation order\r\n  for (const cell of cells) {\r\n    const weight = mapNoiseToWeight(\r\n      noiseGrid[cell.row][cell.col],\r\n      cfg.intensity\r\n    );\r\n    terrainData.push({\r\n      row: cell.row,\r\n      col: cell.col,\r\n      weight,\r\n    });\r\n  }\r\n\r\n  return terrainData;\r\n}\r\n\r\n/**\r\n * Applies terrain instantly to a grid (no animation)\r\n *\r\n * @param grid - The grid to modify\r\n * @param startNode - The start node\r\n * @param finishNode - The finish node\r\n * @param config - Optional terrain configuration\r\n * @returns New grid with terrain applied\r\n */\r\nexport function applyTerrainInstant(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node,\r\n  config: Partial<TerrainConfig> = {}\r\n): Grid {\r\n  const terrainNodes = generateTerrainMap(grid, startNode, finishNode, config);\r\n\r\n  // Deep copy grid\r\n  const newGrid: Grid = grid.map((row) => row.map((node) => ({ ...node })));\r\n\r\n  // Apply terrain weights\r\n  for (const terrain of terrainNodes) {\r\n    newGrid[terrain.row][terrain.col].weight = terrain.weight;\r\n    // Clear walls - terrain replaces walls\r\n    newGrid[terrain.row][terrain.col].isWall = false;\r\n  }\r\n\r\n  // Ensure start and finish are weight 1\r\n  newGrid[startNode.row][startNode.col].weight = 1;\r\n  newGrid[finishNode.row][finishNode.col].weight = 1;\r\n\r\n  return newGrid;\r\n}\r\n\r\nexport type { TerrainNode, TerrainConfig };\r\n"],"names":["MinHeap$4","__publicField","node","key","idx","min","last","parentIdx","length","leftIdx","rightIdx","smallest","i","j","keyI","keyJ","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","visited","getKey","minHeap","MinHeap","closestNode","closestKey","neighbors","getUnvisitedNeighbors","neighbor","newDistance","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","row","col","numRows","numCols","MinHeap$3","getPriority","manhattanDistance","nodeA","nodeB","astar","gScore","fScore","startKey","openSet","current","currentKey","currentGScore","getNeighbors","neighborKey","tentativeGScore","neighborGScore","Queue$1","item","bfs","queue","Queue","dfs","stack","MinHeap$2","greedyBestFirst","hScore","nodesInPathOrder","bidirectionalBFS","parentFromStart","parentFromFinish","visitedFromStart","visitedFromFinish","getNodeFromKey","startQueue","finishQueue","finishKey","meetingKey","n","pathFromStart","parent","pathToFinish","meetingParentFromFinish","fullPath","MinHeap$1","bidirectionalAStar","gScoreStart","fScoreStart","gScoreFinish","fScoreFinish","openSetStart","openSetFinish","bestPathCost","topFStart","topFFinish","pathCost","entry","DIRECTIONS","jumpPointSearch","isWalkable","cameFrom","jump","startRow","startCol","dirRow","dirCol","identifySuccessors","parentDirRow","parentDirCol","successors","directionsToCheck","dRow","dCol","jumpPoint","reconstructPath","successor","successorKey","successorNode","fScoreValue","path","jumpPoints","from","to","currentRow","currentCol","getRecursiveDivisionMaze","wallsInOrder","divide","chooseOrientation","endRow","endCol","orientation","height","width","possibleRows","getEvenNumbers","wallRow","possibleGaps","getOddNumbers","gapCol","isStartOrFinish","possibleCols","wallCol","gapRow","start","end","result","getRandomizedDFSMaze","carveIterative","ensureConnected","passagesInOrder","randomIndex","nextRow","nextCol","directions","newRow","newCol","bfsVisited","pRow","pCol","getPrimsMaze","isPassage","inFrontier","frontier","addFrontier","passageNeighbors","getPassageNeighbors","neighborRow","neighborCol","ensureNodeIsPassage","connectToNearestPassage","shuffleArray","array","getSpiralMaze","protectedCells","protectAdjacentCells","canBeWall","addWall","top","bottom","left","right","ringCount","gapSide","dr","dc","DEFAULT_CONFIG","getCellularAutomataMaze","config","wallState","initializeRandomWalls","gen","simulateGeneration","clearAroundNode","ensurePathExists","addBorderWalls","r","c","layer","wallChance","walls","currentState","birthLimit","deathLimit","newState","wallNeighbors","countWallNeighbors","state","count","nr","nc","finishRow","finishCol","reachable","carveWindingPath","PERMUTATION","p","GRADIENTS_2D","fade","t","lerp","a","b","grad","hash","x","y","gradient","noise","X","Y","xf","yf","u","v","aa","ab","ba","bb","gradAA","gradBA","gradAB","gradBB","x1","x2","fbm","octaves","persistence","lacunarity","total","frequency","amplitude","maxValue","seedNoise","seed","s","random","perm","mapNoiseToWeight","noiseValue","intensity","stretched","biased","generateTerrainMap","cfg","terrainData","centerRow","centerCol","noiseGrid","cells","distance","cell","weight"],"mappings":"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"}