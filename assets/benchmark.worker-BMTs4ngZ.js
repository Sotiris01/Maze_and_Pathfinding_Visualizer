var ct=Object.defineProperty;var pt=($,D,U)=>D in $?ct($,D,{enumerable:!0,configurable:!0,writable:!0,value:U}):$[D]=U;var E=($,D,U)=>pt($,typeof D!="symbol"?D+"":D,U);(function(){"use strict";var $=(o=>(o.DIJKSTRA="dijkstra",o.ASTAR="astar",o.BFS="bfs",o.DFS="dfs",o.GREEDY_BEST_FIRST="greedyBestFirst",o.BIDIRECTIONAL_BFS="bidirectionalBFS",o.BIDIRECTIONAL_ASTAR="bidirectionalAStar",o.JUMP_POINT_SEARCH="jumpPointSearch",o))($||{});let D=class{constructor(){E(this,"heap",[]);E(this,"positionMap",new Map)}getKey(t){return`${t.row}-${t.col}`}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.heap[t].distance>=this.heap[e].distance)break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.heap[s].distance<this.heap[n].distance&&(n=s),i<e&&this.heap[i].distance<this.heap[n].distance&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function U(o,t,e){const s=[],i=new Set,n=h=>`${h.row}-${h.col}`;t.distance=0;const a=new D;for(a.insert(t);!a.isEmpty();){const h=a.extractMin(),l=n(h);if(i.has(l)||h.isWall)continue;if(h.distance===1/0||(i.add(l),h.isVisited=!0,s.push(h),h===e))return s;const c=z(h,o,i);for(const g of c){const y=h.distance+1;y<g.distance&&(g.distance=y,g.previousNode=h,a.insert(g))}}return s}function z(o,t,e){const s=[],{row:i,col:n}=o,a=t.length,h=t[0].length;return i>0&&s.push(t[i-1][n]),i<a-1&&s.push(t[i+1][n]),n>0&&s.push(t[i][n-1]),n<h-1&&s.push(t[i][n+1]),s.filter(l=>{const c=`${l.row}-${l.col}`;return!e.has(c)&&!l.isWall})}let A=class{constructor(t,e){E(this,"heap",[]);E(this,"getKey");E(this,"getPriority");E(this,"positionMap",new Map);this.getKey=t,this.getPriority=e}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}contains(t){return this.positionMap.has(this.getKey(t))}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return null;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.getPriority(this.heap[t])>=this.getPriority(this.heap[e]))break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.getPriority(this.heap[s])<this.getPriority(this.heap[n])&&(n=s),i<e&&this.getPriority(this.heap[i])<this.getPriority(this.heap[n])&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function q(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}function Q(o,t,e){const s=[],i=new Map,n=new Map,a=c=>`${c.row}-${c.col}`;for(const c of o)for(const g of c){const y=a(g);i.set(y,1/0),n.set(y,1/0)}const h=a(t);i.set(h,0),n.set(h,q(t,e));const l=new A(a,c=>n.get(a(c))??1/0);for(l.insert(t);!l.isEmpty();){const c=l.extractMin(),g=a(c);if(c.isWall||c.isVisited)continue;const y=i.get(g)??1/0;if(y===1/0||(c.isVisited=!0,s.push(c),c===e))return s;const S=L(c,o);for(const d of S){if(d.isWall||d.isVisited)continue;const u=a(d),b=y+1,w=i.get(u)??1/0;b<w&&(d.previousNode=c,i.set(u,b),n.set(u,b+q(d,e)),l.insert(d))}}return s}function L(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return s>0&&e.push(t[s-1][i]),s<n-1&&e.push(t[s+1][i]),i>0&&e.push(t[s][i-1]),i<a-1&&e.push(t[s][i+1]),e}let Y=class{constructor(){E(this,"items",[]);E(this,"head",0)}enqueue(t){this.items.push(t)}dequeue(){if(this.isEmpty())return;const t=this.items[this.head];return this.head++,this.head>1e3&&this.head>this.items.length/2&&(this.items=this.items.slice(this.head),this.head=0),t}isEmpty(){return this.head>=this.items.length}get size(){return this.items.length-this.head}};function X(o,t,e){const s=[],i=new Y;for(t.isVisited=!0,t.distance=0,i.enqueue(t),s.push(t);!i.isEmpty();){const n=i.dequeue();if(n.isWall)continue;if(n===e)return s;const a=Z(n,o);for(const h of a)if(!h.isWall&&(h.isVisited=!0,h.previousNode=n,h.distance=n.distance+1,i.enqueue(h),s.push(h),h===e))return s}return s}function Z(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return s>0&&e.push(t[s-1][i]),s<n-1&&e.push(t[s+1][i]),i>0&&e.push(t[s][i-1]),i<a-1&&e.push(t[s][i+1]),e.filter(h=>!h.isVisited)}function N(o,t,e){const s=[],i=[];for(i.push(t);i.length>0;){const n=i.pop();if(n.isWall||n.isVisited)continue;if(n.isVisited=!0,s.push(n),n===e)return s;const a=j(n,o);for(const h of a)h.isWall||h.isVisited||(h.previousNode=n,i.push(h))}return s}function j(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return i>0&&e.push(t[s][i-1]),s<n-1&&e.push(t[s+1][i]),i<a-1&&e.push(t[s][i+1]),s>0&&e.push(t[s-1][i]),e.filter(h=>!h.isVisited)}let x=class{constructor(t,e){E(this,"heap",[]);E(this,"getKey");E(this,"getPriority");E(this,"positionMap",new Map);this.getKey=t,this.getPriority=e}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.getPriority(this.heap[t])>=this.getPriority(this.heap[e]))break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.getPriority(this.heap[s])<this.getPriority(this.heap[n])&&(n=s),i<e&&this.getPriority(this.heap[i])<this.getPriority(this.heap[n])&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function O(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}function tt(o,t,e){const s=[],i=new Set,n=c=>`${c.row}-${c.col}`,a=new Map,h=new x(n,c=>a.get(n(c))??1/0),l=n(t);for(a.set(l,O(t,e)),h.insert(t);!h.isEmpty();){const c=h.extractMin(),g=n(c);if(c.isWall||i.has(g))continue;if(i.add(g),c.isVisited=!0,s.push(c),c===e)return s;const y=et(c,o);for(const S of y){const d=n(S);S.isWall||i.has(d)||(S.previousNode=c,a.set(d,O(S,e)),h.insert(S))}}return s}function et(o,t){const e=[],{row:s,col:i}=o,n=t.length,a=t[0].length;return s>0&&e.push(t[s-1][i]),s<n-1&&e.push(t[s+1][i]),i>0&&e.push(t[s][i-1]),i<a-1&&e.push(t[s][i+1]),e}class H{constructor(){E(this,"items",[]);E(this,"head",0)}enqueue(t){this.items.push(t)}dequeue(){if(this.head>=this.items.length)return;const t=this.items[this.head];return this.head++,this.head>this.items.length/2&&this.head>100&&(this.items=this.items.slice(this.head),this.head=0),t}get size(){return this.items.length-this.head}isEmpty(){return this.head>=this.items.length}}function st(o,t,e){const s=[],i=o.length,n=o[0].length,a=new Map,h=new Map,l=new Set,c=new Set,g=p=>`${p.row}-${p.col}`,y=p=>{const[r,f]=p.split("-").map(Number);return o[r][f]},S=new H,d=new H,u=g(t);l.add(u),a.set(u,null),t.isVisited=!0,s.push(t),S.enqueue(t);const b=g(e);c.add(b),h.set(b,null),d.enqueue(e);let w=null;const v=p=>{const r=[],{row:f,col:I}=p;return f>0&&r.push(o[f-1][I]),f<i-1&&r.push(o[f+1][I]),I>0&&r.push(o[f][I-1]),I<n-1&&r.push(o[f][I+1]),r.filter(V=>!V.isWall)};for(;!S.isEmpty()&&!d.isEmpty();){if(!S.isEmpty()){const p=S.dequeue();for(const r of v(p)){const f=g(r);if(!l.has(f)){if(l.add(f),a.set(f,p),r.isVisited=!0,s.push(r),c.has(f)){w=f;break}S.enqueue(r)}}if(w)break}if(!d.isEmpty()&&!w){const p=d.dequeue();p===e&&(e.isVisited=!0,s.push(e));for(const r of v(p)){const f=g(r);if(!c.has(f)){if(c.add(f),h.set(f,p),r.isVisited=!0,s.push(r),l.has(f)){w=f;break}d.enqueue(r)}}if(w)break}}if(w){const p=[];let r=w;for(;r!==null;){p.unshift(y(r));const m=a.get(r);r=m?g(m):null}const f=[],I=h.get(w);for(r=I?g(I):null;r!==null;){f.push(y(r));const m=h.get(r);r=m?g(m):null}const V=[...p,...f];for(let m=1;m<V.length;m++)V[m].previousNode=V[m-1];e.isVisited=!0}return s}let _=class{constructor(t,e){E(this,"heap",[]);E(this,"getKey");E(this,"getPriority");E(this,"positionMap",new Map);this.getKey=t,this.getPriority=e}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}peekMin(){return this.heap[0]}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s)}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.getPriority(this.heap[t])>=this.getPriority(this.heap[e]))break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.getPriority(this.heap[s])<this.getPriority(this.heap[n])&&(n=s),i<e&&this.getPriority(this.heap[i])<this.getPriority(this.heap[n])&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}};function W(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}function it(o,t,e){const s=[],i=o.length,n=o[0].length,a=m=>`${m.row}-${m.col}`,h=m=>{const[k,K]=m.split("-").map(Number);return o[k][K]},l=new Map,c=new Map,g=new Map,y=new Set,S=new Map,d=new Map,u=new Map,b=new Set;for(const m of o)for(const k of m){const K=a(k);l.set(K,1/0),c.set(K,1/0),S.set(K,1/0),d.set(K,1/0)}const w=a(t);l.set(w,0),c.set(w,W(t,e)),g.set(w,null),y.add(w),t.isVisited=!0,s.push(t);const v=a(e);S.set(v,0),d.set(v,W(e,t)),u.set(v,null),b.add(v);const p=new _(a,m=>c.get(a(m))??1/0),r=new _(a,m=>d.get(a(m))??1/0);p.insert(t),r.insert(e);let f=null,I=1/0;const V=m=>{const k=[],{row:K,col:P}=m;return K>0&&k.push(o[K-1][P]),K<i-1&&k.push(o[K+1][P]),P>0&&k.push(o[K][P-1]),P<n-1&&k.push(o[K][P+1]),k.filter(F=>!F.isWall)};for(;!p.isEmpty()&&!r.isEmpty();){const m=c.get(a(p.peekMin()))??1/0,k=d.get(a(r.peekMin()))??1/0;if(I<=Math.min(m,k))break;if(!p.isEmpty()){const K=p.extractMin(),P=a(K);if(K.isWall)continue;if(b.has(P)){const F=(l.get(P)??1/0)+(S.get(P)??1/0);F<I&&(I=F,f=P)}for(const F of V(K)){const M=a(F),R=(l.get(P)??1/0)+1,T=l.get(M)??1/0;if(R<T&&(g.set(M,K),l.set(M,R),c.set(M,R+W(F,e)),p.insert(F),!y.has(M)&&(y.add(M),F.isVisited=!0,s.push(F),b.has(M)))){const C=R+(S.get(M)??1/0);C<I&&(I=C,f=M)}}}if(!r.isEmpty()){const K=r.extractMin(),P=a(K);if(K.isWall)continue;if(K===e&&!s.includes(e)&&(e.isVisited=!0,s.push(e)),y.has(P)){const F=(l.get(P)??1/0)+(S.get(P)??1/0);F<I&&(I=F,f=P)}for(const F of V(K)){const M=a(F),R=(S.get(P)??1/0)+1,T=S.get(M)??1/0;if(R<T&&(u.set(M,K),S.set(M,R),d.set(M,R+W(F,t)),r.insert(F),!b.has(M)&&(b.add(M),F.isVisited=!0,s.push(F),y.has(M)))){const C=(l.get(M)??1/0)+R;C<I&&(I=C,f=M)}}}}if(f!==null){const m=[];let k=f;for(;k!==null;){m.unshift(h(k));const M=g.get(k);k=M?a(M):null}const K=[],P=u.get(f);for(k=P?a(P):null;k!==null;){K.push(h(k));const M=u.get(k);k=M?a(M):null}const F=[...m,...K];for(let M=1;M<F.length;M++)F[M].previousNode=F[M-1];e.isVisited=!0}return s}class nt{constructor(){E(this,"heap",[]);E(this,"positionMap",new Map)}getKey(t){return`${t.row}-${t.col}`}get size(){return this.heap.length}isEmpty(){return this.heap.length===0}insert(t){const e=this.getKey(t);if(this.positionMap.has(e)){const s=this.positionMap.get(e);t.fScore<this.heap[s].fScore&&(this.heap[s]=t,this.bubbleUp(s),this.bubbleDown(s))}else{this.heap.push(t);const s=this.heap.length-1;this.positionMap.set(e,s),this.bubbleUp(s)}}extractMin(){if(this.heap.length===0)return;if(this.heap.length===1){const s=this.heap.pop();return this.positionMap.delete(this.getKey(s)),s}const t=this.heap[0],e=this.heap.pop();return this.positionMap.delete(this.getKey(t)),this.heap.length>0&&(this.heap[0]=e,this.positionMap.set(this.getKey(e),0),this.bubbleDown(0)),t}has(t){return this.positionMap.has(t)}bubbleUp(t){for(;t>0;){const e=Math.floor((t-1)/2);if(this.heap[t].fScore>=this.heap[e].fScore)break;this.swap(t,e),t=e}}bubbleDown(t){const e=this.heap.length;for(;;){const s=2*t+1,i=2*t+2;let n=t;if(s<e&&this.heap[s].fScore<this.heap[n].fScore&&(n=s),i<e&&this.heap[i].fScore<this.heap[n].fScore&&(n=i),n===t)break;this.swap(t,n),t=n}}swap(t,e){const s=this.getKey(this.heap[t]),i=this.getKey(this.heap[e]);[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],this.positionMap.set(s,e),this.positionMap.set(i,t)}}function G(o,t){return Math.abs(o.row-t.row)+Math.abs(o.col-t.col)}const ot=[[-1,0],[1,0],[0,-1],[0,1]];function ht(o,t,e){const s=[],i=o.length,n=o[0].length,a=(u,b)=>`${u}-${b}`,h=(u,b)=>u<0||u>=i||b<0||b>=n?!1:!o[u][b].isWall,l=new Map,c=new Map,g=a(t.row,t.col);l.set(g,0),c.set(g,null);const y=new nt;y.insert({row:t.row,col:t.col,dirRow:0,dirCol:0,fScore:G(t,e)});const S=(u,b,w,v)=>{let p=u+w,r=b+v;for(;;){if(!h(p,r))return null;if(p===e.row&&r===e.col)return{row:p,col:r};if(w===0&&(!h(p-1,r-v)&&h(p-1,r)||!h(p+1,r-v)&&h(p+1,r)))return{row:p,col:r};if(v===0&&(!h(p-w,r-1)&&h(p,r-1)||!h(p-w,r+1)&&h(p,r+1)))return{row:p,col:r};p+=w,r+=v}},d=(u,b,w,v)=>{const p=[];let r;w===0&&v===0?r=ot:w===0?(r=[[0,v]],!h(u-1,b-v)&&h(u-1,b)&&r.push([-1,0]),!h(u+1,b-v)&&h(u+1,b)&&r.push([1,0])):(r=[[w,0]],!h(u-w,b-1)&&h(u,b-1)&&r.push([0,-1]),!h(u-w,b+1)&&h(u,b+1)&&r.push([0,1]));for(const[f,I]of r){const V=S(u,b,f,I);V&&p.push(V)}return p};for(;!y.isEmpty();){const u=y.extractMin(),b=a(u.row,u.col),w=o[u.row][u.col];if(w.isVisited)continue;if(w.isVisited=!0,s.push(w),u.row===e.row&&u.col===e.col)return rt(o,c,e),s;const v=d(u.row,u.col,u.dirRow,u.dirCol);for(const p of v){const r=a(p.row,p.col),f=o[p.row][p.col];if(f.isVisited)continue;const I=(l.get(b)??1/0)+G(w,f);if(I<(l.get(r)??1/0)){c.set(r,b),l.set(r,I);const V=I+G(f,e),m=p.row===u.row?0:p.row>u.row?1:-1,k=p.col===u.col?0:p.col>u.col?1:-1;y.insert({row:p.row,col:p.col,dirRow:m,dirCol:k,fScore:V})}}}return s}function rt(o,t,e){const s=[];let i=`${e.row}-${e.col}`;const n=[];for(;i!==null;){const[a,h]=i.split("-").map(Number);n.unshift(o[a][h]),i=t.get(i)??null}for(let a=0;a<n.length-1;a++){const h=n[a],l=n[a+1];let c=h.row,g=h.col;for(;c!==l.row||g!==l.col;){const y=o[c][g];s.length>0&&(y.previousNode=s[s.length-1]),s.push(y),c<l.row?c++:c>l.row?c--:g<l.col?g++:g>l.col&&g--}}n.length>0&&(e.previousNode=s.length>0?s[s.length-1]:null,s.push(e))}function at(o){return o.map(t=>t.map(e=>({row:e.row,col:e.col,isStart:e.isStart,isFinish:e.isFinish,isWall:e.isWall,isVisited:!1,distance:1/0,previousNode:null})))}function B(o){const t=o.map(i=>i.map(n=>({...n,isVisited:!1,distance:1/0,previousNode:null})));let e=null,s=null;for(const i of t)for(const n of i)n.isStart&&(e=n),n.isFinish&&(s=n);if(!e||!s)throw new Error("Start or Finish node not found in grid");return{clonedGrid:t,start:e,finish:s}}function J(o,t,e,s){switch(o){case $.DIJKSTRA:U(t,e,s);break;case $.ASTAR:Q(t,e,s);break;case $.BFS:X(t,e,s);break;case $.DFS:N(t,e,s);break;case $.GREEDY_BEST_FIRST:tt(t,e,s);break;case $.BIDIRECTIONAL_BFS:st(t,e,s);break;case $.BIDIRECTIONAL_ASTAR:it(t,e,s);break;case $.JUMP_POINT_SEARCH:ht(t,e,s);break;default:U(t,e,s)}}self.onmessage=o=>{var h,l,c,g;const{requestId:t,algorithmName:e,gridData:s,startPos:i,finishPos:n,minDuration:a}=o.data;try{const y=at(s);if(!((l=(h=y[i.row])==null?void 0:h[i.col])!=null&&l.isStart)||!((g=(c=y[n.row])==null?void 0:c[n.col])!=null&&g.isFinish))throw new Error("Invalid start/finish positions");for(let r=0;r<3;r++){const{clonedGrid:f,start:I,finish:V}=B(y);J(e,f,I,V)}let S=0;const d=performance.now();let u=0;for(;u<a;){const{clonedGrid:r,start:f,finish:I}=B(y);J(e,r,f,I),S++,u=performance.now()-d}const b=u,w=b/S,v=1e3/w,p={avgTime:w,iterations:S,opsPerSec:v,totalTime:b};self.postMessage({success:!0,data:p,requestId:t})}catch(y){self.postMessage({success:!1,error:y instanceof Error?y.message:"Unknown error",requestId:t})}}})();
//# sourceMappingURL=benchmark.worker-BMTs4ngZ.js.map
