{"version":3,"file":"benchmark.worker-CwKMJ_BO.js","sources":["../src/types/index.ts","../src/algorithms/pathfinding/dijkstra.ts","../src/algorithms/pathfinding/astar.ts","../src/algorithms/pathfinding/bfs.ts","../src/algorithms/pathfinding/dfs.ts","../src/algorithms/pathfinding/greedyBestFirst.ts","../src/algorithms/pathfinding/bidirectionalBFS.ts","../src/algorithms/pathfinding/bidirectionalAStar.ts","../src/algorithms/pathfinding/jumpPointSearch.ts","../src/workers/benchmark.worker.ts"],"sourcesContent":["/**\r\n * Node Interface - Core data model for each cell in the grid\r\n * As specified in Section 3.1 of the project requirements\r\n */\r\nexport interface Node {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  distance: number; // For Dijkstra/A* - initialized to Infinity\r\n  previousNode: Node | null; // For backtracking the shortest path\r\n}\r\n\r\n/**\r\n * Grid Type - 2D array of Nodes\r\n */\r\nexport type Grid = Node[][];\r\n\r\n/**\r\n * Algorithm Types\r\n */\r\nexport enum AlgorithmType {\r\n  DIJKSTRA = \"dijkstra\",\r\n  ASTAR = \"astar\",\r\n  BFS = \"bfs\",\r\n  DFS = \"dfs\",\r\n  GREEDY_BEST_FIRST = \"greedyBestFirst\",\r\n  BIDIRECTIONAL_BFS = \"bidirectionalBFS\",\r\n  BIDIRECTIONAL_ASTAR = \"bidirectionalAStar\",\r\n  JUMP_POINT_SEARCH = \"jumpPointSearch\",\r\n}\r\n\r\n/**\r\n * Maze Generation Types\r\n */\r\nexport enum MazeType {\r\n  RECURSIVE_DIVISION = \"recursiveDivision\",\r\n  RANDOMIZED_DFS = \"randomizedDFS\",\r\n  PRIMS = \"prims\",\r\n  SPIRAL = \"spiral\",\r\n  CELLULAR_AUTOMATA = \"cellularAutomata\",\r\n}\r\n\r\n/**\r\n * Node State for styling purposes\r\n */\r\nexport enum NodeState {\r\n  UNVISITED = \"unvisited\",\r\n  VISITED = \"visited\",\r\n  WALL = \"wall\",\r\n  START = \"start\",\r\n  FINISH = \"finish\",\r\n  PATH = \"path\",\r\n}\r\n\r\n/**\r\n * Algorithm Result - returned after algorithm execution\r\n */\r\nexport interface AlgorithmResult {\r\n  visitedNodesInOrder: Node[];\r\n  shortestPath: Node[];\r\n  executionTimeMs: number;\r\n  visitedCount: number;\r\n  pathLength: number;\r\n}\r\n\r\n/**\r\n * Run Record - stored in localStorage for history tracking\r\n */\r\nexport interface RunRecord {\r\n  id: string; // UUID\r\n  timestamp: number; // Unix timestamp for sorting\r\n  date: string; // ISO format for display\r\n  mode: \"Single\" | \"Race\";\r\n  algorithm1: string; // Display name of algorithm 1\r\n  algorithm2?: string; // Display name of algorithm 2 (Race mode only)\r\n  gridSize: string; // e.g., \"20x30\"\r\n  // Algorithm 1 stats\r\n  time1: number; // Execution time in ms\r\n  pathLength1: number;\r\n  visitedCount1: number;\r\n  // Algorithm 2 stats (Race mode only)\r\n  time2?: number;\r\n  pathLength2?: number;\r\n  visitedCount2?: number;\r\n  // Race mode result\r\n  winner?: string; // \"Algorithm 1 Name\" | \"Algorithm 2 Name\" | \"Tie\" | \"Both Failed\"\r\n}\r\n\r\n/**\r\n * Grid Configuration Constants\r\n */\r\nexport const GRID_ROWS = 20;\r\nexport const GRID_COLS = 30;\r\n// Default Start: Top-left corner (1,1) for nice padding from edge\r\nexport const DEFAULT_START_ROW = 1;\r\nexport const DEFAULT_START_COL = 1;\r\n// Default Finish: Center of the grid (calculated dynamically)\r\nexport const DEFAULT_FINISH_ROW = Math.floor(GRID_ROWS / 2);\r\nexport const DEFAULT_FINISH_COL = Math.floor(GRID_COLS / 2);\r\n","/**\r\n * Dijkstra's Algorithm Implementation\r\n * Phase B: Basic Pathfinding\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Dijkstra's algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize start node distance to 0 (all others are Infinity)\r\n * 2. Create list of all unvisited nodes\r\n * 3. Loop:\r\n *    - Sort unvisited by distance, pick closest\r\n *    - If closest is Infinity → trapped (no path)\r\n *    - If closest is wall → skip\r\n *    - If closest is finish → done\r\n *    - Update neighbors' distances and previousNode\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n */\r\nexport function dijkstra(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Initialize start node distance\r\n  startNode.distance = 0;\r\n\r\n  // Get all nodes as unvisited list\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length > 0) {\r\n    // Sort by distance (smallest first)\r\n    sortNodesByDistance(unvisitedNodes);\r\n\r\n    // Get the closest node\r\n    const closestNode = unvisitedNodes.shift()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If closest node has Infinity distance, we're trapped\r\n    // (no path exists to remaining nodes)\r\n    if (closestNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Update all unvisited neighbors\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by dijkstra)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Flattens the 2D grid into a 1D array of all nodes.\r\n */\r\nfunction getAllNodes(grid: Grid): Node[] {\r\n  const nodes: Node[] = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/**\r\n * Sorts nodes by distance in ascending order (in-place).\r\n * Note: Simple array sort is O(n log n). A Min-Heap would be O(log n)\r\n * for production, but this is acceptable for visualization purposes.\r\n */\r\nfunction sortNodesByDistance(unvisitedNodes: Node[]): void {\r\n  unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\n/**\r\n * Updates the distance and previousNode of all unvisited neighbors.\r\n * Each neighbor's distance = current distance + 1 (uniform cost)\r\n */\r\nfunction updateUnvisitedNeighbors(node: Node, grid: Grid): void {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Distance to neighbor is current distance + 1\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","/**\r\n * A* (A-Star) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * A* is an informed search algorithm that uses a heuristic to guide\r\n * its search towards the goal, making it more efficient than Dijkstra\r\n * for pathfinding problems.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement (up, down, left, right), the Manhattan distance\r\n * provides an admissible heuristic (never overestimates the actual cost).\r\n *\r\n * @param nodeA - First node\r\n * @param nodeB - Second node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize gScore (distance from start) and fScore (gScore + heuristic)\r\n * 2. Add startNode to Open Set\r\n * 3. Loop while Open Set is not empty:\r\n *    - Pop node with lowest fScore\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each neighbor:\r\n *      - Calculate tentative gScore\r\n *      - If tentative < neighbor's gScore:\r\n *        - Update neighbor's previousNode, gScore, fScore\r\n *        - Add to Open Set if not present\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Key Difference from Dijkstra:\r\n * - Dijkstra uses only distance from start (gScore)\r\n * - A* uses distance from start + estimated distance to goal (fScore)\r\n * - This heuristic guides the search towards the goal more efficiently\r\n */\r\nexport function astar(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Use Maps to track scores (avoid mutating Node objects in React state)\r\n  // Key: \"row-col\", Value: score\r\n  const gScore = new Map<string, number>();\r\n  const fScore = new Map<string, number>();\r\n  const inOpenSet = new Map<string, boolean>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScore.set(key, Infinity);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScore.set(startKey, 0);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n\r\n  // Open Set - nodes to be evaluated (sorted by fScore)\r\n  const openSet: Node[] = [startNode];\r\n  inOpenSet.set(startKey, true);\r\n\r\n  while (openSet.length > 0) {\r\n    // Sort by fScore and get node with lowest fScore\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n\r\n    const current = openSet.shift()!;\r\n    const currentKey = getKey(current);\r\n    inOpenSet.set(currentKey, false);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (current.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Check if we're trapped (no path exists)\r\n    const currentGScore = gScore.get(currentKey) ?? Infinity;\r\n    if (currentGScore === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Calculate tentative gScore (current gScore + 1 for uniform cost)\r\n      const tentativeGScore = currentGScore + 1;\r\n\r\n      // If this path is better than any previous one\r\n      const neighborGScore = gScore.get(neighborKey) ?? Infinity;\r\n      if (tentativeGScore < neighborGScore) {\r\n        // Update the path - this is the best path to this neighbor so far\r\n        neighbor.previousNode = current;\r\n        gScore.set(neighborKey, tentativeGScore);\r\n        fScore.set(neighborKey, tentativeGScore + manhattanDistance(neighbor, finishNode));\r\n\r\n        // Add to open set if not already there\r\n        if (!inOpenSet.get(neighborKey)) {\r\n          openSet.push(neighbor);\r\n          inOpenSet.set(neighborKey, true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Reuses the same logic as Dijkstra since both use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by astar)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nexport default astar;\r\n","/**\r\n * Breadth-First Search (BFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * BFS explores nodes layer by layer, guaranteeing the shortest path\r\n * in an unweighted graph (all edges have equal cost).\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Breadth-First Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize a queue with the start node\r\n * 2. Mark start node as visited\r\n * 3. While queue is not empty:\r\n *    - Dequeue the first node (FIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Get all unvisited neighbors (up, down, left, right)\r\n *    - For each neighbor:\r\n *      - Mark as visited\r\n *      - Set previousNode pointer\r\n *      - Enqueue the neighbor\r\n *      - Add to visitedNodesInOrder\r\n * 4. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path in unweighted graphs\r\n * - Explores nodes level by level (breadth-first)\r\n * - Uses a Queue (FIFO) data structure\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function bfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Queue for BFS - FIFO (First In, First Out)\r\n  const queue: Node[] = [];\r\n\r\n  // Initialize: mark start as visited and enqueue\r\n  startNode.isVisited = true;\r\n  startNode.distance = 0;\r\n  queue.push(startNode);\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  while (queue.length > 0) {\r\n    // Dequeue the first node (FIFO)\r\n    const currentNode = queue.shift()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Mark as visited\r\n      neighbor.isVisited = true;\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Set distance (optional for BFS, but useful for consistency)\r\n      neighbor.distance = currentNode.distance + 1;\r\n\r\n      // Enqueue the neighbor\r\n      queue.push(neighbor);\r\n\r\n      // Record visit order for animation\r\n      visitedNodesInOrder.push(neighbor);\r\n\r\n      // Early exit: if we just added the finish node, we can return\r\n      if (neighbor === finishNode) {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Identical to Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by bfs)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default bfs;\r\n","/**\r\n * Depth-First Search (DFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * DFS explores as far as possible along each branch before backtracking.\r\n * Unlike BFS, DFS does NOT guarantee the shortest path.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Depth-First Search to find a path (not necessarily shortest).\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps (Iterative):\r\n * 1. Initialize a stack with the start node\r\n * 2. While stack is not empty:\r\n *    - Pop the last node (LIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If already visited → skip\r\n *    - Mark as visited and add to visitedNodesInOrder\r\n *    - Get all unvisited neighbors\r\n *    - For each neighbor:\r\n *      - Set previousNode pointer\r\n *      - Push to stack\r\n * 3. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path (explores depth-first)\r\n * - Uses a Stack (LIFO) data structure\r\n * - Memory efficient for deep paths\r\n * - Creates a \"snake-like\" movement pattern\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function dfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Stack for DFS - LIFO (Last In, First Out)\r\n  const stack: Node[] = [];\r\n\r\n  // Initialize: push start node onto stack\r\n  stack.push(startNode);\r\n\r\n  while (stack.length > 0) {\r\n    // Pop the last node (LIFO)\r\n    const currentNode = stack.pop()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (currentNode.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n\r\n    // Record visit order for animation\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    // Order: Up, Right, Down, Left\r\n    // Since stack is LIFO, we push in reverse order so Up is explored first\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Skip already visited\r\n      if (neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Push to stack\r\n      stack.push(neighbor);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n * (Identical to BFS/Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by dfs)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n * Warning: For DFS, this path is NOT necessarily the shortest!\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n *\r\n * Order: Up, Right, Down, Left (reversed for stack to create consistent movement)\r\n * Since stack is LIFO, the last pushed neighbor is explored first.\r\n * We push Left, Down, Right, Up so that Up is explored first.\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Push in reverse order for LIFO stack: Left, Down, Right, Up\r\n  // This makes DFS explore in order: Up, Right, Down, Left\r\n\r\n  // Left (pushed first, explored last)\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  // Up (pushed last, explored first)\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default dfs;\r\n","/**\r\n * Greedy Best-First Search Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Greedy Best-First Search is an informed search algorithm that selects\r\n * nodes based solely on their heuristic value (estimated distance to goal).\r\n *\r\n * Key Difference from A*:\r\n * - A* uses: fScore = gScore + hScore (actual distance + estimated remaining)\r\n * - Greedy uses: fScore = hScore only (ignores actual distance traveled)\r\n *\r\n * This makes Greedy faster but does NOT guarantee the shortest path.\r\n * It's useful when you want to find \"a\" path quickly, not necessarily the best one.\r\n *\r\n * Note: Since this algorithm uses heuristics (needs to know target location),\r\n * it should be DISABLED in Hidden Target Mode.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides\r\n * the estimated distance to the goal.\r\n *\r\n * @param nodeA - Current node\r\n * @param nodeB - Target node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Greedy Best-First Search to find a path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize fScore = heuristic (distance to goal only)\r\n * 2. Add startNode to Open Set\r\n * 3. Loop while Open Set is not empty:\r\n *    - Pop node with lowest fScore (closest to goal by heuristic)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall or visited → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each unvisited neighbor:\r\n *      - Set previousNode for path reconstruction\r\n *      - Calculate fScore = heuristic only (no gScore!)\r\n *      - Add to Open Set\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path\r\n * - Very fast for simple mazes (beelines toward goal)\r\n * - Can get \"stuck\" in dead ends with complex mazes\r\n * - Explores far fewer nodes than BFS/Dijkstra in best case\r\n */\r\nexport function greedyBestFirst(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Use Map to track fScore (heuristic only)\r\n  // Key: \"row-col\", Value: heuristic score\r\n  const fScore = new Map<string, number>();\r\n  const inOpenSet = new Map<string, boolean>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node with heuristic only (no gScore)\r\n  const startKey = getKey(startNode);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n\r\n  // Open Set - nodes to be evaluated (sorted by fScore)\r\n  const openSet: Node[] = [startNode];\r\n  inOpenSet.set(startKey, true);\r\n\r\n  while (openSet.length > 0) {\r\n    // Sort by fScore (heuristic only) and get node with lowest fScore\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n\r\n    const current = openSet.shift()!;\r\n    const currentKey = getKey(current);\r\n    inOpenSet.set(currentKey, false);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (current.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Skip if already in open set (unlike A*, we don't update paths)\r\n      if (inOpenSet.get(neighborKey)) {\r\n        continue;\r\n      }\r\n\r\n      // Set the path pointer for backtracking\r\n      neighbor.previousNode = current;\r\n\r\n      // GREEDY: fScore = heuristic ONLY (no gScore!)\r\n      // This is the key difference from A*\r\n      fScore.set(neighborKey, manhattanDistance(neighbor, finishNode));\r\n\r\n      // Add to open set\r\n      openSet.push(neighbor);\r\n      inOpenSet.set(neighborKey, true);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by greedyBestFirst)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: This path is NOT guaranteed to be the shortest!\r\n * Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n","/**\r\n * Bidirectional BFS (Breadth-First Search) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional BFS searches from both the start and finish nodes simultaneously,\r\n * meeting somewhere in the middle. This can be significantly faster than\r\n * unidirectional BFS as it explores roughly half the search space.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path in unweighted graphs\r\n * - Explores from both ends simultaneously\r\n * - Meeting point detection when frontiers intersect\r\n * - Time Complexity: O(b^(d/2)) compared to O(b^d) for unidirectional\r\n *   where b = branching factor, d = depth\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// Module-level variable to store the path after algorithm runs\r\nlet reconstructedPath: Node[] = [];\r\n\r\n/**\r\n * Performs Bidirectional BFS to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited (alternating from both sides)\r\n */\r\nexport function bidirectionalBFS(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Reset the path\r\n  reconstructedPath = [];\r\n\r\n  // Parent maps for path reconstruction\r\n  const parentFromStart: Map<string, Node | null> = new Map();\r\n  const parentFromFinish: Map<string, Node | null> = new Map();\r\n\r\n  // Visited sets for each direction\r\n  const visitedFromStart: Set<string> = new Set();\r\n  const visitedFromFinish: Set<string> = new Set();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // Initialize queues\r\n  const startQueue: Node[] = [startNode];\r\n  const finishQueue: Node[] = [finishNode];\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  visitedFromStart.add(startKey);\r\n  parentFromStart.set(startKey, null);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  visitedFromFinish.add(finishKey);\r\n  parentFromFinish.set(finishKey, null);\r\n\r\n  // Track meeting point\r\n  let meetingKey: string | null = null;\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    // Up\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    // Down\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    // Left\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    // Right\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  // Main loop - alternate between expanding from start and finish\r\n  while (startQueue.length > 0 && finishQueue.length > 0) {\r\n    // Expand from start side\r\n    if (startQueue.length > 0) {\r\n      const currentNode = startQueue.shift()!;\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from start\r\n        if (visitedFromStart.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from start\r\n        visitedFromStart.add(neighborKey);\r\n        parentFromStart.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from finish - INTERSECTION!\r\n        if (visitedFromFinish.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        startQueue.push(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n\r\n    // Expand from finish side\r\n    if (finishQueue.length > 0 && !meetingKey) {\r\n      const currentNode = finishQueue.shift()!;\r\n\r\n      // Add finish node to visited order on first expansion\r\n      if (currentNode === finishNode) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from finish\r\n        if (visitedFromFinish.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from finish\r\n        visitedFromFinish.add(neighborKey);\r\n        parentFromFinish.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from start - INTERSECTION!\r\n        if (visitedFromStart.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        finishQueue.push(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n  }\r\n\r\n  // Reconstruct path if meeting point found\r\n  if (meetingKey) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine paths\r\n    reconstructedPath = [...pathFromStart, ...pathToFinish];\r\n\r\n    // Set up previousNode chain for the path (for compatibility with animation)\r\n    for (let i = 1; i < reconstructedPath.length; i++) {\r\n      reconstructedPath[i].previousNode = reconstructedPath[i - 1];\r\n    }\r\n\r\n    // Mark finish as having a valid path\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalBFS.\r\n * Must be called after bidirectionalBFS has run.\r\n *\r\n * @param finishNode - The destination node (used for compatibility, actual path stored internally)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  // If we have a reconstructed path from bidirectional search, use it\r\n  if (reconstructedPath.length > 0) {\r\n    return reconstructedPath;\r\n  }\r\n\r\n  // Fallback: standard path reconstruction via previousNode chain\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Bidirectional A* (A-Star) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional A* combines the efficiency of A* heuristic search with\r\n * bidirectional search strategy. It searches from both start and finish\r\n * nodes simultaneously, using heuristics from both ends.\r\n *\r\n * Key Characteristics:\r\n * - Uses priority queues (Open Sets) sorted by fScore for both directions\r\n * - Two heuristics: startOpenSet → finishNode, finishOpenSet → startNode\r\n * - Meeting point detection when frontiers intersect\r\n * - Guarantees shortest path in graphs with consistent heuristics\r\n * - Can be significantly faster than unidirectional A*\r\n *\r\n * Time Complexity: O(b^(d/2)) compared to O(b^d) for unidirectional A*\r\n * where b = branching factor, d = depth\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// Module-level variable to store the path after algorithm runs\r\nlet reconstructedPath: Node[] = [];\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides an\r\n * admissible heuristic (never overestimates the actual cost).\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Bidirectional A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited (alternating from both sides)\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize two Open Sets (priority queues) - one from start, one from finish\r\n * 2. Each side uses gScore (distance from origin) and fScore (gScore + heuristic)\r\n * 3. Loop while both Open Sets are not empty:\r\n *    - Expand from start side: pop lowest fScore, check for intersection\r\n *    - Expand from finish side: pop lowest fScore, check for intersection\r\n * 4. When frontiers meet, reconstruct path through meeting point\r\n */\r\nexport function bidirectionalAStar(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Reset the path\r\n  reconstructedPath = [];\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // === START SIDE DATA STRUCTURES ===\r\n  // gScore: distance from startNode\r\n  // fScore: gScore + heuristic to finishNode\r\n  const gScoreStart = new Map<string, number>();\r\n  const fScoreStart = new Map<string, number>();\r\n  const parentFromStart = new Map<string, Node | null>();\r\n  const visitedFromStart = new Set<string>();\r\n  const inOpenSetStart = new Map<string, boolean>();\r\n  const openSetStart: Node[] = [];\r\n\r\n  // === FINISH SIDE DATA STRUCTURES ===\r\n  // gScore: distance from finishNode\r\n  // fScore: gScore + heuristic to startNode\r\n  const gScoreFinish = new Map<string, number>();\r\n  const fScoreFinish = new Map<string, number>();\r\n  const parentFromFinish = new Map<string, Node | null>();\r\n  const visitedFromFinish = new Set<string>();\r\n  const inOpenSetFinish = new Map<string, boolean>();\r\n  const openSetFinish: Node[] = [];\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScoreStart.set(key, Infinity);\r\n      fScoreStart.set(key, Infinity);\r\n      gScoreFinish.set(key, Infinity);\r\n      fScoreFinish.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScoreStart.set(startKey, 0);\r\n  fScoreStart.set(startKey, manhattanDistance(startNode, finishNode));\r\n  parentFromStart.set(startKey, null);\r\n  openSetStart.push(startNode);\r\n  inOpenSetStart.set(startKey, true);\r\n  visitedFromStart.add(startKey);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  gScoreFinish.set(finishKey, 0);\r\n  fScoreFinish.set(finishKey, manhattanDistance(finishNode, startNode));\r\n  parentFromFinish.set(finishKey, null);\r\n  openSetFinish.push(finishNode);\r\n  inOpenSetFinish.set(finishKey, true);\r\n  visitedFromFinish.add(finishKey);\r\n\r\n  // Track meeting point\r\n  let meetingKey: string | null = null;\r\n  let bestPathCost = Infinity;\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    // Up\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    // Down\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    // Left\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    // Right\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  /**\r\n   * Sort and pop the node with lowest fScore from an open set\r\n   */\r\n  const popLowestFScore = (\r\n    openSet: Node[],\r\n    fScore: Map<string, number>\r\n  ): Node | undefined => {\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n    return openSet.shift();\r\n  };\r\n\r\n  // Main loop - alternate between expanding from start and finish\r\n  while (openSetStart.length > 0 && openSetFinish.length > 0) {\r\n    // === EXPAND FROM START SIDE ===\r\n    if (openSetStart.length > 0) {\r\n      const current = popLowestFScore(openSetStart, fScoreStart);\r\n      if (!current) break;\r\n\r\n      const currentKey = getKey(current);\r\n      inOpenSetStart.set(currentKey, false);\r\n\r\n      // Skip walls\r\n      if (current.isWall) continue;\r\n\r\n      // Check for intersection - has finish side visited this node?\r\n      if (visitedFromFinish.has(currentKey)) {\r\n        // Calculate total path cost through this meeting point\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip already fully processed nodes\r\n        if (\r\n          visitedFromStart.has(neighborKey) &&\r\n          !inOpenSetStart.get(neighborKey)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        const tentativeGScore = (gScoreStart.get(currentKey) ?? Infinity) + 1;\r\n        const neighborGScore = gScoreStart.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          // Found a better path\r\n          parentFromStart.set(neighborKey, current);\r\n          gScoreStart.set(neighborKey, tentativeGScore);\r\n          fScoreStart.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, finishNode)\r\n          );\r\n\r\n          if (!inOpenSetStart.get(neighborKey)) {\r\n            openSetStart.push(neighbor);\r\n            inOpenSetStart.set(neighborKey, true);\r\n          }\r\n\r\n          // Add to visited order for animation (if not already visited from start)\r\n          if (!visitedFromStart.has(neighborKey)) {\r\n            visitedFromStart.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check if this creates a better meeting point\r\n            if (visitedFromFinish.has(neighborKey)) {\r\n              const pathCost =\r\n                tentativeGScore + (gScoreFinish.get(neighborKey) ?? Infinity);\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // === EXPAND FROM FINISH SIDE ===\r\n    if (openSetFinish.length > 0) {\r\n      const current = popLowestFScore(openSetFinish, fScoreFinish);\r\n      if (!current) break;\r\n\r\n      const currentKey = getKey(current);\r\n      inOpenSetFinish.set(currentKey, false);\r\n\r\n      // Skip walls\r\n      if (current.isWall) continue;\r\n\r\n      // Add finish node to visited order on first expansion\r\n      if (current === finishNode && !visitedNodesInOrder.includes(finishNode)) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      // Check for intersection - has start side visited this node?\r\n      if (visitedFromStart.has(currentKey)) {\r\n        // Calculate total path cost through this meeting point\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip already fully processed nodes\r\n        if (\r\n          visitedFromFinish.has(neighborKey) &&\r\n          !inOpenSetFinish.get(neighborKey)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        const tentativeGScore = (gScoreFinish.get(currentKey) ?? Infinity) + 1;\r\n        const neighborGScore = gScoreFinish.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          // Found a better path\r\n          parentFromFinish.set(neighborKey, current);\r\n          gScoreFinish.set(neighborKey, tentativeGScore);\r\n          fScoreFinish.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, startNode)\r\n          );\r\n\r\n          if (!inOpenSetFinish.get(neighborKey)) {\r\n            openSetFinish.push(neighbor);\r\n            inOpenSetFinish.set(neighborKey, true);\r\n          }\r\n\r\n          // Add to visited order for animation (if not already visited from finish)\r\n          if (!visitedFromFinish.has(neighborKey)) {\r\n            visitedFromFinish.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check if this creates a better meeting point\r\n            if (visitedFromStart.has(neighborKey)) {\r\n              const pathCost =\r\n                (gScoreStart.get(neighborKey) ?? Infinity) + tentativeGScore;\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Early termination: if both sides have exhausted their frontiers near the meeting point\r\n    // We use a simple heuristic: if the sum of minimum fScores exceeds best path cost, we're done\r\n    if (\r\n      meetingKey !== null &&\r\n      openSetStart.length > 0 &&\r\n      openSetFinish.length > 0\r\n    ) {\r\n      const minFStart = fScoreStart.get(getKey(openSetStart[0])) ?? Infinity;\r\n      const minFFinish = fScoreFinish.get(getKey(openSetFinish[0])) ?? Infinity;\r\n\r\n      // If the minimum possible path through remaining nodes is worse than our best, stop\r\n      if (minFStart + minFFinish >= bestPathCost) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reconstruct path if meeting point found\r\n  if (meetingKey !== null) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine paths\r\n    reconstructedPath = [...pathFromStart, ...pathToFinish];\r\n\r\n    // Set up previousNode chain for the path (for compatibility with animation)\r\n    for (let i = 1; i < reconstructedPath.length; i++) {\r\n      reconstructedPath[i].previousNode = reconstructedPath[i - 1];\r\n    }\r\n\r\n    // Mark finish as having a valid path\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalAStar.\r\n * Must be called after bidirectionalAStar has run.\r\n *\r\n * @param finishNode - The destination node (used for compatibility, actual path stored internally)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  // If we have a reconstructed path from bidirectional search, use it\r\n  if (reconstructedPath.length > 0) {\r\n    return reconstructedPath;\r\n  }\r\n\r\n  // Fallback: standard path reconstruction via previousNode chain\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Jump Point Search (JPS) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Jump Point Search is an optimization over A* for uniform-cost grids.\r\n * It dramatically reduces the number of nodes that need to be examined\r\n * by \"jumping\" over intermediate nodes in straight lines and only\r\n * considering nodes that are \"forced neighbors\" or corner points.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path (same as A*)\r\n * - Only works on uniform-cost grids (all edge weights equal)\r\n * - Exploits grid structure to skip intermediate nodes\r\n * - Typically 10-100x faster than A* in open spaces\r\n * - Falls back to A*-like behavior in dense obstacle environments\r\n *\r\n * Note: This implementation is for 4-directional movement (cardinal only).\r\n * For 8-directional (with diagonals), the forced neighbor rules differ.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Direction vectors for 4-directional movement\r\n * [row delta, col delta]\r\n */\r\nconst DIRECTIONS: [number, number][] = [\r\n  [-1, 0], // Up\r\n  [1, 0], // Down\r\n  [0, -1], // Left\r\n  [0, 1], // Right\r\n];\r\n\r\n/**\r\n * Performs Jump Point Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n */\r\nexport function jumpPointSearch(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Helper to get node key\r\n  const getKey = (row: number, col: number): string => `${row}-${col}`;\r\n\r\n  // Check if a position is valid and not a wall\r\n  const isWalkable = (row: number, col: number): boolean => {\r\n    if (row < 0 || row >= numRows || col < 0 || col >= numCols) return false;\r\n    return !grid[row][col].isWall;\r\n  };\r\n\r\n  // Use Maps to track scores\r\n  const gScore = new Map<string, number>();\r\n  const fScore = new Map<string, number>();\r\n  const cameFrom = new Map<string, string | null>();\r\n  const inOpenSet = new Map<string, boolean>();\r\n\r\n  // Initialize all with Infinity\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node.row, node.col);\r\n      gScore.set(key, Infinity);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode.row, startNode.col);\r\n  gScore.set(startKey, 0);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n  cameFrom.set(startKey, null);\r\n\r\n  // Open set with direction info: [row, col, dirRow, dirCol]\r\n  // Direction is used to determine which neighbors to explore\r\n  const openSet: {\r\n    row: number;\r\n    col: number;\r\n    dirRow: number;\r\n    dirCol: number;\r\n  }[] = [];\r\n\r\n  // Add start node with all directions (no parent direction)\r\n  openSet.push({\r\n    row: startNode.row,\r\n    col: startNode.col,\r\n    dirRow: 0,\r\n    dirCol: 0,\r\n  });\r\n  inOpenSet.set(startKey, true);\r\n\r\n  /**\r\n   * Jump function - the core of JPS\r\n   * Recursively jumps in a direction until it finds:\r\n   * 1. The goal node\r\n   * 2. A jump point (forced neighbor exists)\r\n   * 3. A wall or boundary (returns null)\r\n   */\r\n  const jump = (\r\n    row: number,\r\n    col: number,\r\n    dirRow: number,\r\n    dirCol: number\r\n  ): { row: number; col: number } | null => {\r\n    const nextRow = row + dirRow;\r\n    const nextCol = col + dirCol;\r\n\r\n    // Hit wall or boundary\r\n    if (!isWalkable(nextRow, nextCol)) {\r\n      return null;\r\n    }\r\n\r\n    // Found the goal!\r\n    if (nextRow === finishNode.row && nextCol === finishNode.col) {\r\n      return { row: nextRow, col: nextCol };\r\n    }\r\n\r\n    // Check for forced neighbors (4-directional rules)\r\n    // A forced neighbor exists when there's a wall adjacent to the path\r\n    // that creates a shorter path through the current node\r\n\r\n    // Horizontal movement (dirRow === 0)\r\n    if (dirRow === 0) {\r\n      // Check for forced neighbors above and below\r\n      // If there's a wall above/below and walkable diagonal, it's a jump point\r\n      if (\r\n        (!isWalkable(nextRow - 1, nextCol - dirCol) &&\r\n          isWalkable(nextRow - 1, nextCol)) ||\r\n        (!isWalkable(nextRow + 1, nextCol - dirCol) &&\r\n          isWalkable(nextRow + 1, nextCol))\r\n      ) {\r\n        return { row: nextRow, col: nextCol };\r\n      }\r\n    }\r\n\r\n    // Vertical movement (dirCol === 0)\r\n    if (dirCol === 0) {\r\n      // Check for forced neighbors left and right\r\n      if (\r\n        (!isWalkable(nextRow - dirRow, nextCol - 1) &&\r\n          isWalkable(nextRow, nextCol - 1)) ||\r\n        (!isWalkable(nextRow - dirRow, nextCol + 1) &&\r\n          isWalkable(nextRow, nextCol + 1))\r\n      ) {\r\n        return { row: nextRow, col: nextCol };\r\n      }\r\n    }\r\n\r\n    // Continue jumping in the same direction\r\n    return jump(nextRow, nextCol, dirRow, dirCol);\r\n  };\r\n\r\n  /**\r\n   * Identify successors (jump points) from a node\r\n   */\r\n  const identifySuccessors = (\r\n    row: number,\r\n    col: number,\r\n    parentDirRow: number,\r\n    parentDirCol: number\r\n  ): { row: number; col: number }[] => {\r\n    const successors: { row: number; col: number }[] = [];\r\n\r\n    // Determine which directions to explore based on parent direction\r\n    let directionsToCheck: [number, number][];\r\n\r\n    if (parentDirRow === 0 && parentDirCol === 0) {\r\n      // Start node - check all directions\r\n      directionsToCheck = DIRECTIONS;\r\n    } else if (parentDirRow === 0) {\r\n      // Horizontal movement - continue horizontal + check perpendicular if forced\r\n      directionsToCheck = [[0, parentDirCol]]; // Continue in same direction\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - 1, col - parentDirCol) &&\r\n        isWalkable(row - 1, col)\r\n      ) {\r\n        directionsToCheck.push([-1, 0]);\r\n      }\r\n      if (\r\n        !isWalkable(row + 1, col - parentDirCol) &&\r\n        isWalkable(row + 1, col)\r\n      ) {\r\n        directionsToCheck.push([1, 0]);\r\n      }\r\n    } else {\r\n      // Vertical movement - continue vertical + check perpendicular if forced\r\n      directionsToCheck = [[parentDirRow, 0]]; // Continue in same direction\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - parentDirRow, col - 1) &&\r\n        isWalkable(row, col - 1)\r\n      ) {\r\n        directionsToCheck.push([0, -1]);\r\n      }\r\n      if (\r\n        !isWalkable(row - parentDirRow, col + 1) &&\r\n        isWalkable(row, col + 1)\r\n      ) {\r\n        directionsToCheck.push([0, 1]);\r\n      }\r\n    }\r\n\r\n    // Jump in each valid direction\r\n    for (const [dRow, dCol] of directionsToCheck) {\r\n      const jumpPoint = jump(row, col, dRow, dCol);\r\n      if (jumpPoint) {\r\n        successors.push(jumpPoint);\r\n      }\r\n    }\r\n\r\n    return successors;\r\n  };\r\n\r\n  // Main loop\r\n  while (openSet.length > 0) {\r\n    // Sort by fScore and get lowest\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a.row, a.col)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b.row, b.col)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n\r\n    const current = openSet.shift()!;\r\n    const currentKey = getKey(current.row, current.col);\r\n    const currentNode = grid[current.row][current.col];\r\n\r\n    inOpenSet.set(currentKey, false);\r\n\r\n    // Skip if already visited\r\n    if (currentNode.isVisited) continue;\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // Found the goal!\r\n    if (current.row === finishNode.row && current.col === finishNode.col) {\r\n      // Reconstruct path using previousNode pointers\r\n      reconstructPath(grid, cameFrom, startNode, finishNode);\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get successors (jump points)\r\n    const successors = identifySuccessors(\r\n      current.row,\r\n      current.col,\r\n      current.dirRow,\r\n      current.dirCol\r\n    );\r\n\r\n    for (const successor of successors) {\r\n      const successorKey = getKey(successor.row, successor.col);\r\n      const successorNode = grid[successor.row][successor.col];\r\n\r\n      if (successorNode.isVisited) continue;\r\n\r\n      // Calculate tentative gScore (actual distance, not just 1)\r\n      const tentativeGScore =\r\n        (gScore.get(currentKey) ?? Infinity) +\r\n        manhattanDistance(currentNode, successorNode);\r\n\r\n      if (tentativeGScore < (gScore.get(successorKey) ?? Infinity)) {\r\n        // Found a better path\r\n        cameFrom.set(successorKey, currentKey);\r\n        gScore.set(successorKey, tentativeGScore);\r\n        fScore.set(\r\n          successorKey,\r\n          tentativeGScore + manhattanDistance(successorNode, finishNode)\r\n        );\r\n\r\n        // Calculate direction from current to successor\r\n        const dirRow =\r\n          successor.row === current.row\r\n            ? 0\r\n            : successor.row > current.row\r\n            ? 1\r\n            : -1;\r\n        const dirCol =\r\n          successor.col === current.col\r\n            ? 0\r\n            : successor.col > current.col\r\n            ? 1\r\n            : -1;\r\n\r\n        if (!inOpenSet.get(successorKey)) {\r\n          openSet.push({\r\n            row: successor.row,\r\n            col: successor.col,\r\n            dirRow,\r\n            dirCol,\r\n          });\r\n          inOpenSet.set(successorKey, true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Reconstructs the path by setting previousNode pointers\r\n * JPS jumps over nodes, so we need to fill in the gaps\r\n */\r\nfunction reconstructPath(\r\n  grid: Grid,\r\n  cameFrom: Map<string, string | null>,\r\n  _startNode: Node,\r\n  finishNode: Node\r\n): void {\r\n  const path: Node[] = [];\r\n  let currentKey: string | null = `${finishNode.row}-${finishNode.col}`;\r\n\r\n  // Collect jump points from finish to start\r\n  const jumpPoints: Node[] = [];\r\n  while (currentKey !== null) {\r\n    const [row, col] = currentKey.split(\"-\").map(Number);\r\n    jumpPoints.unshift(grid[row][col]);\r\n    currentKey = cameFrom.get(currentKey) ?? null;\r\n  }\r\n\r\n  // Fill in intermediate nodes between jump points\r\n  for (let i = 0; i < jumpPoints.length - 1; i++) {\r\n    const from = jumpPoints[i];\r\n    const to = jumpPoints[i + 1];\r\n\r\n    // Add intermediate nodes\r\n    let currentRow = from.row;\r\n    let currentCol = from.col;\r\n\r\n    while (currentRow !== to.row || currentCol !== to.col) {\r\n      const node = grid[currentRow][currentCol];\r\n      if (path.length > 0) {\r\n        node.previousNode = path[path.length - 1];\r\n      }\r\n      path.push(node);\r\n\r\n      // Move towards target\r\n      if (currentRow < to.row) currentRow++;\r\n      else if (currentRow > to.row) currentRow--;\r\n      else if (currentCol < to.col) currentCol++;\r\n      else if (currentCol > to.col) currentCol--;\r\n    }\r\n  }\r\n\r\n  // Add the finish node\r\n  if (jumpPoints.length > 0) {\r\n    finishNode.previousNode = path.length > 0 ? path[path.length - 1] : null;\r\n    path.push(finishNode);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by Jump Point Search.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Benchmark Web Worker\r\n * Industrial-Grade Isolated Timing System\r\n *\r\n * This worker runs in a completely separate thread from the UI,\r\n * guaranteeing zero interference from:\r\n * - DOM rendering\r\n * - React state updates\r\n * - User interactions (mouse, scroll, resize)\r\n * - Animation frames\r\n * - Garbage collection on main thread\r\n *\r\n * Uses adaptive sampling: keeps running until minDuration passes,\r\n * then calculates average time per operation.\r\n */\r\n\r\nimport { Grid, Node, AlgorithmType } from \"../types\";\r\n\r\n// === ALGORITHM IMPORTS ===\r\n// Import the raw algorithm functions directly\r\nimport { dijkstra } from \"../algorithms/pathfinding/dijkstra\";\r\nimport { astar } from \"../algorithms/pathfinding/astar\";\r\nimport { bfs } from \"../algorithms/pathfinding/bfs\";\r\nimport { dfs } from \"../algorithms/pathfinding/dfs\";\r\nimport { greedyBestFirst } from \"../algorithms/pathfinding/greedyBestFirst\";\r\nimport { bidirectionalBFS } from \"../algorithms/pathfinding/bidirectionalBFS\";\r\nimport { bidirectionalAStar } from \"../algorithms/pathfinding/bidirectionalAStar\";\r\nimport { jumpPointSearch } from \"../algorithms/pathfinding/jumpPointSearch\";\r\n\r\n// === TYPE DEFINITIONS ===\r\n\r\ninterface BenchmarkInput {\r\n  requestId: number; // Unique ID to match request with response\r\n  algorithmName: AlgorithmType;\r\n  gridData: SerializedGrid;\r\n  startPos: { row: number; col: number };\r\n  finishPos: { row: number; col: number };\r\n  minDuration: number; // Minimum benchmark duration in ms (e.g., 200)\r\n}\r\n\r\ninterface BenchmarkOutput {\r\n  avgTime: number; // Average time per execution in ms\r\n  iterations: number; // Number of iterations completed\r\n  opsPerSec: number; // Operations per second\r\n  totalTime: number; // Total benchmark duration\r\n}\r\n\r\n// Serialized grid format (no circular references)\r\ntype SerializedNode = {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n};\r\n\r\ntype SerializedGrid = SerializedNode[][];\r\n\r\n// === HELPER FUNCTIONS ===\r\n\r\n/**\r\n * Reconstructs a full Grid from serialized data\r\n * Creates fresh Node objects with all required properties\r\n */\r\nfunction deserializeGrid(serialized: SerializedGrid): Grid {\r\n  return serialized.map((row) =>\r\n    row.map((cell) => ({\r\n      row: cell.row,\r\n      col: cell.col,\r\n      isStart: cell.isStart,\r\n      isFinish: cell.isFinish,\r\n      isWall: cell.isWall,\r\n      isVisited: false,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n    }))\r\n  );\r\n}\r\n\r\n/**\r\n * Creates a fresh deep copy of the grid for each benchmark iteration\r\n * Ensures no state pollution between runs\r\n */\r\nfunction cloneGridForIteration(grid: Grid): {\r\n  clonedGrid: Grid;\r\n  start: Node;\r\n  finish: Node;\r\n} {\r\n  const clonedGrid: Grid = grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isVisited: false,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n    }))\r\n  );\r\n\r\n  let start: Node | null = null;\r\n  let finish: Node | null = null;\r\n\r\n  for (const row of clonedGrid) {\r\n    for (const node of row) {\r\n      if (node.isStart) start = node;\r\n      if (node.isFinish) finish = node;\r\n    }\r\n  }\r\n\r\n  if (!start || !finish) {\r\n    throw new Error(\"Start or Finish node not found in grid\");\r\n  }\r\n\r\n  return { clonedGrid, start, finish };\r\n}\r\n\r\n/**\r\n * Runs the specified algorithm on a grid\r\n */\r\nfunction runAlgorithm(\r\n  algorithmName: AlgorithmType,\r\n  grid: Grid,\r\n  start: Node,\r\n  finish: Node\r\n): void {\r\n  switch (algorithmName) {\r\n    case AlgorithmType.DIJKSTRA:\r\n      dijkstra(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.ASTAR:\r\n      astar(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.BFS:\r\n      bfs(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.DFS:\r\n      dfs(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.GREEDY_BEST_FIRST:\r\n      greedyBestFirst(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.BIDIRECTIONAL_BFS:\r\n      bidirectionalBFS(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.BIDIRECTIONAL_ASTAR:\r\n      bidirectionalAStar(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.JUMP_POINT_SEARCH:\r\n      jumpPointSearch(grid, start, finish);\r\n      break;\r\n    default:\r\n      dijkstra(grid, start, finish);\r\n  }\r\n}\r\n\r\n// === MAIN MESSAGE HANDLER ===\r\n\r\nself.onmessage = (event: MessageEvent<BenchmarkInput>) => {\r\n  const {\r\n    requestId,\r\n    algorithmName,\r\n    gridData,\r\n    startPos,\r\n    finishPos,\r\n    minDuration,\r\n  } = event.data;\r\n\r\n  try {\r\n    // === PHASE 1: DESERIALIZE ===\r\n    // Parse grid data (this overhead is NOT measured)\r\n    const baseGrid = deserializeGrid(gridData);\r\n\r\n    // Verify start/finish positions\r\n    if (\r\n      !baseGrid[startPos.row]?.[startPos.col]?.isStart ||\r\n      !baseGrid[finishPos.row]?.[finishPos.col]?.isFinish\r\n    ) {\r\n      throw new Error(\"Invalid start/finish positions\");\r\n    }\r\n\r\n    // === PHASE 2: WARM-UP ===\r\n    // Run 3 times to trigger JIT optimization\r\n    // These results are discarded\r\n    for (let i = 0; i < 3; i++) {\r\n      const { clonedGrid, start, finish } = cloneGridForIteration(baseGrid);\r\n      runAlgorithm(algorithmName, clonedGrid, start, finish);\r\n    }\r\n\r\n    // === PHASE 3: ADAPTIVE SAMPLING LOOP ===\r\n    // Keep running until minDuration has passed\r\n    let iterations = 0;\r\n    const startTime = performance.now();\r\n    let elapsed = 0;\r\n\r\n    while (elapsed < minDuration) {\r\n      // Create fresh grid for this iteration\r\n      const { clonedGrid, start, finish } = cloneGridForIteration(baseGrid);\r\n\r\n      // Run algorithm (only this is timed)\r\n      runAlgorithm(algorithmName, clonedGrid, start, finish);\r\n\r\n      iterations++;\r\n      elapsed = performance.now() - startTime;\r\n    }\r\n\r\n    // === PHASE 4: CALCULATE STATISTICS ===\r\n    const totalTime = elapsed;\r\n    const avgTime = totalTime / iterations;\r\n    const opsPerSec = 1000 / avgTime;\r\n\r\n    // === PHASE 5: RETURN RESULTS ===\r\n    const output: BenchmarkOutput = {\r\n      avgTime,\r\n      iterations,\r\n      opsPerSec,\r\n      totalTime,\r\n    };\r\n\r\n    self.postMessage({ success: true, data: output, requestId });\r\n  } catch (error) {\r\n    self.postMessage({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : \"Unknown error\",\r\n      requestId,\r\n    });\r\n  }\r\n};\r\n\r\n// TypeScript requires this for module workers\r\nexport {};\r\n"],"names":["AlgorithmType","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","getAllNodes","sortNodesByDistance","closestNode","updateUnvisitedNeighbors","nodes","row","node","a","b","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","neighbors","col","numRows","numCols","manhattanDistance","nodeA","nodeB","astar","gScore","fScore","inOpenSet","getKey","key","startKey","openSet","fA","fB","current","currentKey","currentGScore","getNeighbors","neighborKey","tentativeGScore","neighborGScore","bfs","queue","currentNode","dfs","stack","greedyBestFirst","reconstructedPath","bidirectionalBFS","parentFromStart","parentFromFinish","visitedFromStart","visitedFromFinish","getNodeFromKey","startQueue","finishQueue","finishKey","meetingKey","n","pathFromStart","parent","pathToFinish","meetingParentFromFinish","i","bidirectionalAStar","gScoreStart","fScoreStart","inOpenSetStart","openSetStart","gScoreFinish","fScoreFinish","inOpenSetFinish","openSetFinish","bestPathCost","popLowestFScore","pathCost","minFStart","minFFinish","DIRECTIONS","jumpPointSearch","isWalkable","cameFrom","jump","dirRow","dirCol","nextRow","nextCol","identifySuccessors","parentDirRow","parentDirCol","successors","directionsToCheck","dRow","dCol","jumpPoint","reconstructPath","successor","successorKey","successorNode","_startNode","path","jumpPoints","from","to","currentRow","currentCol","deserializeGrid","serialized","cell","cloneGridForIteration","clonedGrid","start","finish","runAlgorithm","algorithmName","event","requestId","gridData","startPos","finishPos","minDuration","baseGrid","_b","_a","_d","_c","iterations","startTime","elapsed","totalTime","avgTime","opsPerSec","output","error"],"mappings":"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"}