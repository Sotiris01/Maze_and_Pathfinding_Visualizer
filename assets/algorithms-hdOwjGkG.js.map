{"version":3,"file":"algorithms-hdOwjGkG.js","sources":["../../src/algorithms/pathfinding/dijkstra.ts","../../src/algorithms/pathfinding/astar.ts","../../src/algorithms/pathfinding/bfs.ts","../../src/algorithms/pathfinding/dfs.ts","../../src/algorithms/pathfinding/greedyBestFirst.ts","../../src/algorithms/pathfinding/bidirectionalBFS.ts","../../src/algorithms/pathfinding/bidirectionalAStar.ts","../../src/algorithms/pathfinding/jumpPointSearch.ts","../../src/algorithms/maze/recursiveDivision.ts","../../src/algorithms/maze/randomizedDFS.ts","../../src/algorithms/maze/prims.ts","../../src/algorithms/maze/spiralMaze.ts","../../src/algorithms/maze/cellularAutomata.ts"],"sourcesContent":["/**\r\n * Dijkstra's Algorithm Implementation\r\n * Phase B: Basic Pathfinding\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Dijkstra's algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize start node distance to 0 (all others are Infinity)\r\n * 2. Create list of all unvisited nodes\r\n * 3. Loop:\r\n *    - Sort unvisited by distance, pick closest\r\n *    - If closest is Infinity → trapped (no path)\r\n *    - If closest is wall → skip\r\n *    - If closest is finish → done\r\n *    - Update neighbors' distances and previousNode\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n */\r\nexport function dijkstra(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Initialize start node distance\r\n  startNode.distance = 0;\r\n\r\n  // Get all nodes as unvisited list\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length > 0) {\r\n    // Sort by distance (smallest first)\r\n    sortNodesByDistance(unvisitedNodes);\r\n\r\n    // Get the closest node\r\n    const closestNode = unvisitedNodes.shift()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If closest node has Infinity distance, we're trapped\r\n    // (no path exists to remaining nodes)\r\n    if (closestNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Update all unvisited neighbors\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by dijkstra)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Flattens the 2D grid into a 1D array of all nodes.\r\n */\r\nfunction getAllNodes(grid: Grid): Node[] {\r\n  const nodes: Node[] = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/**\r\n * Sorts nodes by distance in ascending order (in-place).\r\n * Note: Simple array sort is O(n log n). A Min-Heap would be O(log n)\r\n * for production, but this is acceptable for visualization purposes.\r\n */\r\nfunction sortNodesByDistance(unvisitedNodes: Node[]): void {\r\n  unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\n/**\r\n * Updates the distance and previousNode of all unvisited neighbors.\r\n * Each neighbor's distance = current distance + 1 (uniform cost)\r\n */\r\nfunction updateUnvisitedNeighbors(node: Node, grid: Grid): void {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Distance to neighbor is current distance + 1\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","/**\r\n * A* (A-Star) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * A* is an informed search algorithm that uses a heuristic to guide\r\n * its search towards the goal, making it more efficient than Dijkstra\r\n * for pathfinding problems.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement (up, down, left, right), the Manhattan distance\r\n * provides an admissible heuristic (never overestimates the actual cost).\r\n *\r\n * @param nodeA - First node\r\n * @param nodeB - Second node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize gScore (distance from start) and fScore (gScore + heuristic)\r\n * 2. Add startNode to Open Set\r\n * 3. Loop while Open Set is not empty:\r\n *    - Pop node with lowest fScore\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each neighbor:\r\n *      - Calculate tentative gScore\r\n *      - If tentative < neighbor's gScore:\r\n *        - Update neighbor's previousNode, gScore, fScore\r\n *        - Add to Open Set if not present\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Key Difference from Dijkstra:\r\n * - Dijkstra uses only distance from start (gScore)\r\n * - A* uses distance from start + estimated distance to goal (fScore)\r\n * - This heuristic guides the search towards the goal more efficiently\r\n */\r\nexport function astar(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Use Maps to track scores (avoid mutating Node objects in React state)\r\n  // Key: \"row-col\", Value: score\r\n  const gScore = new Map<string, number>();\r\n  const fScore = new Map<string, number>();\r\n  const inOpenSet = new Map<string, boolean>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScore.set(key, Infinity);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScore.set(startKey, 0);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n\r\n  // Open Set - nodes to be evaluated (sorted by fScore)\r\n  const openSet: Node[] = [startNode];\r\n  inOpenSet.set(startKey, true);\r\n\r\n  while (openSet.length > 0) {\r\n    // Sort by fScore and get node with lowest fScore\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n\r\n    const current = openSet.shift()!;\r\n    const currentKey = getKey(current);\r\n    inOpenSet.set(currentKey, false);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (current.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Check if we're trapped (no path exists)\r\n    const currentGScore = gScore.get(currentKey) ?? Infinity;\r\n    if (currentGScore === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Calculate tentative gScore (current gScore + 1 for uniform cost)\r\n      const tentativeGScore = currentGScore + 1;\r\n\r\n      // If this path is better than any previous one\r\n      const neighborGScore = gScore.get(neighborKey) ?? Infinity;\r\n      if (tentativeGScore < neighborGScore) {\r\n        // Update the path - this is the best path to this neighbor so far\r\n        neighbor.previousNode = current;\r\n        gScore.set(neighborKey, tentativeGScore);\r\n        fScore.set(neighborKey, tentativeGScore + manhattanDistance(neighbor, finishNode));\r\n\r\n        // Add to open set if not already there\r\n        if (!inOpenSet.get(neighborKey)) {\r\n          openSet.push(neighbor);\r\n          inOpenSet.set(neighborKey, true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Reuses the same logic as Dijkstra since both use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by astar)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nexport default astar;\r\n","/**\r\n * Breadth-First Search (BFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * BFS explores nodes layer by layer, guaranteeing the shortest path\r\n * in an unweighted graph (all edges have equal cost).\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Breadth-First Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize a queue with the start node\r\n * 2. Mark start node as visited\r\n * 3. While queue is not empty:\r\n *    - Dequeue the first node (FIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Get all unvisited neighbors (up, down, left, right)\r\n *    - For each neighbor:\r\n *      - Mark as visited\r\n *      - Set previousNode pointer\r\n *      - Enqueue the neighbor\r\n *      - Add to visitedNodesInOrder\r\n * 4. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path in unweighted graphs\r\n * - Explores nodes level by level (breadth-first)\r\n * - Uses a Queue (FIFO) data structure\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function bfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Queue for BFS - FIFO (First In, First Out)\r\n  const queue: Node[] = [];\r\n\r\n  // Initialize: mark start as visited and enqueue\r\n  startNode.isVisited = true;\r\n  startNode.distance = 0;\r\n  queue.push(startNode);\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  while (queue.length > 0) {\r\n    // Dequeue the first node (FIFO)\r\n    const currentNode = queue.shift()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Mark as visited\r\n      neighbor.isVisited = true;\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Set distance (optional for BFS, but useful for consistency)\r\n      neighbor.distance = currentNode.distance + 1;\r\n\r\n      // Enqueue the neighbor\r\n      queue.push(neighbor);\r\n\r\n      // Record visit order for animation\r\n      visitedNodesInOrder.push(neighbor);\r\n\r\n      // Early exit: if we just added the finish node, we can return\r\n      if (neighbor === finishNode) {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Identical to Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by bfs)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default bfs;\r\n","/**\r\n * Depth-First Search (DFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * DFS explores as far as possible along each branch before backtracking.\r\n * Unlike BFS, DFS does NOT guarantee the shortest path.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Depth-First Search to find a path (not necessarily shortest).\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps (Iterative):\r\n * 1. Initialize a stack with the start node\r\n * 2. While stack is not empty:\r\n *    - Pop the last node (LIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If already visited → skip\r\n *    - Mark as visited and add to visitedNodesInOrder\r\n *    - Get all unvisited neighbors\r\n *    - For each neighbor:\r\n *      - Set previousNode pointer\r\n *      - Push to stack\r\n * 3. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path (explores depth-first)\r\n * - Uses a Stack (LIFO) data structure\r\n * - Memory efficient for deep paths\r\n * - Creates a \"snake-like\" movement pattern\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function dfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Stack for DFS - LIFO (Last In, First Out)\r\n  const stack: Node[] = [];\r\n\r\n  // Initialize: push start node onto stack\r\n  stack.push(startNode);\r\n\r\n  while (stack.length > 0) {\r\n    // Pop the last node (LIFO)\r\n    const currentNode = stack.pop()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (currentNode.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n\r\n    // Record visit order for animation\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    // Order: Up, Right, Down, Left\r\n    // Since stack is LIFO, we push in reverse order so Up is explored first\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Skip already visited\r\n      if (neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Push to stack\r\n      stack.push(neighbor);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n * (Identical to BFS/Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by dfs)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n * Warning: For DFS, this path is NOT necessarily the shortest!\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n *\r\n * Order: Up, Right, Down, Left (reversed for stack to create consistent movement)\r\n * Since stack is LIFO, the last pushed neighbor is explored first.\r\n * We push Left, Down, Right, Up so that Up is explored first.\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Push in reverse order for LIFO stack: Left, Down, Right, Up\r\n  // This makes DFS explore in order: Up, Right, Down, Left\r\n\r\n  // Left (pushed first, explored last)\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  // Up (pushed last, explored first)\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default dfs;\r\n","/**\r\n * Greedy Best-First Search Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Greedy Best-First Search is an informed search algorithm that selects\r\n * nodes based solely on their heuristic value (estimated distance to goal).\r\n *\r\n * Key Difference from A*:\r\n * - A* uses: fScore = gScore + hScore (actual distance + estimated remaining)\r\n * - Greedy uses: fScore = hScore only (ignores actual distance traveled)\r\n *\r\n * This makes Greedy faster but does NOT guarantee the shortest path.\r\n * It's useful when you want to find \"a\" path quickly, not necessarily the best one.\r\n *\r\n * Note: Since this algorithm uses heuristics (needs to know target location),\r\n * it should be DISABLED in Hidden Target Mode.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides\r\n * the estimated distance to the goal.\r\n *\r\n * @param nodeA - Current node\r\n * @param nodeB - Target node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Greedy Best-First Search to find a path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize fScore = heuristic (distance to goal only)\r\n * 2. Add startNode to Open Set\r\n * 3. Loop while Open Set is not empty:\r\n *    - Pop node with lowest fScore (closest to goal by heuristic)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall or visited → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each unvisited neighbor:\r\n *      - Set previousNode for path reconstruction\r\n *      - Calculate fScore = heuristic only (no gScore!)\r\n *      - Add to Open Set\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path\r\n * - Very fast for simple mazes (beelines toward goal)\r\n * - Can get \"stuck\" in dead ends with complex mazes\r\n * - Explores far fewer nodes than BFS/Dijkstra in best case\r\n */\r\nexport function greedyBestFirst(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Use Map to track fScore (heuristic only)\r\n  // Key: \"row-col\", Value: heuristic score\r\n  const fScore = new Map<string, number>();\r\n  const inOpenSet = new Map<string, boolean>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node with heuristic only (no gScore)\r\n  const startKey = getKey(startNode);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n\r\n  // Open Set - nodes to be evaluated (sorted by fScore)\r\n  const openSet: Node[] = [startNode];\r\n  inOpenSet.set(startKey, true);\r\n\r\n  while (openSet.length > 0) {\r\n    // Sort by fScore (heuristic only) and get node with lowest fScore\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n\r\n    const current = openSet.shift()!;\r\n    const currentKey = getKey(current);\r\n    inOpenSet.set(currentKey, false);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (current.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Skip if already in open set (unlike A*, we don't update paths)\r\n      if (inOpenSet.get(neighborKey)) {\r\n        continue;\r\n      }\r\n\r\n      // Set the path pointer for backtracking\r\n      neighbor.previousNode = current;\r\n\r\n      // GREEDY: fScore = heuristic ONLY (no gScore!)\r\n      // This is the key difference from A*\r\n      fScore.set(neighborKey, manhattanDistance(neighbor, finishNode));\r\n\r\n      // Add to open set\r\n      openSet.push(neighbor);\r\n      inOpenSet.set(neighborKey, true);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by greedyBestFirst)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: This path is NOT guaranteed to be the shortest!\r\n * Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n","/**\r\n * Bidirectional BFS (Breadth-First Search) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional BFS searches from both the start and finish nodes simultaneously,\r\n * meeting somewhere in the middle. This can be significantly faster than\r\n * unidirectional BFS as it explores roughly half the search space.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path in unweighted graphs\r\n * - Explores from both ends simultaneously\r\n * - Meeting point detection when frontiers intersect\r\n * - Time Complexity: O(b^(d/2)) compared to O(b^d) for unidirectional\r\n *   where b = branching factor, d = depth\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// Module-level variable to store the path after algorithm runs\r\nlet reconstructedPath: Node[] = [];\r\n\r\n/**\r\n * Performs Bidirectional BFS to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited (alternating from both sides)\r\n */\r\nexport function bidirectionalBFS(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Reset the path\r\n  reconstructedPath = [];\r\n\r\n  // Parent maps for path reconstruction\r\n  const parentFromStart: Map<string, Node | null> = new Map();\r\n  const parentFromFinish: Map<string, Node | null> = new Map();\r\n\r\n  // Visited sets for each direction\r\n  const visitedFromStart: Set<string> = new Set();\r\n  const visitedFromFinish: Set<string> = new Set();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // Initialize queues\r\n  const startQueue: Node[] = [startNode];\r\n  const finishQueue: Node[] = [finishNode];\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  visitedFromStart.add(startKey);\r\n  parentFromStart.set(startKey, null);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  visitedFromFinish.add(finishKey);\r\n  parentFromFinish.set(finishKey, null);\r\n\r\n  // Track meeting point\r\n  let meetingKey: string | null = null;\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    // Up\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    // Down\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    // Left\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    // Right\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  // Main loop - alternate between expanding from start and finish\r\n  while (startQueue.length > 0 && finishQueue.length > 0) {\r\n    // Expand from start side\r\n    if (startQueue.length > 0) {\r\n      const currentNode = startQueue.shift()!;\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from start\r\n        if (visitedFromStart.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from start\r\n        visitedFromStart.add(neighborKey);\r\n        parentFromStart.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from finish - INTERSECTION!\r\n        if (visitedFromFinish.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        startQueue.push(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n\r\n    // Expand from finish side\r\n    if (finishQueue.length > 0 && !meetingKey) {\r\n      const currentNode = finishQueue.shift()!;\r\n\r\n      // Add finish node to visited order on first expansion\r\n      if (currentNode === finishNode) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from finish\r\n        if (visitedFromFinish.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from finish\r\n        visitedFromFinish.add(neighborKey);\r\n        parentFromFinish.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from start - INTERSECTION!\r\n        if (visitedFromStart.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        finishQueue.push(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n  }\r\n\r\n  // Reconstruct path if meeting point found\r\n  if (meetingKey) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine paths\r\n    reconstructedPath = [...pathFromStart, ...pathToFinish];\r\n\r\n    // Set up previousNode chain for the path (for compatibility with animation)\r\n    for (let i = 1; i < reconstructedPath.length; i++) {\r\n      reconstructedPath[i].previousNode = reconstructedPath[i - 1];\r\n    }\r\n\r\n    // Mark finish as having a valid path\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalBFS.\r\n * Must be called after bidirectionalBFS has run.\r\n *\r\n * @param finishNode - The destination node (used for compatibility, actual path stored internally)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  // If we have a reconstructed path from bidirectional search, use it\r\n  if (reconstructedPath.length > 0) {\r\n    return reconstructedPath;\r\n  }\r\n\r\n  // Fallback: standard path reconstruction via previousNode chain\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Bidirectional A* (A-Star) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional A* combines the efficiency of A* heuristic search with\r\n * bidirectional search strategy. It searches from both start and finish\r\n * nodes simultaneously, using heuristics from both ends.\r\n *\r\n * Key Characteristics:\r\n * - Uses priority queues (Open Sets) sorted by fScore for both directions\r\n * - Two heuristics: startOpenSet → finishNode, finishOpenSet → startNode\r\n * - Meeting point detection when frontiers intersect\r\n * - Guarantees shortest path in graphs with consistent heuristics\r\n * - Can be significantly faster than unidirectional A*\r\n *\r\n * Time Complexity: O(b^(d/2)) compared to O(b^d) for unidirectional A*\r\n * where b = branching factor, d = depth\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// Module-level variable to store the path after algorithm runs\r\nlet reconstructedPath: Node[] = [];\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides an\r\n * admissible heuristic (never overestimates the actual cost).\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Bidirectional A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited (alternating from both sides)\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize two Open Sets (priority queues) - one from start, one from finish\r\n * 2. Each side uses gScore (distance from origin) and fScore (gScore + heuristic)\r\n * 3. Loop while both Open Sets are not empty:\r\n *    - Expand from start side: pop lowest fScore, check for intersection\r\n *    - Expand from finish side: pop lowest fScore, check for intersection\r\n * 4. When frontiers meet, reconstruct path through meeting point\r\n */\r\nexport function bidirectionalAStar(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Reset the path\r\n  reconstructedPath = [];\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // === START SIDE DATA STRUCTURES ===\r\n  // gScore: distance from startNode\r\n  // fScore: gScore + heuristic to finishNode\r\n  const gScoreStart = new Map<string, number>();\r\n  const fScoreStart = new Map<string, number>();\r\n  const parentFromStart = new Map<string, Node | null>();\r\n  const visitedFromStart = new Set<string>();\r\n  const inOpenSetStart = new Map<string, boolean>();\r\n  const openSetStart: Node[] = [];\r\n\r\n  // === FINISH SIDE DATA STRUCTURES ===\r\n  // gScore: distance from finishNode\r\n  // fScore: gScore + heuristic to startNode\r\n  const gScoreFinish = new Map<string, number>();\r\n  const fScoreFinish = new Map<string, number>();\r\n  const parentFromFinish = new Map<string, Node | null>();\r\n  const visitedFromFinish = new Set<string>();\r\n  const inOpenSetFinish = new Map<string, boolean>();\r\n  const openSetFinish: Node[] = [];\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScoreStart.set(key, Infinity);\r\n      fScoreStart.set(key, Infinity);\r\n      gScoreFinish.set(key, Infinity);\r\n      fScoreFinish.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScoreStart.set(startKey, 0);\r\n  fScoreStart.set(startKey, manhattanDistance(startNode, finishNode));\r\n  parentFromStart.set(startKey, null);\r\n  openSetStart.push(startNode);\r\n  inOpenSetStart.set(startKey, true);\r\n  visitedFromStart.add(startKey);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  gScoreFinish.set(finishKey, 0);\r\n  fScoreFinish.set(finishKey, manhattanDistance(finishNode, startNode));\r\n  parentFromFinish.set(finishKey, null);\r\n  openSetFinish.push(finishNode);\r\n  inOpenSetFinish.set(finishKey, true);\r\n  visitedFromFinish.add(finishKey);\r\n\r\n  // Track meeting point\r\n  let meetingKey: string | null = null;\r\n  let bestPathCost = Infinity;\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    // Up\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    // Down\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    // Left\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    // Right\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  /**\r\n   * Sort and pop the node with lowest fScore from an open set\r\n   */\r\n  const popLowestFScore = (\r\n    openSet: Node[],\r\n    fScore: Map<string, number>\r\n  ): Node | undefined => {\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n    return openSet.shift();\r\n  };\r\n\r\n  // Main loop - alternate between expanding from start and finish\r\n  while (openSetStart.length > 0 && openSetFinish.length > 0) {\r\n    // === EXPAND FROM START SIDE ===\r\n    if (openSetStart.length > 0) {\r\n      const current = popLowestFScore(openSetStart, fScoreStart);\r\n      if (!current) break;\r\n\r\n      const currentKey = getKey(current);\r\n      inOpenSetStart.set(currentKey, false);\r\n\r\n      // Skip walls\r\n      if (current.isWall) continue;\r\n\r\n      // Check for intersection - has finish side visited this node?\r\n      if (visitedFromFinish.has(currentKey)) {\r\n        // Calculate total path cost through this meeting point\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip already fully processed nodes\r\n        if (\r\n          visitedFromStart.has(neighborKey) &&\r\n          !inOpenSetStart.get(neighborKey)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        const tentativeGScore = (gScoreStart.get(currentKey) ?? Infinity) + 1;\r\n        const neighborGScore = gScoreStart.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          // Found a better path\r\n          parentFromStart.set(neighborKey, current);\r\n          gScoreStart.set(neighborKey, tentativeGScore);\r\n          fScoreStart.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, finishNode)\r\n          );\r\n\r\n          if (!inOpenSetStart.get(neighborKey)) {\r\n            openSetStart.push(neighbor);\r\n            inOpenSetStart.set(neighborKey, true);\r\n          }\r\n\r\n          // Add to visited order for animation (if not already visited from start)\r\n          if (!visitedFromStart.has(neighborKey)) {\r\n            visitedFromStart.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check if this creates a better meeting point\r\n            if (visitedFromFinish.has(neighborKey)) {\r\n              const pathCost =\r\n                tentativeGScore + (gScoreFinish.get(neighborKey) ?? Infinity);\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // === EXPAND FROM FINISH SIDE ===\r\n    if (openSetFinish.length > 0) {\r\n      const current = popLowestFScore(openSetFinish, fScoreFinish);\r\n      if (!current) break;\r\n\r\n      const currentKey = getKey(current);\r\n      inOpenSetFinish.set(currentKey, false);\r\n\r\n      // Skip walls\r\n      if (current.isWall) continue;\r\n\r\n      // Add finish node to visited order on first expansion\r\n      if (current === finishNode && !visitedNodesInOrder.includes(finishNode)) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      // Check for intersection - has start side visited this node?\r\n      if (visitedFromStart.has(currentKey)) {\r\n        // Calculate total path cost through this meeting point\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip already fully processed nodes\r\n        if (\r\n          visitedFromFinish.has(neighborKey) &&\r\n          !inOpenSetFinish.get(neighborKey)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        const tentativeGScore = (gScoreFinish.get(currentKey) ?? Infinity) + 1;\r\n        const neighborGScore = gScoreFinish.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          // Found a better path\r\n          parentFromFinish.set(neighborKey, current);\r\n          gScoreFinish.set(neighborKey, tentativeGScore);\r\n          fScoreFinish.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, startNode)\r\n          );\r\n\r\n          if (!inOpenSetFinish.get(neighborKey)) {\r\n            openSetFinish.push(neighbor);\r\n            inOpenSetFinish.set(neighborKey, true);\r\n          }\r\n\r\n          // Add to visited order for animation (if not already visited from finish)\r\n          if (!visitedFromFinish.has(neighborKey)) {\r\n            visitedFromFinish.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check if this creates a better meeting point\r\n            if (visitedFromStart.has(neighborKey)) {\r\n              const pathCost =\r\n                (gScoreStart.get(neighborKey) ?? Infinity) + tentativeGScore;\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Early termination: if both sides have exhausted their frontiers near the meeting point\r\n    // We use a simple heuristic: if the sum of minimum fScores exceeds best path cost, we're done\r\n    if (\r\n      meetingKey !== null &&\r\n      openSetStart.length > 0 &&\r\n      openSetFinish.length > 0\r\n    ) {\r\n      const minFStart = fScoreStart.get(getKey(openSetStart[0])) ?? Infinity;\r\n      const minFFinish = fScoreFinish.get(getKey(openSetFinish[0])) ?? Infinity;\r\n\r\n      // If the minimum possible path through remaining nodes is worse than our best, stop\r\n      if (minFStart + minFFinish >= bestPathCost) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reconstruct path if meeting point found\r\n  if (meetingKey !== null) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine paths\r\n    reconstructedPath = [...pathFromStart, ...pathToFinish];\r\n\r\n    // Set up previousNode chain for the path (for compatibility with animation)\r\n    for (let i = 1; i < reconstructedPath.length; i++) {\r\n      reconstructedPath[i].previousNode = reconstructedPath[i - 1];\r\n    }\r\n\r\n    // Mark finish as having a valid path\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalAStar.\r\n * Must be called after bidirectionalAStar has run.\r\n *\r\n * @param finishNode - The destination node (used for compatibility, actual path stored internally)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  // If we have a reconstructed path from bidirectional search, use it\r\n  if (reconstructedPath.length > 0) {\r\n    return reconstructedPath;\r\n  }\r\n\r\n  // Fallback: standard path reconstruction via previousNode chain\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Jump Point Search (JPS) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Jump Point Search is an optimization over A* for uniform-cost grids.\r\n * It dramatically reduces the number of nodes that need to be examined\r\n * by \"jumping\" over intermediate nodes in straight lines and only\r\n * considering nodes that are \"forced neighbors\" or corner points.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path (same as A*)\r\n * - Only works on uniform-cost grids (all edge weights equal)\r\n * - Exploits grid structure to skip intermediate nodes\r\n * - Typically 10-100x faster than A* in open spaces\r\n * - Falls back to A*-like behavior in dense obstacle environments\r\n *\r\n * Note: This implementation is for 4-directional movement (cardinal only).\r\n * For 8-directional (with diagonals), the forced neighbor rules differ.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Direction vectors for 4-directional movement\r\n * [row delta, col delta]\r\n */\r\nconst DIRECTIONS: [number, number][] = [\r\n  [-1, 0], // Up\r\n  [1, 0], // Down\r\n  [0, -1], // Left\r\n  [0, 1], // Right\r\n];\r\n\r\n/**\r\n * Performs Jump Point Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n */\r\nexport function jumpPointSearch(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Helper to get node key\r\n  const getKey = (row: number, col: number): string => `${row}-${col}`;\r\n\r\n  // Check if a position is valid and not a wall\r\n  const isWalkable = (row: number, col: number): boolean => {\r\n    if (row < 0 || row >= numRows || col < 0 || col >= numCols) return false;\r\n    return !grid[row][col].isWall;\r\n  };\r\n\r\n  // Use Maps to track scores\r\n  const gScore = new Map<string, number>();\r\n  const fScore = new Map<string, number>();\r\n  const cameFrom = new Map<string, string | null>();\r\n  const inOpenSet = new Map<string, boolean>();\r\n\r\n  // Initialize all with Infinity\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node.row, node.col);\r\n      gScore.set(key, Infinity);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode.row, startNode.col);\r\n  gScore.set(startKey, 0);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n  cameFrom.set(startKey, null);\r\n\r\n  // Open set with direction info: [row, col, dirRow, dirCol]\r\n  // Direction is used to determine which neighbors to explore\r\n  const openSet: {\r\n    row: number;\r\n    col: number;\r\n    dirRow: number;\r\n    dirCol: number;\r\n  }[] = [];\r\n\r\n  // Add start node with all directions (no parent direction)\r\n  openSet.push({\r\n    row: startNode.row,\r\n    col: startNode.col,\r\n    dirRow: 0,\r\n    dirCol: 0,\r\n  });\r\n  inOpenSet.set(startKey, true);\r\n\r\n  /**\r\n   * Jump function - the core of JPS\r\n   * Recursively jumps in a direction until it finds:\r\n   * 1. The goal node\r\n   * 2. A jump point (forced neighbor exists)\r\n   * 3. A wall or boundary (returns null)\r\n   */\r\n  const jump = (\r\n    row: number,\r\n    col: number,\r\n    dirRow: number,\r\n    dirCol: number\r\n  ): { row: number; col: number } | null => {\r\n    const nextRow = row + dirRow;\r\n    const nextCol = col + dirCol;\r\n\r\n    // Hit wall or boundary\r\n    if (!isWalkable(nextRow, nextCol)) {\r\n      return null;\r\n    }\r\n\r\n    // Found the goal!\r\n    if (nextRow === finishNode.row && nextCol === finishNode.col) {\r\n      return { row: nextRow, col: nextCol };\r\n    }\r\n\r\n    // Check for forced neighbors (4-directional rules)\r\n    // A forced neighbor exists when there's a wall adjacent to the path\r\n    // that creates a shorter path through the current node\r\n\r\n    // Horizontal movement (dirRow === 0)\r\n    if (dirRow === 0) {\r\n      // Check for forced neighbors above and below\r\n      // If there's a wall above/below and walkable diagonal, it's a jump point\r\n      if (\r\n        (!isWalkable(nextRow - 1, nextCol - dirCol) &&\r\n          isWalkable(nextRow - 1, nextCol)) ||\r\n        (!isWalkable(nextRow + 1, nextCol - dirCol) &&\r\n          isWalkable(nextRow + 1, nextCol))\r\n      ) {\r\n        return { row: nextRow, col: nextCol };\r\n      }\r\n    }\r\n\r\n    // Vertical movement (dirCol === 0)\r\n    if (dirCol === 0) {\r\n      // Check for forced neighbors left and right\r\n      if (\r\n        (!isWalkable(nextRow - dirRow, nextCol - 1) &&\r\n          isWalkable(nextRow, nextCol - 1)) ||\r\n        (!isWalkable(nextRow - dirRow, nextCol + 1) &&\r\n          isWalkable(nextRow, nextCol + 1))\r\n      ) {\r\n        return { row: nextRow, col: nextCol };\r\n      }\r\n    }\r\n\r\n    // Continue jumping in the same direction\r\n    return jump(nextRow, nextCol, dirRow, dirCol);\r\n  };\r\n\r\n  /**\r\n   * Identify successors (jump points) from a node\r\n   */\r\n  const identifySuccessors = (\r\n    row: number,\r\n    col: number,\r\n    parentDirRow: number,\r\n    parentDirCol: number\r\n  ): { row: number; col: number }[] => {\r\n    const successors: { row: number; col: number }[] = [];\r\n\r\n    // Determine which directions to explore based on parent direction\r\n    let directionsToCheck: [number, number][];\r\n\r\n    if (parentDirRow === 0 && parentDirCol === 0) {\r\n      // Start node - check all directions\r\n      directionsToCheck = DIRECTIONS;\r\n    } else if (parentDirRow === 0) {\r\n      // Horizontal movement - continue horizontal + check perpendicular if forced\r\n      directionsToCheck = [[0, parentDirCol]]; // Continue in same direction\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - 1, col - parentDirCol) &&\r\n        isWalkable(row - 1, col)\r\n      ) {\r\n        directionsToCheck.push([-1, 0]);\r\n      }\r\n      if (\r\n        !isWalkable(row + 1, col - parentDirCol) &&\r\n        isWalkable(row + 1, col)\r\n      ) {\r\n        directionsToCheck.push([1, 0]);\r\n      }\r\n    } else {\r\n      // Vertical movement - continue vertical + check perpendicular if forced\r\n      directionsToCheck = [[parentDirRow, 0]]; // Continue in same direction\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - parentDirRow, col - 1) &&\r\n        isWalkable(row, col - 1)\r\n      ) {\r\n        directionsToCheck.push([0, -1]);\r\n      }\r\n      if (\r\n        !isWalkable(row - parentDirRow, col + 1) &&\r\n        isWalkable(row, col + 1)\r\n      ) {\r\n        directionsToCheck.push([0, 1]);\r\n      }\r\n    }\r\n\r\n    // Jump in each valid direction\r\n    for (const [dRow, dCol] of directionsToCheck) {\r\n      const jumpPoint = jump(row, col, dRow, dCol);\r\n      if (jumpPoint) {\r\n        successors.push(jumpPoint);\r\n      }\r\n    }\r\n\r\n    return successors;\r\n  };\r\n\r\n  // Main loop\r\n  while (openSet.length > 0) {\r\n    // Sort by fScore and get lowest\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a.row, a.col)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b.row, b.col)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n\r\n    const current = openSet.shift()!;\r\n    const currentKey = getKey(current.row, current.col);\r\n    const currentNode = grid[current.row][current.col];\r\n\r\n    inOpenSet.set(currentKey, false);\r\n\r\n    // Skip if already visited\r\n    if (currentNode.isVisited) continue;\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // Found the goal!\r\n    if (current.row === finishNode.row && current.col === finishNode.col) {\r\n      // Reconstruct path using previousNode pointers\r\n      reconstructPath(grid, cameFrom, startNode, finishNode);\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get successors (jump points)\r\n    const successors = identifySuccessors(\r\n      current.row,\r\n      current.col,\r\n      current.dirRow,\r\n      current.dirCol\r\n    );\r\n\r\n    for (const successor of successors) {\r\n      const successorKey = getKey(successor.row, successor.col);\r\n      const successorNode = grid[successor.row][successor.col];\r\n\r\n      if (successorNode.isVisited) continue;\r\n\r\n      // Calculate tentative gScore (actual distance, not just 1)\r\n      const tentativeGScore =\r\n        (gScore.get(currentKey) ?? Infinity) +\r\n        manhattanDistance(currentNode, successorNode);\r\n\r\n      if (tentativeGScore < (gScore.get(successorKey) ?? Infinity)) {\r\n        // Found a better path\r\n        cameFrom.set(successorKey, currentKey);\r\n        gScore.set(successorKey, tentativeGScore);\r\n        fScore.set(\r\n          successorKey,\r\n          tentativeGScore + manhattanDistance(successorNode, finishNode)\r\n        );\r\n\r\n        // Calculate direction from current to successor\r\n        const dirRow =\r\n          successor.row === current.row\r\n            ? 0\r\n            : successor.row > current.row\r\n            ? 1\r\n            : -1;\r\n        const dirCol =\r\n          successor.col === current.col\r\n            ? 0\r\n            : successor.col > current.col\r\n            ? 1\r\n            : -1;\r\n\r\n        if (!inOpenSet.get(successorKey)) {\r\n          openSet.push({\r\n            row: successor.row,\r\n            col: successor.col,\r\n            dirRow,\r\n            dirCol,\r\n          });\r\n          inOpenSet.set(successorKey, true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Reconstructs the path by setting previousNode pointers\r\n * JPS jumps over nodes, so we need to fill in the gaps\r\n */\r\nfunction reconstructPath(\r\n  grid: Grid,\r\n  cameFrom: Map<string, string | null>,\r\n  _startNode: Node,\r\n  finishNode: Node\r\n): void {\r\n  const path: Node[] = [];\r\n  let currentKey: string | null = `${finishNode.row}-${finishNode.col}`;\r\n\r\n  // Collect jump points from finish to start\r\n  const jumpPoints: Node[] = [];\r\n  while (currentKey !== null) {\r\n    const [row, col] = currentKey.split(\"-\").map(Number);\r\n    jumpPoints.unshift(grid[row][col]);\r\n    currentKey = cameFrom.get(currentKey) ?? null;\r\n  }\r\n\r\n  // Fill in intermediate nodes between jump points\r\n  for (let i = 0; i < jumpPoints.length - 1; i++) {\r\n    const from = jumpPoints[i];\r\n    const to = jumpPoints[i + 1];\r\n\r\n    // Add intermediate nodes\r\n    let currentRow = from.row;\r\n    let currentCol = from.col;\r\n\r\n    while (currentRow !== to.row || currentCol !== to.col) {\r\n      const node = grid[currentRow][currentCol];\r\n      if (path.length > 0) {\r\n        node.previousNode = path[path.length - 1];\r\n      }\r\n      path.push(node);\r\n\r\n      // Move towards target\r\n      if (currentRow < to.row) currentRow++;\r\n      else if (currentRow > to.row) currentRow--;\r\n      else if (currentCol < to.col) currentCol++;\r\n      else if (currentCol > to.col) currentCol--;\r\n    }\r\n  }\r\n\r\n  // Add the finish node\r\n  if (jumpPoints.length > 0) {\r\n    finishNode.previousNode = path.length > 0 ? path[path.length - 1] : null;\r\n    path.push(finishNode);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by Jump Point Search.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Recursive Division Maze Generation Algorithm\r\n * Phase C: Maze Generation\r\n *\r\n * This algorithm creates a maze by recursively dividing the grid into chambers\r\n * and adding walls with gaps to ensure a solvable path.\r\n *\r\n * Key Concepts:\r\n * - Start with empty grid (no walls)\r\n * - Recursively divide into smaller chambers\r\n * - Each division adds a wall with exactly one gap\r\n * - Orientation based on chamber dimensions (height > width = horizontal)\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Orientation enum for wall placement\r\n */\r\nenum Orientation {\r\n  HORIZONTAL = 'horizontal',\r\n  VERTICAL = 'vertical',\r\n}\r\n\r\n/**\r\n * Main function to generate a Recursive Division maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must not be overwritten)\r\n * @param finishNode - The finish node (must not be overwritten)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getRecursiveDivisionMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const wallsInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Start recursive division on the full grid (no border walls)\r\n  divide(\r\n    grid,\r\n    0, // startRow (full grid)\r\n    numRows - 1, // endRow (full grid)\r\n    0, // startCol (full grid)\r\n    numCols - 1, // endCol (full grid)\r\n    chooseOrientation(numRows, numCols),\r\n    wallsInOrder,\r\n    startNode,\r\n    finishNode\r\n  );\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Recursive division function\r\n * Divides a chamber by adding a wall with a gap\r\n */\r\nfunction divide(\r\n  grid: Grid,\r\n  startRow: number,\r\n  endRow: number,\r\n  startCol: number,\r\n  endCol: number,\r\n  orientation: Orientation,\r\n  wallsInOrder: Node[],\r\n  startNode: Node,\r\n  finishNode: Node\r\n): void {\r\n  // Calculate chamber dimensions\r\n  const height = endRow - startRow + 1;\r\n  const width = endCol - startCol + 1;\r\n\r\n  // Base case: chamber too small to divide\r\n  if (height < 3 || width < 3) {\r\n    return;\r\n  }\r\n\r\n  // Choose where to place the wall and the gap\r\n  if (orientation === Orientation.HORIZONTAL) {\r\n    // Horizontal wall - pick a row (must be even to align with passages)\r\n    const possibleRows = getEvenNumbers(startRow + 1, endRow - 1);\r\n    if (possibleRows.length === 0) return;\r\n\r\n    const wallRow = possibleRows[Math.floor(Math.random() * possibleRows.length)];\r\n\r\n    // Pick a gap position (must be odd to align with passages)\r\n    const possibleGaps = getOddNumbers(startCol, endCol);\r\n    if (possibleGaps.length === 0) return;\r\n\r\n    const gapCol = possibleGaps[Math.floor(Math.random() * possibleGaps.length)];\r\n\r\n    // Build the wall with a gap\r\n    for (let col = startCol; col <= endCol; col++) {\r\n      if (col === gapCol) continue; // Leave the gap\r\n      if (isStartOrFinish(wallRow, col, startNode, finishNode)) continue;\r\n\r\n      wallsInOrder.push(grid[wallRow][col]);\r\n    }\r\n\r\n    // Recursively divide the two new chambers\r\n    // Top chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      wallRow - 1,\r\n      startCol,\r\n      endCol,\r\n      chooseOrientation(wallRow - 1 - startRow + 1, width),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n\r\n    // Bottom chamber\r\n    divide(\r\n      grid,\r\n      wallRow + 1,\r\n      endRow,\r\n      startCol,\r\n      endCol,\r\n      chooseOrientation(endRow - (wallRow + 1) + 1, width),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  } else {\r\n    // Vertical wall - pick a column (must be even to align with passages)\r\n    const possibleCols = getEvenNumbers(startCol + 1, endCol - 1);\r\n    if (possibleCols.length === 0) return;\r\n\r\n    const wallCol = possibleCols[Math.floor(Math.random() * possibleCols.length)];\r\n\r\n    // Pick a gap position (must be odd to align with passages)\r\n    const possibleGaps = getOddNumbers(startRow, endRow);\r\n    if (possibleGaps.length === 0) return;\r\n\r\n    const gapRow = possibleGaps[Math.floor(Math.random() * possibleGaps.length)];\r\n\r\n    // Build the wall with a gap\r\n    for (let row = startRow; row <= endRow; row++) {\r\n      if (row === gapRow) continue; // Leave the gap\r\n      if (isStartOrFinish(row, wallCol, startNode, finishNode)) continue;\r\n\r\n      wallsInOrder.push(grid[row][wallCol]);\r\n    }\r\n\r\n    // Recursively divide the two new chambers\r\n    // Left chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      endRow,\r\n      startCol,\r\n      wallCol - 1,\r\n      chooseOrientation(height, wallCol - 1 - startCol + 1),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n\r\n    // Right chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      endRow,\r\n      wallCol + 1,\r\n      endCol,\r\n      chooseOrientation(height, endCol - (wallCol + 1) + 1),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Chooses wall orientation based on chamber dimensions\r\n * Prefers to divide along the longer axis\r\n */\r\nfunction chooseOrientation(height: number, width: number): Orientation {\r\n  if (height > width) {\r\n    return Orientation.HORIZONTAL;\r\n  } else if (width > height) {\r\n    return Orientation.VERTICAL;\r\n  } else {\r\n    // Square chamber - random choice\r\n    return Math.random() < 0.5 ? Orientation.HORIZONTAL : Orientation.VERTICAL;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets all even numbers in a range (inclusive)\r\n */\r\nfunction getEvenNumbers(start: number, end: number): number[] {\r\n  const result: number[] = [];\r\n  for (let i = start; i <= end; i++) {\r\n    if (i % 2 === 0) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Gets all odd numbers in a range (inclusive)\r\n */\r\nfunction getOddNumbers(start: number, end: number): number[] {\r\n  const result: number[] = [];\r\n  for (let i = start; i <= end; i++) {\r\n    if (i % 2 !== 0) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks if a position is the start or finish node\r\n */\r\nfunction isStartOrFinish(\r\n  row: number,\r\n  col: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean {\r\n  return (\r\n    (row === startNode.row && col === startNode.col) ||\r\n    (row === finishNode.row && col === finishNode.col)\r\n  );\r\n}\r\n\r\nexport default getRecursiveDivisionMaze;\r\n","/**\r\n * Randomized DFS (Recursive Backtracker) Maze Generation Algorithm\r\n * Phase C: Maze Generation\r\n *\r\n * This algorithm creates a maze by \"carving\" passages through a grid of walls.\r\n * It uses depth-first search with random neighbor selection to create\r\n * organic, winding passages with long corridors.\r\n *\r\n * Key Concepts:\r\n * - Start with a grid conceptually full of walls\r\n * - Carve passages using DFS with random neighbor order\r\n * - Each step moves 2 cells to leave room for walls between passages\r\n * - Results in a \"perfect maze\" (exactly one path between any two points)\r\n *\r\n * Output: Returns array of wall nodes for animation (inverse of carved passages)\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Tracks which cells have been visited during maze generation\r\n * true = passage (carved), false = wall (uncarved)\r\n */\r\ntype VisitedGrid = boolean[][];\r\n\r\n/**\r\n * Main function to generate a Randomized DFS maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain accessible)\r\n * @param finishNode - The finish node (must remain accessible)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getRandomizedDFSMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Initialize visited grid - all false (all walls)\r\n  const visited: VisitedGrid = Array.from({ length: numRows }, () =>\r\n    Array(numCols).fill(false)\r\n  );\r\n\r\n  // Track the order of carved passages (for potential future use)\r\n  const passagesInOrder: Node[] = [];\r\n\r\n  // Start carving from position (0, 0) - full grid without border\r\n  const startRow = 0;\r\n  const startCol = 0;\r\n\r\n  // Carve the maze using recursive DFS\r\n  carve(grid, startRow, startCol, visited, passagesInOrder);\r\n\r\n  // Ensure start and finish nodes are passages (not walls)\r\n  ensureAccessible(grid, startNode, visited);\r\n  ensureAccessible(grid, finishNode, visited);\r\n\r\n  // Build the walls array - all non-passage cells become walls\r\n  const wallsInOrder: Node[] = [];\r\n\r\n  // Add all walls (cells that weren't carved as passages) - no border frame\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      if (!visited[row][col]) {\r\n        // This cell is a wall (not carved)\r\n        if (!isStartOrFinish(row, col, startNode, finishNode)) {\r\n          wallsInOrder.push(grid[row][col]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Recursive carving function using DFS\r\n * Carves passages by visiting cells 2 steps apart\r\n */\r\nfunction carve(\r\n  grid: Grid,\r\n  row: number,\r\n  col: number,\r\n  visited: VisitedGrid,\r\n  passagesInOrder: Node[]\r\n): void {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Mark current cell as passage\r\n  visited[row][col] = true;\r\n  passagesInOrder.push(grid[row][col]);\r\n\r\n  // Get neighbors 2 cells away (to leave room for walls)\r\n  const neighbors = getUnvisitedNeighbors(row, col, numRows, numCols, visited);\r\n\r\n  // Shuffle neighbors for randomness\r\n  shuffleArray(neighbors);\r\n\r\n  // Visit each neighbor\r\n  for (const neighbor of neighbors) {\r\n    const [nextRow, nextCol] = neighbor;\r\n\r\n    // Check if still unvisited (might have been visited from another path)\r\n    if (!visited[nextRow][nextCol]) {\r\n      // Carve the wall between current and neighbor\r\n      const wallRow = row + (nextRow - row) / 2;\r\n      const wallCol = col + (nextCol - col) / 2;\r\n      visited[wallRow][wallCol] = true;\r\n      passagesInOrder.push(grid[wallRow][wallCol]);\r\n\r\n      // Recursively carve from neighbor\r\n      carve(grid, nextRow, nextCol, visited, passagesInOrder);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gets unvisited neighbors 2 cells away\r\n * Used to ensure walls remain between passages\r\n */\r\nfunction getUnvisitedNeighbors(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  visited: VisitedGrid\r\n): [number, number][] {\r\n  const neighbors: [number, number][] = [];\r\n\r\n  // Check 2 cells in each direction\r\n  const directions: [number, number][] = [\r\n    [-2, 0], // Up\r\n    [2, 0],  // Down\r\n    [0, -2], // Left\r\n    [0, 2],  // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = row + dRow;\r\n    const newCol = col + dCol;\r\n\r\n    // Check bounds (allow full grid edges)\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      if (!visited[newRow][newCol]) {\r\n        neighbors.push([newRow, newCol]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\n/**\r\n * Fisher-Yates shuffle algorithm\r\n * Randomizes the order of neighbors for maze variety\r\n */\r\nfunction shuffleArray<T>(array: T[]): void {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n}\r\n\r\n/**\r\n * Ensures a specific node and its surroundings are accessible (not walls)\r\n * Creates a small clearing around start/finish nodes\r\n */\r\nfunction ensureAccessible(\r\n  grid: Grid,\r\n  node: Node,\r\n  visited: VisitedGrid\r\n): void {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Mark the node itself as passage\r\n  visited[node.row][node.col] = true;\r\n\r\n  // Also clear adjacent cells to ensure connectivity\r\n  const directions: [number, number][] = [\r\n    [-1, 0], // Up\r\n    [1, 0],  // Down\r\n    [0, -1], // Left\r\n    [0, 1],  // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = node.row + dRow;\r\n    const newCol = node.col + dCol;\r\n\r\n    // Allow clearing cells at edges (full grid bounds)\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      visited[newRow][newCol] = true;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a position is the start or finish node\r\n */\r\nfunction isStartOrFinish(\r\n  row: number,\r\n  col: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean {\r\n  return (\r\n    (row === startNode.row && col === startNode.col) ||\r\n    (row === finishNode.row && col === finishNode.col)\r\n  );\r\n}\r\n\r\nexport default getRandomizedDFSMaze;\r\n","/**\r\n * Prim's Maze Generation Algorithm (Randomized)\r\n * Phase F: Extensions & History\r\n *\r\n * Creates a maze using a randomized version of Prim's minimum spanning tree algorithm.\r\n * Unlike Recursive Division (which starts empty and adds walls), Prim's starts with\r\n * ALL walls and carves passages.\r\n *\r\n * Key Characteristics:\r\n * - Produces \"organic\" looking mazes with many dead ends\r\n * - Different feel from Recursive Division (more cave-like, less structured)\r\n * - Guaranteed to create a perfect maze (exactly one path between any two cells)\r\n *\r\n * Algorithm (Randomized Prim's):\r\n * 1. Start with a grid full of walls\r\n * 2. Pick a starting cell, mark it as a passage\r\n * 3. Add its wall neighbors to a \"frontier\" list\r\n * 4. While frontier is not empty:\r\n *    a. Pick a random cell from the frontier\r\n *    b. Find its neighbors that are already passages\r\n *    c. Connect to ONE random passage neighbor (carve the wall between them)\r\n *    d. Mark the frontier cell as a passage\r\n *    e. Add the frontier cell's wall neighbors to the frontier\r\n * 5. Ensure start and finish nodes are passages\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Main function to generate a Prim's maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain open)\r\n * @param finishNode - The finish node (must remain open)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getPrimsMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Create a passage map: true = passage, false = wall\r\n  // We'll use this to track the maze state during generation\r\n  const isPassage: boolean[][] = Array.from({ length: numRows }, () =>\r\n    Array(numCols).fill(false)\r\n  );\r\n\r\n  // Set to track cells in frontier\r\n  const inFrontier = new Set<string>();\r\n\r\n  // Frontier list - cells to potentially become passages\r\n  const frontier: [number, number][] = [];\r\n\r\n  // Helper to get cell key\r\n  const getKey = (row: number, col: number): string => `${row}-${col}`;\r\n\r\n  // Start position - use a cell near the start node\r\n  // Using odd coordinates ensures proper maze structure\r\n  const startRow = Math.max(1, Math.min(numRows - 2, startNode.row | 1)); // Ensure odd\r\n  const startCol = Math.max(1, Math.min(numCols - 2, startNode.col | 1)); // Ensure odd\r\n\r\n  // Mark starting cell as passage\r\n  isPassage[startRow][startCol] = true;\r\n\r\n  // Add initial frontier cells (neighbors 2 steps away, within bounds)\r\n  addFrontier(\r\n    startRow,\r\n    startCol,\r\n    numRows,\r\n    numCols,\r\n    isPassage,\r\n    frontier,\r\n    inFrontier\r\n  );\r\n\r\n  // Main loop - process frontier cells\r\n  while (frontier.length > 0) {\r\n    // Pick a random cell from the frontier\r\n    const randomIndex = Math.floor(Math.random() * frontier.length);\r\n    const [row, col] = frontier[randomIndex];\r\n\r\n    // Remove from frontier\r\n    frontier.splice(randomIndex, 1);\r\n    inFrontier.delete(getKey(row, col));\r\n\r\n    // Skip if already a passage (can happen due to multiple additions)\r\n    if (isPassage[row][col]) {\r\n      continue;\r\n    }\r\n\r\n    // Find passage neighbors (cells 2 steps away that are passages)\r\n    const passageNeighbors = getPassageNeighbors(\r\n      row,\r\n      col,\r\n      numRows,\r\n      numCols,\r\n      isPassage\r\n    );\r\n\r\n    if (passageNeighbors.length > 0) {\r\n      // Pick a random passage neighbor to connect to\r\n      const [neighborRow, neighborCol] =\r\n        passageNeighbors[Math.floor(Math.random() * passageNeighbors.length)];\r\n\r\n      // Carve passage: mark current cell as passage\r\n      isPassage[row][col] = true;\r\n\r\n      // Carve the wall between current cell and the passage neighbor\r\n      const wallRow = (row + neighborRow) / 2;\r\n      const wallCol = (col + neighborCol) / 2;\r\n      isPassage[wallRow][wallCol] = true;\r\n\r\n      // Add new frontier cells from this newly opened cell\r\n      addFrontier(row, col, numRows, numCols, isPassage, frontier, inFrontier);\r\n    }\r\n  }\r\n\r\n  // Ensure start and finish nodes are passages\r\n  ensureNodeIsPassage(startNode, isPassage, numRows, numCols);\r\n  ensureNodeIsPassage(finishNode, isPassage, numRows, numCols);\r\n\r\n  // Ensure path from start to nearest passage\r\n  connectToNearestPassage(\r\n    startNode.row,\r\n    startNode.col,\r\n    isPassage,\r\n    numRows,\r\n    numCols\r\n  );\r\n  connectToNearestPassage(\r\n    finishNode.row,\r\n    finishNode.col,\r\n    isPassage,\r\n    numRows,\r\n    numCols\r\n  );\r\n\r\n  // Convert passage map to walls list for animation\r\n  // Walls are cells where isPassage is false\r\n  const wallsInOrder: Node[] = [];\r\n\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      // Skip start and finish nodes\r\n      if (\r\n        (row === startNode.row && col === startNode.col) ||\r\n        (row === finishNode.row && col === finishNode.col)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // If it's a wall (not a passage), add to walls list\r\n      if (!isPassage[row][col]) {\r\n        wallsInOrder.push(grid[row][col]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shuffle walls for more interesting animation\r\n  shuffleArray(wallsInOrder);\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Adds frontier cells from a given position\r\n * Frontier cells are walls 2 steps away (in cardinal directions)\r\n */\r\nfunction addFrontier(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  isPassage: boolean[][],\r\n  frontier: [number, number][],\r\n  inFrontier: Set<string>\r\n): void {\r\n  const directions = [\r\n    [-2, 0], // Up\r\n    [2, 0], // Down\r\n    [0, -2], // Left\r\n    [0, 2], // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = row + dRow;\r\n    const newCol = col + dCol;\r\n\r\n    // Check bounds (leave 1 cell border)\r\n    if (\r\n      newRow >= 1 &&\r\n      newRow < numRows - 1 &&\r\n      newCol >= 1 &&\r\n      newCol < numCols - 1\r\n    ) {\r\n      const key = `${newRow}-${newCol}`;\r\n\r\n      // Add to frontier if it's a wall and not already in frontier\r\n      if (!isPassage[newRow][newCol] && !inFrontier.has(key)) {\r\n        frontier.push([newRow, newCol]);\r\n        inFrontier.add(key);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gets passage neighbors (cells 2 steps away that are passages)\r\n */\r\nfunction getPassageNeighbors(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  isPassage: boolean[][]\r\n): [number, number][] {\r\n  const neighbors: [number, number][] = [];\r\n  const directions = [\r\n    [-2, 0], // Up\r\n    [2, 0], // Down\r\n    [0, -2], // Left\r\n    [0, 2], // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = row + dRow;\r\n    const newCol = col + dCol;\r\n\r\n    // Check bounds\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      if (isPassage[newRow][newCol]) {\r\n        neighbors.push([newRow, newCol]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\n/**\r\n * Ensures a specific node is marked as a passage\r\n */\r\nfunction ensureNodeIsPassage(\r\n  node: Node,\r\n  isPassage: boolean[][],\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  if (\r\n    node.row >= 0 &&\r\n    node.row < numRows &&\r\n    node.col >= 0 &&\r\n    node.col < numCols\r\n  ) {\r\n    isPassage[node.row][node.col] = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Connects a cell to the nearest passage by carving a path\r\n */\r\nfunction connectToNearestPassage(\r\n  startRow: number,\r\n  startCol: number,\r\n  isPassage: boolean[][],\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  // BFS to find nearest passage\r\n  const visited = new Set<string>();\r\n  const queue: [number, number, [number, number][]][] = [\r\n    [startRow, startCol, []],\r\n  ];\r\n  visited.add(`${startRow}-${startCol}`);\r\n\r\n  const directions = [\r\n    [-1, 0], // Up\r\n    [1, 0], // Down\r\n    [0, -1], // Left\r\n    [0, 1], // Right\r\n  ];\r\n\r\n  while (queue.length > 0) {\r\n    const [row, col, path] = queue.shift()!;\r\n\r\n    // Found a passage - carve the path to it\r\n    if (isPassage[row][col] && path.length > 0) {\r\n      for (const [pRow, pCol] of path) {\r\n        isPassage[pRow][pCol] = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Explore neighbors\r\n    for (const [dRow, dCol] of directions) {\r\n      const newRow = row + dRow;\r\n      const newCol = col + dCol;\r\n      const key = `${newRow}-${newCol}`;\r\n\r\n      if (\r\n        newRow >= 0 &&\r\n        newRow < numRows &&\r\n        newCol >= 0 &&\r\n        newCol < numCols &&\r\n        !visited.has(key)\r\n      ) {\r\n        visited.add(key);\r\n        queue.push([newRow, newCol, [...path, [newRow, newCol]]]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Fisher-Yates shuffle for random wall animation order\r\n */\r\nfunction shuffleArray<T>(array: T[]): void {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n}\r\n","/**\r\n * Spiral Maze Generation Algorithm\r\n * Phase F: Extensions & History\r\n *\r\n * Creates a maze with walls arranged in a spiral pattern from outside to inside.\r\n * The spiral creates a long winding path that forces traversal through the entire\r\n * maze structure.\r\n *\r\n * Key Characteristics:\r\n * - Visually distinctive spiral pattern\r\n * - Creates a deterministic, predictable maze shape\r\n * - Gaps at each ring transition allow entering inner layers\r\n * - Great for demonstrating how algorithms handle long paths\r\n *\r\n * Algorithm:\r\n * 1. Start from the outermost ring of the grid\r\n * 2. Add walls along each side of the ring (top, right, bottom, left)\r\n * 3. Leave a gap for passage to the inner ring\r\n * 4. Move to the next inner ring and repeat\r\n * 5. Continue until center is reached\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Direction enum for spiral traversal\r\n */\r\nenum Direction {\r\n  RIGHT = 0,\r\n  DOWN = 1,\r\n  LEFT = 2,\r\n  UP = 3,\r\n}\r\n\r\n/**\r\n * Main function to generate a spiral maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain open)\r\n * @param finishNode - The finish node (must remain open)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getSpiralMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const wallsInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Set to track which cells should NOT become walls\r\n  const protectedCells = new Set<string>();\r\n  protectedCells.add(`${startNode.row}-${startNode.col}`);\r\n  protectedCells.add(`${finishNode.row}-${finishNode.col}`);\r\n\r\n  // Also protect adjacent cells to start/finish to ensure accessibility\r\n  protectAdjacentCells(\r\n    startNode.row,\r\n    startNode.col,\r\n    numRows,\r\n    numCols,\r\n    protectedCells\r\n  );\r\n  protectAdjacentCells(\r\n    finishNode.row,\r\n    finishNode.col,\r\n    numRows,\r\n    numCols,\r\n    protectedCells\r\n  );\r\n\r\n  /**\r\n   * Helper to check if a cell can become a wall\r\n   */\r\n  const canBeWall = (row: number, col: number): boolean => {\r\n    // Check bounds\r\n    if (row < 0 || row >= numRows || col < 0 || col >= numCols) return false;\r\n    // Check if protected\r\n    if (protectedCells.has(`${row}-${col}`)) return false;\r\n    // Check if it's start or finish\r\n    if (grid[row][col].isStart || grid[row][col].isFinish) return false;\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Add a wall if valid\r\n   */\r\n  const addWall = (row: number, col: number): void => {\r\n    if (canBeWall(row, col)) {\r\n      wallsInOrder.push(grid[row][col]);\r\n    }\r\n  };\r\n\r\n  // Step 1: Add outer border walls (to prevent edge shortcuts)\r\n  // Top border\r\n  for (let col = 0; col < numCols; col++) {\r\n    addWall(0, col);\r\n  }\r\n  // Bottom border\r\n  for (let col = 0; col < numCols; col++) {\r\n    addWall(numRows - 1, col);\r\n  }\r\n  // Left border\r\n  for (let row = 1; row < numRows - 1; row++) {\r\n    addWall(row, 0);\r\n  }\r\n  // Right border\r\n  for (let row = 1; row < numRows - 1; row++) {\r\n    addWall(row, numCols - 1);\r\n  }\r\n\r\n  // Step 2: Generate spiral walls from outside to inside\r\n  // Each \"ring\" is a rectangular frame of walls with a gap to enter\r\n  let top = 2;\r\n  let bottom = numRows - 3;\r\n  let left = 2;\r\n  let right = numCols - 3;\r\n  let ringCount = 0;\r\n\r\n  while (top < bottom - 1 && left < right - 1) {\r\n    // Calculate gap position - alternate sides for each ring to create winding path\r\n    // Gap rotates: top -> right -> bottom -> left\r\n    const gapSide = ringCount % 4;\r\n\r\n    // Top wall (left to right) with gap\r\n    for (let col = left; col <= right; col++) {\r\n      const isGap = gapSide === 0 && col === Math.floor((left + right) / 2);\r\n      if (!isGap) {\r\n        addWall(top, col);\r\n      }\r\n    }\r\n\r\n    // Right wall (top+1 to bottom) with gap\r\n    for (let row = top + 1; row <= bottom; row++) {\r\n      const isGap = gapSide === 1 && row === Math.floor((top + bottom) / 2);\r\n      if (!isGap) {\r\n        addWall(row, right);\r\n      }\r\n    }\r\n\r\n    // Bottom wall (right-1 to left) with gap\r\n    for (let col = right - 1; col >= left; col--) {\r\n      const isGap = gapSide === 2 && col === Math.floor((left + right) / 2);\r\n      if (!isGap) {\r\n        addWall(bottom, col);\r\n      }\r\n    }\r\n\r\n    // Left wall (bottom-1 to top+1) with gap - this is the entrance to next ring\r\n    for (let row = bottom - 1; row > top; row--) {\r\n      const isGap = gapSide === 3 && row === Math.floor((top + bottom) / 2);\r\n      if (!isGap) {\r\n        addWall(row, left);\r\n      }\r\n    }\r\n\r\n    // Move to inner ring\r\n    top += 2;\r\n    bottom -= 2;\r\n    left += 2;\r\n    right -= 2;\r\n    ringCount++;\r\n  }\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Protect cells adjacent to start/finish to ensure they're accessible\r\n */\r\nfunction protectAdjacentCells(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  protectedCells: Set<string>\r\n): void {\r\n  const directions = [\r\n    [-1, 0], // Up\r\n    [1, 0], // Down\r\n    [0, -1], // Left\r\n    [0, 1], // Right\r\n  ];\r\n\r\n  for (const [dr, dc] of directions) {\r\n    const newRow = row + dr;\r\n    const newCol = col + dc;\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      protectedCells.add(`${newRow}-${newCol}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Alternative spiral pattern: Clockwise inward spiral path\r\n * Creates walls everywhere EXCEPT the spiral path\r\n */\r\nexport function getSpiralPathMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const wallsInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Track which cells are part of the spiral path\r\n  const isPath = new Set<string>();\r\n\r\n  // Start position (near top-left corner)\r\n  let row = 1;\r\n  let col = 1;\r\n  let direction: Direction = Direction.RIGHT;\r\n\r\n  // Boundaries for spiral\r\n  let minRow = 1;\r\n  let maxRow = numRows - 2;\r\n  let minCol = 1;\r\n  let maxCol = numCols - 2;\r\n\r\n  // Carve spiral path\r\n  while (minRow <= maxRow && minCol <= maxCol) {\r\n    // Move in current direction until hitting boundary\r\n    switch (direction) {\r\n      case Direction.RIGHT:\r\n        while (col <= maxCol) {\r\n          isPath.add(`${row}-${col}`);\r\n          col++;\r\n        }\r\n        col--;\r\n        minRow++;\r\n        break;\r\n\r\n      case Direction.DOWN:\r\n        while (row <= maxRow) {\r\n          isPath.add(`${row}-${col}`);\r\n          row++;\r\n        }\r\n        row--;\r\n        maxCol--;\r\n        break;\r\n\r\n      case Direction.LEFT:\r\n        while (col >= minCol) {\r\n          isPath.add(`${row}-${col}`);\r\n          col--;\r\n        }\r\n        col++;\r\n        maxRow--;\r\n        break;\r\n\r\n      case Direction.UP:\r\n        while (row >= minRow) {\r\n          isPath.add(`${row}-${col}`);\r\n          row--;\r\n        }\r\n        row++;\r\n        minCol++;\r\n        break;\r\n    }\r\n\r\n    // Turn clockwise\r\n    direction = (direction + 1) % 4;\r\n  }\r\n\r\n  // Protect start and finish\r\n  isPath.add(`${startNode.row}-${startNode.col}`);\r\n  isPath.add(`${finishNode.row}-${finishNode.col}`);\r\n\r\n  // Add walls for all non-path cells\r\n  for (let r = 0; r < numRows; r++) {\r\n    for (let c = 0; c < numCols; c++) {\r\n      if (!isPath.has(`${r}-${c}`)) {\r\n        const node = grid[r][c];\r\n        if (!node.isStart && !node.isFinish) {\r\n          wallsInOrder.push(node);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shuffle walls for more interesting animation\r\n  shuffleArray(wallsInOrder);\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Fisher-Yates shuffle algorithm\r\n */\r\nfunction shuffleArray<T>(array: T[]): void {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n}\r\n","/**\r\n * Cellular Automata Maze Generation Algorithm\r\n * Phase F: Extensions & History\r\n *\r\n * Creates a maze using cellular automata rules inspired by Conway's Game of Life.\r\n * This produces organic, cave-like patterns that differ from traditional maze algorithms.\r\n *\r\n * Key Characteristics:\r\n * - Creates natural-looking cave systems\r\n * - Non-deterministic (random initial state + rules = unique mazes)\r\n * - May create isolated regions (not guaranteed solvable without post-processing)\r\n * - Smooth, organic wall patterns unlike grid-based mazes\r\n *\r\n * Algorithm:\r\n * 1. Initialize grid with random walls (configurable density)\r\n * 2. Apply cellular automata rules for several generations:\r\n *    - Birth: Empty cell becomes wall if it has >= birthLimit wall neighbors\r\n *    - Death: Wall cell becomes empty if it has < deathLimit wall neighbors\r\n * 3. Ensure start and finish nodes are clear\r\n * 4. Ensure a path exists between start and finish (flood fill + carve if needed)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n/**\r\n * Configuration for the cellular automata\r\n */\r\ninterface CellularAutomataConfig {\r\n  initialWallChance: number; // 0.0 to 1.0 - probability of initial wall\r\n  birthLimit: number; // Neighbors needed for empty cell to become wall\r\n  deathLimit: number; // Neighbors needed for wall cell to stay wall\r\n  generations: number; // Number of simulation steps\r\n}\r\n\r\n/**\r\n * Default configuration - produces good cave-like mazes\r\n * Tuned for 4-directional pathfinding grids\r\n */\r\nconst DEFAULT_CONFIG: CellularAutomataConfig = {\r\n  initialWallChance: 0.4, // 40% initial walls (reduced for more open caves)\r\n  birthLimit: 4, // Empty becomes wall if >= 5 wall neighbors (harder to create walls)\r\n  deathLimit: 4, // Wall dies if < 4 wall neighbors (easier to remove walls)\r\n  generations: 1, // 1 simulation step (fewer to preserve openness)\r\n};\r\n\r\n/**\r\n * Main function to generate a Cellular Automata maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain open)\r\n * @param finishNode - The finish node (must remain open)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getCellularAutomataMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n  const config = DEFAULT_CONFIG;\r\n\r\n  // Create a 2D array to track wall state (true = wall)\r\n  let wallState: boolean[][] = initializeRandomWalls(\r\n    numRows,\r\n    numCols,\r\n    config.initialWallChance,\r\n    startNode,\r\n    finishNode\r\n  );\r\n\r\n  // Run cellular automata simulation\r\n  for (let gen = 0; gen < config.generations; gen++) {\r\n    wallState = simulateGeneration(\r\n      wallState,\r\n      numRows,\r\n      numCols,\r\n      config.birthLimit,\r\n      config.deathLimit\r\n    );\r\n  }\r\n\r\n  // Ensure start and finish are clear along with their neighbors\r\n  clearAroundNode(wallState, startNode.row, startNode.col, numRows, numCols);\r\n  clearAroundNode(wallState, finishNode.row, finishNode.col, numRows, numCols);\r\n\r\n  // Ensure path exists between start and finish\r\n  ensurePathExists(\r\n    wallState,\r\n    startNode.row,\r\n    startNode.col,\r\n    finishNode.row,\r\n    finishNode.col,\r\n    numRows,\r\n    numCols\r\n  );\r\n\r\n  // Keep border walls for nice appearance\r\n  addBorderWalls(wallState, numRows, numCols, startNode, finishNode);\r\n\r\n  // Convert wall state to Node array for animation\r\n  const wallsInOrder: Node[] = [];\r\n\r\n  // Collect walls in a visually interesting order (spiral from outside in)\r\n  const visited = new Set<string>();\r\n  const getKey = (r: number, c: number) => `${r}-${c}`;\r\n\r\n  // Add walls layer by layer from outside\r\n  for (let layer = 0; layer < Math.max(numRows, numCols) / 2; layer++) {\r\n    // Top row of this layer\r\n    for (let c = layer; c < numCols - layer; c++) {\r\n      const r = layer;\r\n      if (r < numRows && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n    // Right column\r\n    for (let r = layer + 1; r < numRows - layer; r++) {\r\n      const c = numCols - 1 - layer;\r\n      if (c >= 0 && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n    // Bottom row\r\n    for (let c = numCols - 2 - layer; c >= layer; c--) {\r\n      const r = numRows - 1 - layer;\r\n      if (r >= 0 && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n    // Left column\r\n    for (let r = numRows - 2 - layer; r > layer; r--) {\r\n      const c = layer;\r\n      if (c < numCols && !visited.has(getKey(r, c))) {\r\n        visited.add(getKey(r, c));\r\n        if (wallState[r][c] && !grid[r][c].isStart && !grid[r][c].isFinish) {\r\n          wallsInOrder.push(grid[r][c]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Initialize grid with random walls\r\n */\r\nfunction initializeRandomWalls(\r\n  numRows: number,\r\n  numCols: number,\r\n  wallChance: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean[][] {\r\n  const walls: boolean[][] = [];\r\n\r\n  for (let r = 0; r < numRows; r++) {\r\n    const row: boolean[] = [];\r\n    for (let c = 0; c < numCols; c++) {\r\n      // Never place walls on start/finish\r\n      if (\r\n        (r === startNode.row && c === startNode.col) ||\r\n        (r === finishNode.row && c === finishNode.col)\r\n      ) {\r\n        row.push(false);\r\n      } else {\r\n        row.push(Math.random() < wallChance);\r\n      }\r\n    }\r\n    walls.push(row);\r\n  }\r\n\r\n  return walls;\r\n}\r\n\r\n/**\r\n * Simulate one generation of cellular automata\r\n */\r\nfunction simulateGeneration(\r\n  currentState: boolean[][],\r\n  numRows: number,\r\n  numCols: number,\r\n  birthLimit: number,\r\n  deathLimit: number\r\n): boolean[][] {\r\n  const newState: boolean[][] = [];\r\n\r\n  for (let r = 0; r < numRows; r++) {\r\n    const row: boolean[] = [];\r\n    for (let c = 0; c < numCols; c++) {\r\n      const wallNeighbors = countWallNeighbors(\r\n        currentState,\r\n        r,\r\n        c,\r\n        numRows,\r\n        numCols\r\n      );\r\n\r\n      if (currentState[r][c]) {\r\n        // Cell is currently a wall\r\n        // It survives if it has enough wall neighbors\r\n        row.push(wallNeighbors >= deathLimit);\r\n      } else {\r\n        // Cell is currently empty\r\n        // It becomes a wall if it has enough wall neighbors\r\n        row.push(wallNeighbors >= birthLimit);\r\n      }\r\n    }\r\n    newState.push(row);\r\n  }\r\n\r\n  return newState;\r\n}\r\n\r\n/**\r\n * Count wall neighbors (8-directional including diagonals)\r\n */\r\nfunction countWallNeighbors(\r\n  state: boolean[][],\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number\r\n): number {\r\n  let count = 0;\r\n\r\n  for (let dr = -1; dr <= 1; dr++) {\r\n    for (let dc = -1; dc <= 1; dc++) {\r\n      if (dr === 0 && dc === 0) continue; // Skip self\r\n\r\n      const nr = row + dr;\r\n      const nc = col + dc;\r\n\r\n      // Out-of-bounds counts as empty (prevents border from filling everything)\r\n      if (nr < 0 || nr >= numRows || nc < 0 || nc >= numCols) {\r\n        // Don't count out-of-bounds as walls\r\n        continue;\r\n      } else if (state[nr][nc]) {\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\n/**\r\n * Clear cells around a node (ensure it's accessible)\r\n */\r\nfunction clearAroundNode(\r\n  state: boolean[][],\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  // Clear the node itself and its 4-directional neighbors\r\n  state[row][col] = false;\r\n\r\n  const directions = [\r\n    [-1, 0],\r\n    [1, 0],\r\n    [0, -1],\r\n    [0, 1],\r\n  ];\r\n\r\n  for (const [dr, dc] of directions) {\r\n    const nr = row + dr;\r\n    const nc = col + dc;\r\n    if (nr >= 0 && nr < numRows && nc >= 0 && nc < numCols) {\r\n      state[nr][nc] = false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure a path exists between start and finish using flood fill\r\n * If no path exists, carve a winding path\r\n */\r\nfunction ensurePathExists(\r\n  state: boolean[][],\r\n  startRow: number,\r\n  startCol: number,\r\n  finishRow: number,\r\n  finishCol: number,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  // Flood fill from start to find all reachable cells\r\n  const reachable = new Set<string>();\r\n  const getKey = (r: number, c: number) => `${r}-${c}`;\r\n\r\n  const queue: [number, number][] = [[startRow, startCol]];\r\n  reachable.add(getKey(startRow, startCol));\r\n\r\n  while (queue.length > 0) {\r\n    const [r, c] = queue.shift()!;\r\n\r\n    const directions = [\r\n      [-1, 0],\r\n      [1, 0],\r\n      [0, -1],\r\n      [0, 1],\r\n    ];\r\n\r\n    for (const [dr, dc] of directions) {\r\n      const nr = r + dr;\r\n      const nc = c + dc;\r\n      const key = getKey(nr, nc);\r\n\r\n      if (\r\n        nr >= 0 &&\r\n        nr < numRows &&\r\n        nc >= 0 &&\r\n        nc < numCols &&\r\n        !state[nr][nc] &&\r\n        !reachable.has(key)\r\n      ) {\r\n        reachable.add(key);\r\n        queue.push([nr, nc]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check if finish is reachable\r\n  if (reachable.has(getKey(finishRow, finishCol))) {\r\n    return; // Path exists!\r\n  }\r\n\r\n  // No path exists - carve a winding path with some randomness\r\n  carveWindingPath(\r\n    state,\r\n    startRow,\r\n    startCol,\r\n    finishRow,\r\n    finishCol,\r\n    numRows,\r\n    numCols\r\n  );\r\n}\r\n\r\n/**\r\n * Carve a winding path between two points (more organic than straight line)\r\n */\r\nfunction carveWindingPath(\r\n  state: boolean[][],\r\n  startRow: number,\r\n  startCol: number,\r\n  endRow: number,\r\n  endCol: number,\r\n  numRows: number,\r\n  numCols: number\r\n): void {\r\n  let r = startRow;\r\n  let c = startCol;\r\n\r\n  // Clear starting area\r\n  state[r][c] = false;\r\n\r\n  while (r !== endRow || c !== endCol) {\r\n    // Clear current cell and some neighbors for wider passages\r\n    state[r][c] = false;\r\n\r\n    // Randomly widen the path occasionally\r\n    if (Math.random() < 0.3) {\r\n      const directions = [\r\n        [-1, 0],\r\n        [1, 0],\r\n        [0, -1],\r\n        [0, 1],\r\n      ];\r\n      const [dr, dc] =\r\n        directions[Math.floor(Math.random() * directions.length)];\r\n      const nr = r + dr;\r\n      const nc = c + dc;\r\n      if (nr > 0 && nr < numRows - 1 && nc > 0 && nc < numCols - 1) {\r\n        state[nr][nc] = false;\r\n      }\r\n    }\r\n\r\n    // Decide direction with some randomness\r\n    const moveVertical = Math.random() < 0.5;\r\n\r\n    if (moveVertical && r !== endRow) {\r\n      r += r < endRow ? 1 : -1;\r\n    } else if (c !== endCol) {\r\n      c += c < endCol ? 1 : -1;\r\n    } else if (r !== endRow) {\r\n      r += r < endRow ? 1 : -1;\r\n    }\r\n  }\r\n\r\n  // Clear the end point and area around it\r\n  state[endRow][endCol] = false;\r\n}\r\n\r\n/**\r\n * Add border walls for a clean look\r\n */\r\nfunction addBorderWalls(\r\n  state: boolean[][],\r\n  numRows: number,\r\n  numCols: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): void {\r\n  // Top and bottom borders\r\n  for (let c = 0; c < numCols; c++) {\r\n    if (\r\n      !(startNode.row === 0 && startNode.col === c) &&\r\n      !(finishNode.row === 0 && finishNode.col === c)\r\n    ) {\r\n      state[0][c] = true;\r\n    }\r\n    if (\r\n      !(startNode.row === numRows - 1 && startNode.col === c) &&\r\n      !(finishNode.row === numRows - 1 && finishNode.col === c)\r\n    ) {\r\n      state[numRows - 1][c] = true;\r\n    }\r\n  }\r\n\r\n  // Left and right borders\r\n  for (let r = 0; r < numRows; r++) {\r\n    if (\r\n      !(startNode.row === r && startNode.col === 0) &&\r\n      !(finishNode.row === r && finishNode.col === 0)\r\n    ) {\r\n      state[r][0] = true;\r\n    }\r\n    if (\r\n      !(startNode.row === r && startNode.col === numCols - 1) &&\r\n      !(finishNode.row === r && finishNode.col === numCols - 1)\r\n    ) {\r\n      state[r][numCols - 1] = true;\r\n    }\r\n  }\r\n}\r\n"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","getAllNodes","sortNodesByDistance","closestNode","updateUnvisitedNeighbors","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","nodes","row","node","a","b","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","neighbors","col","numRows","numCols","manhattanDistance","nodeA","nodeB","astar","gScore","fScore","inOpenSet","getKey","key","startKey","openSet","fA","fB","current","currentKey","currentGScore","getNeighbors","neighborKey","tentativeGScore","neighborGScore","bfs","queue","dfs","stack","greedyBestFirst","nodesInPathOrder","reconstructedPath","bidirectionalBFS","parentFromStart","parentFromFinish","visitedFromStart","visitedFromFinish","getNodeFromKey","startQueue","finishQueue","finishKey","meetingKey","n","pathFromStart","parent","pathToFinish","meetingParentFromFinish","i","bidirectionalAStar","gScoreStart","fScoreStart","inOpenSetStart","openSetStart","gScoreFinish","fScoreFinish","inOpenSetFinish","openSetFinish","bestPathCost","popLowestFScore","pathCost","minFStart","minFFinish","DIRECTIONS","jumpPointSearch","isWalkable","cameFrom","jump","dirRow","dirCol","nextRow","nextCol","identifySuccessors","parentDirRow","parentDirCol","successors","directionsToCheck","dRow","dCol","jumpPoint","reconstructPath","successor","successorKey","successorNode","_startNode","path","jumpPoints","from","to","currentRow","currentCol","getRecursiveDivisionMaze","wallsInOrder","divide","chooseOrientation","startRow","endRow","startCol","endCol","orientation","height","width","possibleRows","getEvenNumbers","wallRow","possibleGaps","getOddNumbers","gapCol","isStartOrFinish","possibleCols","wallCol","gapRow","start","end","result","getRandomizedDFSMaze","visited","carve","ensureAccessible","passagesInOrder","shuffleArray","directions","newRow","newCol","array","j","getPrimsMaze","isPassage","inFrontier","frontier","addFrontier","randomIndex","passageNeighbors","getPassageNeighbors","neighborRow","neighborCol","ensureNodeIsPassage","connectToNearestPassage","pRow","pCol","getSpiralMaze","protectedCells","protectAdjacentCells","canBeWall","addWall","top","bottom","left","right","ringCount","gapSide","dr","dc","DEFAULT_CONFIG","getCellularAutomataMaze","config","wallState","initializeRandomWalls","gen","simulateGeneration","clearAroundNode","ensurePathExists","addBorderWalls","r","c","layer","wallChance","walls","currentState","birthLimit","deathLimit","newState","wallNeighbors","countWallNeighbors","state","count","nr","nc","finishRow","finishCol","reachable","carveWindingPath"],"mappings":"AA6BO,SAASA,GACdC,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAGpCF,EAAU,SAAW,EAGrB,MAAMG,EAAiBC,EAAYL,CAAI,EAEvC,KAAOI,EAAe,OAAS,GAAG,CAEhCE,EAAoBF,CAAc,EAGlC,MAAMG,EAAcH,EAAe,MAAA,EAGnC,GAAI,CAAAG,EAAY,OAehB,IATIA,EAAY,WAAa,MAK7BA,EAAY,UAAY,GACxBJ,EAAoB,KAAKI,CAAW,EAGhCA,IAAgBL,GAClB,OAAOC,EAITK,EAAyBD,EAAaP,CAAI,EAC5C,CAEA,OAAOG,CACT,CAUO,SAASM,GAA4BP,EAA0B,CACpE,MAAMQ,EAAmC,CAAA,EACzC,IAAIC,EAA2BT,EAG/B,KAAOS,IAAgB,MAErBD,EAAyB,QAAQC,CAAW,EAC5CA,EAAcA,EAAY,aAG5B,OAAOD,CACT,CASA,SAASL,EAAYL,EAAoB,CACvC,MAAMY,EAAgB,CAAA,EACtB,UAAWC,KAAOb,EAChB,UAAWc,KAAQD,EACjBD,EAAM,KAAKE,CAAI,EAGnB,OAAOF,CACT,CAOA,SAASN,EAAoBF,EAA8B,CACzDA,EAAe,KAAK,CAACW,EAAGC,IAAMD,EAAE,SAAWC,EAAE,QAAQ,CACvD,CAMA,SAASR,EAAyBM,EAAYd,EAAkB,CAC9D,MAAMiB,EAAqBC,GAAsBJ,EAAMd,CAAI,EAE3D,UAAWmB,KAAYF,EAErBE,EAAS,SAAWL,EAAK,SAAW,EACpCK,EAAS,aAAeL,CAE5B,CAMA,SAASI,GAAsBJ,EAAYd,EAAoB,CAC7D,MAAMoB,EAAoB,CAAA,EACpB,CAAE,IAAAP,EAAK,IAAAQ,CAAA,EAAQP,EACfQ,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxB,OAAIa,EAAM,GACRO,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BR,EAAMS,EAAU,GAClBF,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BA,EAAM,GACRD,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG/BA,EAAME,EAAU,GAClBH,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAI5BD,EAAU,OAAQD,GAAa,CAACA,EAAS,SAAS,CAC3D,CC/IA,SAASK,EAAkBC,EAAaC,EAAqB,CAC3D,OAAO,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,EAAI,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,CACzE,CA8BO,SAASC,GACd3B,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAI9ByB,MAAa,IACbC,MAAa,IACbC,MAAgB,IAGhBC,EAAUjB,GAAuB,GAAGA,EAAK,GAAG,IAAIA,EAAK,GAAG,GAG9D,UAAWD,KAAOb,EAChB,UAAWc,KAAQD,EAAK,CACtB,MAAMmB,EAAMD,EAAOjB,CAAI,EACvBc,EAAO,IAAII,EAAK,GAAQ,EACxBH,EAAO,IAAIG,EAAK,GAAQ,CAC1B,CAIF,MAAMC,EAAWF,EAAO9B,CAAS,EACjC2B,EAAO,IAAIK,EAAU,CAAC,EACtBJ,EAAO,IAAII,EAAUT,EAAkBvB,EAAWC,CAAU,CAAC,EAG7D,MAAMgC,EAAkB,CAACjC,CAAS,EAGlC,IAFA6B,EAAU,IAAIG,EAAU,EAAI,EAErBC,EAAQ,OAAS,GAAG,CAEzBA,EAAQ,KAAK,CAACnB,EAAGC,IAAM,CACrB,MAAMmB,EAAKN,EAAO,IAAIE,EAAOhB,CAAC,CAAC,GAAK,IAC9BqB,EAAKP,EAAO,IAAIE,EAAOf,CAAC,CAAC,GAAK,IACpC,OAAOmB,EAAKC,CACd,CAAC,EAED,MAAMC,EAAUH,EAAQ,MAAA,EAClBI,EAAaP,EAAOM,CAAO,EASjC,GARAP,EAAU,IAAIQ,EAAY,EAAK,EAG3BD,EAAQ,QAKRA,EAAQ,UACV,SAIF,MAAME,EAAgBX,EAAO,IAAIU,CAAU,GAAK,IAUhD,GATIC,IAAkB,MAKtBF,EAAQ,UAAY,GACpBlC,EAAoB,KAAKkC,CAAO,EAG5BA,IAAYnC,GACd,OAAOC,EAIT,MAAMiB,EAAYoB,GAAaH,EAASrC,CAAI,EAE5C,UAAWmB,KAAYC,EAAW,CAEhC,GAAID,EAAS,QAAUA,EAAS,UAC9B,SAGF,MAAMsB,EAAcV,EAAOZ,CAAQ,EAG7BuB,EAAkBH,EAAgB,EAGlCI,EAAiBf,EAAO,IAAIa,CAAW,GAAK,IAC9CC,EAAkBC,IAEpBxB,EAAS,aAAekB,EACxBT,EAAO,IAAIa,EAAaC,CAAe,EACvCb,EAAO,IAAIY,EAAaC,EAAkBlB,EAAkBL,EAAUjB,CAAU,CAAC,EAG5E4B,EAAU,IAAIW,CAAW,IAC5BP,EAAQ,KAAKf,CAAQ,EACrBW,EAAU,IAAIW,EAAa,EAAI,GAGrC,CACF,CAGA,OAAOtC,CACT,CAWO,SAASM,GAA4BP,EAA0B,CACpE,MAAMQ,EAAmC,CAAA,EACzC,IAAIC,EAA2BT,EAG/B,KAAOS,IAAgB,MAErBD,EAAyB,QAAQC,CAAW,EAC5CA,EAAcA,EAAY,aAG5B,OAAOD,CACT,CAUA,SAAS8B,GAAa1B,EAAYd,EAAoB,CACpD,MAAMoB,EAAoB,CAAA,EACpB,CAAE,IAAAP,EAAK,IAAAQ,CAAA,EAAQP,EACfQ,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxB,OAAIa,EAAM,GACRO,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BR,EAAMS,EAAU,GAClBF,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BA,EAAM,GACRD,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG/BA,EAAME,EAAU,GAClBH,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG5BD,CACT,CC/KO,SAASwB,GACd5C,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAG9B0C,EAAgB,CAAA,EAQtB,IALA5C,EAAU,UAAY,GACtBA,EAAU,SAAW,EACrB4C,EAAM,KAAK5C,CAAS,EACpBE,EAAoB,KAAKF,CAAS,EAE3B4C,EAAM,OAAS,GAAG,CAEvB,MAAMlC,EAAckC,EAAM,MAAA,EAG1B,GAAIlC,EAAY,OACd,SAIF,GAAIA,IAAgBT,EAClB,OAAOC,EAIT,MAAMiB,EAAYF,GAAsBP,EAAaX,CAAI,EAEzD,UAAWmB,KAAYC,EAErB,GAAI,CAAAD,EAAS,SAKbA,EAAS,UAAY,GAGrBA,EAAS,aAAeR,EAGxBQ,EAAS,SAAWR,EAAY,SAAW,EAG3CkC,EAAM,KAAK1B,CAAQ,EAGnBhB,EAAoB,KAAKgB,CAAQ,EAG7BA,IAAajB,GACf,OAAOC,CAGb,CAGA,OAAOA,CACT,CAWO,SAASM,GAA4BP,EAA0B,CACpE,MAAMQ,EAAmC,CAAA,EACzC,IAAIC,EAA2BT,EAG/B,KAAOS,IAAgB,MAErBD,EAAyB,QAAQC,CAAW,EAC5CA,EAAcA,EAAY,aAG5B,OAAOD,CACT,CAUA,SAASQ,GAAsBJ,EAAYd,EAAoB,CAC7D,MAAMoB,EAAoB,CAAA,EACpB,CAAE,IAAAP,EAAK,IAAAQ,CAAA,EAAQP,EACfQ,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxB,OAAIa,EAAM,GACRO,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BR,EAAMS,EAAU,GAClBF,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BA,EAAM,GACRD,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG/BA,EAAME,EAAU,GAClBH,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAI5BD,EAAU,OAAQD,GAAa,CAACA,EAAS,SAAS,CAC3D,CC1HO,SAAS2B,GACd9C,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAG9B4C,EAAgB,CAAA,EAKtB,IAFAA,EAAM,KAAK9C,CAAS,EAEb8C,EAAM,OAAS,GAAG,CAEvB,MAAMpC,EAAcoC,EAAM,IAAA,EAQ1B,GALIpC,EAAY,QAKZA,EAAY,UACd,SAUF,GANAA,EAAY,UAAY,GAGxBR,EAAoB,KAAKQ,CAAW,EAGhCA,IAAgBT,EAClB,OAAOC,EAMT,MAAMiB,EAAYF,GAAsBP,EAAaX,CAAI,EAEzD,UAAWmB,KAAYC,EAEjBD,EAAS,QAKTA,EAAS,YAKbA,EAAS,aAAeR,EAGxBoC,EAAM,KAAK5B,CAAQ,EAEvB,CAGA,OAAOhB,CACT,CAYO,SAASM,GAA4BP,EAA0B,CACpE,MAAMQ,EAAmC,CAAA,EACzC,IAAIC,EAA2BT,EAG/B,KAAOS,IAAgB,MAErBD,EAAyB,QAAQC,CAAW,EAC5CA,EAAcA,EAAY,aAG5B,OAAOD,CACT,CAcA,SAASQ,GAAsBJ,EAAYd,EAAoB,CAC7D,MAAMoB,EAAoB,CAAA,EACpB,CAAE,IAAAP,EAAK,IAAAQ,CAAA,EAAQP,EACfQ,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAMxB,OAAIqB,EAAM,GACRD,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG/BR,EAAMS,EAAU,GAClBF,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BA,EAAME,EAAU,GAClBH,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG/BR,EAAM,GACRO,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAI5BD,EAAU,OAAQD,GAAa,CAACA,EAAS,SAAS,CAC3D,CC7IA,SAASK,EAAkBC,EAAaC,EAAqB,CAC3D,OAAO,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,EAAI,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,CACzE,CA8BO,SAASsB,GACdhD,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAI9B0B,MAAa,IACbC,MAAgB,IAGhBC,EAAUjB,GAAuB,GAAGA,EAAK,GAAG,IAAIA,EAAK,GAAG,GAG9D,UAAWD,KAAOb,EAChB,UAAWc,KAAQD,EAAK,CACtB,MAAMmB,EAAMD,EAAOjB,CAAI,EACvBe,EAAO,IAAIG,EAAK,GAAQ,CAC1B,CAIF,MAAMC,EAAWF,EAAO9B,CAAS,EACjC4B,EAAO,IAAII,EAAUT,EAAkBvB,EAAWC,CAAU,CAAC,EAG7D,MAAMgC,EAAkB,CAACjC,CAAS,EAGlC,IAFA6B,EAAU,IAAIG,EAAU,EAAI,EAErBC,EAAQ,OAAS,GAAG,CAEzBA,EAAQ,KAAK,CAACnB,EAAGC,IAAM,CACrB,MAAMmB,EAAKN,EAAO,IAAIE,EAAOhB,CAAC,CAAC,GAAK,IAC9BqB,EAAKP,EAAO,IAAIE,EAAOf,CAAC,CAAC,GAAK,IACpC,OAAOmB,EAAKC,CACd,CAAC,EAED,MAAMC,EAAUH,EAAQ,MAAA,EAClBI,EAAaP,EAAOM,CAAO,EASjC,GARAP,EAAU,IAAIQ,EAAY,EAAK,EAG3BD,EAAQ,QAKRA,EAAQ,UACV,SAQF,GAJAA,EAAQ,UAAY,GACpBlC,EAAoB,KAAKkC,CAAO,EAG5BA,IAAYnC,EACd,OAAOC,EAIT,MAAMiB,EAAYoB,GAAaH,EAASrC,CAAI,EAE5C,UAAWmB,KAAYC,EAAW,CAEhC,GAAID,EAAS,QAAUA,EAAS,UAC9B,SAGF,MAAMsB,EAAcV,EAAOZ,CAAQ,EAG/BW,EAAU,IAAIW,CAAW,IAK7BtB,EAAS,aAAekB,EAIxBR,EAAO,IAAIY,EAAajB,EAAkBL,EAAUjB,CAAU,CAAC,EAG/DgC,EAAQ,KAAKf,CAAQ,EACrBW,EAAU,IAAIW,EAAa,EAAI,EACjC,CACF,CAGA,OAAOtC,CACT,CAWO,SAASM,GAA4BP,EAA0B,CACpE,MAAM+C,EAA2B,CAAA,EACjC,IAAItC,EAA2BT,EAG/B,KAAOS,IAAgB,MAErBsC,EAAiB,QAAQtC,CAAW,EACpCA,EAAcA,EAAY,aAG5B,OAAOsC,CACT,CAUA,SAAST,GAAa1B,EAAYd,EAAoB,CACpD,MAAMoB,EAAoB,CAAA,EACpB,CAAE,IAAAP,EAAK,IAAAQ,CAAA,EAAQP,EACfQ,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxB,OAAIa,EAAM,GACRO,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BR,EAAMS,EAAU,GAClBF,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAG/BA,EAAM,GACRD,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG/BA,EAAME,EAAU,GAClBH,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAG5BD,CACT,CCjMA,IAAI8B,EAA4B,CAAA,EAUzB,SAASC,GACdnD,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAC9BmB,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxBkD,EAAoB,CAAA,EAGpB,MAAME,MAAgD,IAChDC,MAAiD,IAGjDC,MAAoC,IACpCC,MAAqC,IAGrCxB,EAAUjB,GAAuB,GAAGA,EAAK,GAAG,IAAIA,EAAK,GAAG,GACxD0C,EAAkBxB,GAAsB,CAC5C,KAAM,CAACnB,EAAKQ,CAAG,EAAIW,EAAI,MAAM,GAAG,EAAE,IAAI,MAAM,EAC5C,OAAOhC,EAAKa,CAAG,EAAEQ,CAAG,CACtB,EAGMoC,EAAqB,CAACxD,CAAS,EAC/ByD,EAAsB,CAACxD,CAAU,EAGjC+B,EAAWF,EAAO9B,CAAS,EACjCqD,EAAiB,IAAIrB,CAAQ,EAC7BmB,EAAgB,IAAInB,EAAU,IAAI,EAClChC,EAAU,UAAY,GACtBE,EAAoB,KAAKF,CAAS,EAGlC,MAAM0D,EAAY5B,EAAO7B,CAAU,EACnCqD,EAAkB,IAAII,CAAS,EAC/BN,EAAiB,IAAIM,EAAW,IAAI,EAGpC,IAAIC,EAA4B,KAKhC,MAAMpB,EAAgB1B,GAAuB,CAC3C,MAAMM,EAAoB,CAAA,EACpB,CAAE,IAAAP,EAAK,IAAAQ,CAAA,EAAQP,EAGrB,OAAID,EAAM,GAAGO,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAE1CR,EAAMS,EAAU,GAAGF,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAEpDA,EAAM,GAAGD,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAE1CA,EAAME,EAAU,GAAGH,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAEjDD,EAAU,OAAQyC,GAAM,CAACA,EAAE,MAAM,CAC1C,EAGA,KAAOJ,EAAW,OAAS,GAAKC,EAAY,OAAS,GAAG,CAEtD,GAAID,EAAW,OAAS,EAAG,CACzB,MAAM9C,EAAc8C,EAAW,MAAA,EAE/B,UAAWtC,KAAYqB,EAAa7B,CAAW,EAAG,CAChD,MAAM8B,EAAcV,EAAOZ,CAAQ,EAGnC,GAAI,CAAAmC,EAAiB,IAAIb,CAAW,EASpC,IANAa,EAAiB,IAAIb,CAAW,EAChCW,EAAgB,IAAIX,EAAa9B,CAAW,EAC5CQ,EAAS,UAAY,GACrBhB,EAAoB,KAAKgB,CAAQ,EAG7BoC,EAAkB,IAAId,CAAW,EAAG,CACtCmB,EAAanB,EACb,KACF,CAEAgB,EAAW,KAAKtC,CAAQ,EAC1B,CAEA,GAAIyC,EAAY,KAClB,CAGA,GAAIF,EAAY,OAAS,GAAK,CAACE,EAAY,CACzC,MAAMjD,EAAc+C,EAAY,MAAA,EAG5B/C,IAAgBT,IAClBA,EAAW,UAAY,GACvBC,EAAoB,KAAKD,CAAU,GAGrC,UAAWiB,KAAYqB,EAAa7B,CAAW,EAAG,CAChD,MAAM8B,EAAcV,EAAOZ,CAAQ,EAGnC,GAAI,CAAAoC,EAAkB,IAAId,CAAW,EASrC,IANAc,EAAkB,IAAId,CAAW,EACjCY,EAAiB,IAAIZ,EAAa9B,CAAW,EAC7CQ,EAAS,UAAY,GACrBhB,EAAoB,KAAKgB,CAAQ,EAG7BmC,EAAiB,IAAIb,CAAW,EAAG,CACrCmB,EAAanB,EACb,KACF,CAEAiB,EAAY,KAAKvC,CAAQ,EAC3B,CAEA,GAAIyC,EAAY,KAClB,CACF,CAGA,GAAIA,EAAY,CAEd,MAAME,EAAwB,CAAA,EAC9B,IAAIxB,EAA4BsB,EAChC,KAAOtB,IAAe,MAAM,CAC1BwB,EAAc,QAAQN,EAAelB,CAAU,CAAC,EAChD,MAAMyB,EAASX,EAAgB,IAAId,CAAU,EAC7CA,EAAayB,EAAShC,EAAOgC,CAAM,EAAI,IACzC,CAGA,MAAMC,EAAuB,CAAA,EACvBC,EAA0BZ,EAAiB,IAAIO,CAAU,EAI/D,IAHAtB,EAAa2B,EACTlC,EAAOkC,CAAuB,EAC9B,KACG3B,IAAe,MAAM,CAC1B0B,EAAa,KAAKR,EAAelB,CAAU,CAAC,EAC5C,MAAMyB,EAASV,EAAiB,IAAIf,CAAU,EAC9CA,EAAayB,EAAShC,EAAOgC,CAAM,EAAI,IACzC,CAGAb,EAAoB,CAAC,GAAGY,EAAe,GAAGE,CAAY,EAGtD,QAASE,EAAI,EAAGA,EAAIhB,EAAkB,OAAQgB,IAC5ChB,EAAkBgB,CAAC,EAAE,aAAehB,EAAkBgB,EAAI,CAAC,EAI7DhE,EAAW,UAAY,EACzB,CAEA,OAAOC,CACT,CASO,SAASM,GAA4BP,EAA0B,CAEpE,GAAIgD,EAAkB,OAAS,EAC7B,OAAOA,EAIT,MAAMxC,EAAmC,CAAA,EACzC,IAAIC,EAA2BT,EAG/B,GAAI,CAACA,EAAW,UACd,OAAOQ,EAGT,KAAOC,IAAgB,MACrBD,EAAyB,QAAQC,CAAW,EAC5CA,EAAcA,EAAY,aAG5B,OAAOD,CACT,CC3MA,IAAIwC,EAA4B,CAAA,EAQhC,SAAS1B,EAAkBC,EAAaC,EAAqB,CAC3D,OAAO,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,EAAI,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,CACzE,CAkBO,SAASyC,GACdnE,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAC9BmB,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxBkD,EAAoB,CAAA,EAGpB,MAAMnB,EAAUjB,GAAuB,GAAGA,EAAK,GAAG,IAAIA,EAAK,GAAG,GACxD0C,EAAkBxB,GAAsB,CAC5C,KAAM,CAACnB,EAAKQ,CAAG,EAAIW,EAAI,MAAM,GAAG,EAAE,IAAI,MAAM,EAC5C,OAAOhC,EAAKa,CAAG,EAAEQ,CAAG,CACtB,EAKM+C,MAAkB,IAClBC,MAAkB,IAClBjB,MAAsB,IACtBE,MAAuB,IACvBgB,MAAqB,IACrBC,EAAuB,CAAA,EAKvBC,MAAmB,IACnBC,MAAmB,IACnBpB,MAAuB,IACvBE,MAAwB,IACxBmB,MAAsB,IACtBC,EAAwB,CAAA,EAG9B,UAAW9D,KAAOb,EAChB,UAAWc,KAAQD,EAAK,CACtB,MAAMmB,EAAMD,EAAOjB,CAAI,EACvBsD,EAAY,IAAIpC,EAAK,GAAQ,EAC7BqC,EAAY,IAAIrC,EAAK,GAAQ,EAC7BwC,EAAa,IAAIxC,EAAK,GAAQ,EAC9ByC,EAAa,IAAIzC,EAAK,GAAQ,CAChC,CAIF,MAAMC,EAAWF,EAAO9B,CAAS,EACjCmE,EAAY,IAAInC,EAAU,CAAC,EAC3BoC,EAAY,IAAIpC,EAAUT,EAAkBvB,EAAWC,CAAU,CAAC,EAClEkD,EAAgB,IAAInB,EAAU,IAAI,EAClCsC,EAAa,KAAKtE,CAAS,EAC3BqE,EAAe,IAAIrC,EAAU,EAAI,EACjCqB,EAAiB,IAAIrB,CAAQ,EAC7BhC,EAAU,UAAY,GACtBE,EAAoB,KAAKF,CAAS,EAGlC,MAAM0D,EAAY5B,EAAO7B,CAAU,EACnCsE,EAAa,IAAIb,EAAW,CAAC,EAC7Bc,EAAa,IAAId,EAAWnC,EAAkBtB,EAAYD,CAAS,CAAC,EACpEoD,EAAiB,IAAIM,EAAW,IAAI,EACpCgB,EAAc,KAAKzE,CAAU,EAC7BwE,EAAgB,IAAIf,EAAW,EAAI,EACnCJ,EAAkB,IAAII,CAAS,EAG/B,IAAIC,EAA4B,KAC5BgB,EAAe,IAKnB,MAAMpC,EAAgB1B,GAAuB,CAC3C,MAAMM,EAAoB,CAAA,EACpB,CAAE,IAAAP,EAAK,IAAAQ,CAAA,EAAQP,EAGrB,OAAID,EAAM,GAAGO,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAE1CR,EAAMS,EAAU,GAAGF,EAAU,KAAKpB,EAAKa,EAAM,CAAC,EAAEQ,CAAG,CAAC,EAEpDA,EAAM,GAAGD,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAE1CA,EAAME,EAAU,GAAGH,EAAU,KAAKpB,EAAKa,CAAG,EAAEQ,EAAM,CAAC,CAAC,EAEjDD,EAAU,OAAQyC,GAAM,CAACA,EAAE,MAAM,CAC1C,EAKMgB,EAAkB,CACtB3C,EACAL,KAEAK,EAAQ,KAAK,CAACnB,EAAGC,IAAM,CACrB,MAAMmB,EAAKN,EAAO,IAAIE,EAAOhB,CAAC,CAAC,GAAK,IAC9BqB,EAAKP,EAAO,IAAIE,EAAOf,CAAC,CAAC,GAAK,IACpC,OAAOmB,EAAKC,CACd,CAAC,EACMF,EAAQ,MAAA,GAIjB,KAAOqC,EAAa,OAAS,GAAKI,EAAc,OAAS,GAAG,CAE1D,GAAIJ,EAAa,OAAS,EAAG,CAC3B,MAAMlC,EAAUwC,EAAgBN,EAAcF,CAAW,EACzD,GAAI,CAAChC,EAAS,MAEd,MAAMC,EAAaP,EAAOM,CAAO,EAIjC,GAHAiC,EAAe,IAAIhC,EAAY,EAAK,EAGhCD,EAAQ,OAAQ,SAGpB,GAAIkB,EAAkB,IAAIjB,CAAU,EAAG,CAErC,MAAMwC,GACHV,EAAY,IAAI9B,CAAU,GAAK,MAC/BkC,EAAa,IAAIlC,CAAU,GAAK,KAE/BwC,EAAWF,IACbA,EAAeE,EACflB,EAAatB,EAEjB,CAGA,UAAWnB,KAAYqB,EAAaH,CAAO,EAAG,CAC5C,MAAMI,EAAcV,EAAOZ,CAAQ,EAGnC,GACEmC,EAAiB,IAAIb,CAAW,GAChC,CAAC6B,EAAe,IAAI7B,CAAW,EAE/B,SAGF,MAAMC,GAAmB0B,EAAY,IAAI9B,CAAU,GAAK,KAAY,EAC9DK,EAAiByB,EAAY,IAAI3B,CAAW,GAAK,IAEvD,GAAIC,EAAkBC,IAEpBS,EAAgB,IAAIX,EAAaJ,CAAO,EACxC+B,EAAY,IAAI3B,EAAaC,CAAe,EAC5C2B,EAAY,IACV5B,EACAC,EAAkBlB,EAAkBL,EAAUjB,CAAU,CAAA,EAGrDoE,EAAe,IAAI7B,CAAW,IACjC8B,EAAa,KAAKpD,CAAQ,EAC1BmD,EAAe,IAAI7B,EAAa,EAAI,GAIlC,CAACa,EAAiB,IAAIb,CAAW,IACnCa,EAAiB,IAAIb,CAAW,EAChCtB,EAAS,UAAY,GACrBhB,EAAoB,KAAKgB,CAAQ,EAG7BoC,EAAkB,IAAId,CAAW,IAAG,CACtC,MAAMqC,EACJpC,GAAmB8B,EAAa,IAAI/B,CAAW,GAAK,KAClDqC,EAAWF,IACbA,EAAeE,EACflB,EAAanB,EAEjB,CAGN,CACF,CAGA,GAAIkC,EAAc,OAAS,EAAG,CAC5B,MAAMtC,EAAUwC,EAAgBF,EAAeF,CAAY,EAC3D,GAAI,CAACpC,EAAS,MAEd,MAAMC,EAAaP,EAAOM,CAAO,EAIjC,GAHAqC,EAAgB,IAAIpC,EAAY,EAAK,EAGjCD,EAAQ,OAAQ,SASpB,GANIA,IAAYnC,GAAc,CAACC,EAAoB,SAASD,CAAU,IACpEA,EAAW,UAAY,GACvBC,EAAoB,KAAKD,CAAU,GAIjCoD,EAAiB,IAAIhB,CAAU,EAAG,CAEpC,MAAMwC,GACHV,EAAY,IAAI9B,CAAU,GAAK,MAC/BkC,EAAa,IAAIlC,CAAU,GAAK,KAE/BwC,EAAWF,IACbA,EAAeE,EACflB,EAAatB,EAEjB,CAGA,UAAWnB,KAAYqB,EAAaH,CAAO,EAAG,CAC5C,MAAMI,EAAcV,EAAOZ,CAAQ,EAGnC,GACEoC,EAAkB,IAAId,CAAW,GACjC,CAACiC,EAAgB,IAAIjC,CAAW,EAEhC,SAGF,MAAMC,GAAmB8B,EAAa,IAAIlC,CAAU,GAAK,KAAY,EAC/DK,EAAiB6B,EAAa,IAAI/B,CAAW,GAAK,IAExD,GAAIC,EAAkBC,IAEpBU,EAAiB,IAAIZ,EAAaJ,CAAO,EACzCmC,EAAa,IAAI/B,EAAaC,CAAe,EAC7C+B,EAAa,IACXhC,EACAC,EAAkBlB,EAAkBL,EAAUlB,CAAS,CAAA,EAGpDyE,EAAgB,IAAIjC,CAAW,IAClCkC,EAAc,KAAKxD,CAAQ,EAC3BuD,EAAgB,IAAIjC,EAAa,EAAI,GAInC,CAACc,EAAkB,IAAId,CAAW,IACpCc,EAAkB,IAAId,CAAW,EACjCtB,EAAS,UAAY,GACrBhB,EAAoB,KAAKgB,CAAQ,EAG7BmC,EAAiB,IAAIb,CAAW,IAAG,CACrC,MAAMqC,GACHV,EAAY,IAAI3B,CAAW,GAAK,KAAYC,EAC3CoC,EAAWF,IACbA,EAAeE,EACflB,EAAanB,EAEjB,CAGN,CACF,CAIA,GACEmB,IAAe,MACfW,EAAa,OAAS,GACtBI,EAAc,OAAS,EACvB,CACA,MAAMI,EAAYV,EAAY,IAAItC,EAAOwC,EAAa,CAAC,CAAC,CAAC,GAAK,IACxDS,EAAaP,EAAa,IAAI1C,EAAO4C,EAAc,CAAC,CAAC,CAAC,GAAK,IAGjE,GAAII,EAAYC,GAAcJ,EAC5B,KAEJ,CACF,CAGA,GAAIhB,IAAe,KAAM,CAEvB,MAAME,EAAwB,CAAA,EAC9B,IAAIxB,EAA4BsB,EAChC,KAAOtB,IAAe,MAAM,CAC1BwB,EAAc,QAAQN,EAAelB,CAAU,CAAC,EAChD,MAAMyB,EAASX,EAAgB,IAAId,CAAU,EAC7CA,EAAayB,EAAShC,EAAOgC,CAAM,EAAI,IACzC,CAGA,MAAMC,EAAuB,CAAA,EACvBC,EAA0BZ,EAAiB,IAAIO,CAAU,EAI/D,IAHAtB,EAAa2B,EACTlC,EAAOkC,CAAuB,EAC9B,KACG3B,IAAe,MAAM,CAC1B0B,EAAa,KAAKR,EAAelB,CAAU,CAAC,EAC5C,MAAMyB,EAASV,EAAiB,IAAIf,CAAU,EAC9CA,EAAayB,EAAShC,EAAOgC,CAAM,EAAI,IACzC,CAGAb,EAAoB,CAAC,GAAGY,EAAe,GAAGE,CAAY,EAGtD,QAASE,EAAI,EAAGA,EAAIhB,EAAkB,OAAQgB,IAC5ChB,EAAkBgB,CAAC,EAAE,aAAehB,EAAkBgB,EAAI,CAAC,EAI7DhE,EAAW,UAAY,EACzB,CAEA,OAAOC,CACT,CASO,SAASM,GAA4BP,EAA0B,CAEpE,GAAIgD,EAAkB,OAAS,EAC7B,OAAOA,EAIT,MAAMxC,EAAmC,CAAA,EACzC,IAAIC,EAA2BT,EAG/B,GAAI,CAACA,EAAW,UACd,OAAOQ,EAGT,KAAOC,IAAgB,MACrBD,EAAyB,QAAQC,CAAW,EAC5CA,EAAcA,EAAY,aAG5B,OAAOD,CACT,CClXA,SAASc,EAAkBC,EAAaC,EAAqB,CAC3D,OAAO,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,EAAI,KAAK,IAAID,EAAM,IAAMC,EAAM,GAAG,CACzE,CAMA,MAAMuD,GAAiC,CACrC,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CACP,EAUO,SAASC,GACdlF,EACAC,EACAC,EACQ,CACR,MAAMC,EAA8B,CAAA,EAC9BmB,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGlB+B,EAAS,CAAClB,EAAaQ,IAAwB,GAAGR,CAAG,IAAIQ,CAAG,GAG5D8D,EAAa,CAACtE,EAAaQ,IAC3BR,EAAM,GAAKA,GAAOS,GAAWD,EAAM,GAAKA,GAAOE,EAAgB,GAC5D,CAACvB,EAAKa,CAAG,EAAEQ,CAAG,EAAE,OAInBO,MAAa,IACbC,MAAa,IACbuD,MAAe,IACftD,MAAgB,IAGtB,UAAWjB,KAAOb,EAChB,UAAWc,KAAQD,EAAK,CACtB,MAAMmB,EAAMD,EAAOjB,EAAK,IAAKA,EAAK,GAAG,EACrCc,EAAO,IAAII,EAAK,GAAQ,EACxBH,EAAO,IAAIG,EAAK,GAAQ,CAC1B,CAIF,MAAMC,EAAWF,EAAO9B,EAAU,IAAKA,EAAU,GAAG,EACpD2B,EAAO,IAAIK,EAAU,CAAC,EACtBJ,EAAO,IAAII,EAAUT,EAAkBvB,EAAWC,CAAU,CAAC,EAC7DkF,EAAS,IAAInD,EAAU,IAAI,EAI3B,MAAMC,EAKA,CAAA,EAGNA,EAAQ,KAAK,CACX,IAAKjC,EAAU,IACf,IAAKA,EAAU,IACf,OAAQ,EACR,OAAQ,CAAA,CACT,EACD6B,EAAU,IAAIG,EAAU,EAAI,EAS5B,MAAMoD,EAAO,CACXxE,EACAQ,EACAiE,EACAC,IACwC,CACxC,MAAMC,EAAU3E,EAAMyE,EAChBG,EAAUpE,EAAMkE,EAGtB,OAAKJ,EAAWK,EAASC,CAAO,EAK5BD,IAAYtF,EAAW,KAAOuF,IAAYvF,EAAW,IAChD,CAAE,IAAKsF,EAAS,IAAKC,CAAA,EAQ1BH,IAAW,IAIV,CAACH,EAAWK,EAAU,EAAGC,EAAUF,CAAM,GACxCJ,EAAWK,EAAU,EAAGC,CAAO,GAChC,CAACN,EAAWK,EAAU,EAAGC,EAAUF,CAAM,GACxCJ,EAAWK,EAAU,EAAGC,CAAO,GAE1B,CAAE,IAAKD,EAAS,IAAKC,CAAA,EAK5BF,IAAW,IAGV,CAACJ,EAAWK,EAAUF,EAAQG,EAAU,CAAC,GACxCN,EAAWK,EAASC,EAAU,CAAC,GAChC,CAACN,EAAWK,EAAUF,EAAQG,EAAU,CAAC,GACxCN,EAAWK,EAASC,EAAU,CAAC,GAE1B,CAAE,IAAKD,EAAS,IAAKC,CAAA,EAKzBJ,EAAKG,EAASC,EAASH,EAAQC,CAAM,EAxCnC,IAyCX,EAKMG,EAAqB,CACzB7E,EACAQ,EACAsE,EACAC,IACmC,CACnC,MAAMC,EAA6C,CAAA,EAGnD,IAAIC,EAEAH,IAAiB,GAAKC,IAAiB,EAEzCE,EAAoBb,GACXU,IAAiB,GAE1BG,EAAoB,CAAC,CAAC,EAAGF,CAAY,CAAC,EAIpC,CAACT,EAAWtE,EAAM,EAAGQ,EAAMuE,CAAY,GACvCT,EAAWtE,EAAM,EAAGQ,CAAG,GAEvByE,EAAkB,KAAK,CAAC,GAAI,CAAC,CAAC,EAG9B,CAACX,EAAWtE,EAAM,EAAGQ,EAAMuE,CAAY,GACvCT,EAAWtE,EAAM,EAAGQ,CAAG,GAEvByE,EAAkB,KAAK,CAAC,EAAG,CAAC,CAAC,IAI/BA,EAAoB,CAAC,CAACH,EAAc,CAAC,CAAC,EAIpC,CAACR,EAAWtE,EAAM8E,EAActE,EAAM,CAAC,GACvC8D,EAAWtE,EAAKQ,EAAM,CAAC,GAEvByE,EAAkB,KAAK,CAAC,EAAG,EAAE,CAAC,EAG9B,CAACX,EAAWtE,EAAM8E,EAActE,EAAM,CAAC,GACvC8D,EAAWtE,EAAKQ,EAAM,CAAC,GAEvByE,EAAkB,KAAK,CAAC,EAAG,CAAC,CAAC,GAKjC,SAAW,CAACC,EAAMC,CAAI,IAAKF,EAAmB,CAC5C,MAAMG,EAAYZ,EAAKxE,EAAKQ,EAAK0E,EAAMC,CAAI,EACvCC,GACFJ,EAAW,KAAKI,CAAS,CAE7B,CAEA,OAAOJ,CACT,EAGA,KAAO3D,EAAQ,OAAS,GAAG,CAEzBA,EAAQ,KAAK,CAACnB,EAAGC,IAAM,CACrB,MAAMmB,EAAKN,EAAO,IAAIE,EAAOhB,EAAE,IAAKA,EAAE,GAAG,CAAC,GAAK,IACzCqB,EAAKP,EAAO,IAAIE,EAAOf,EAAE,IAAKA,EAAE,GAAG,CAAC,GAAK,IAC/C,OAAOmB,EAAKC,CACd,CAAC,EAED,MAAMC,EAAUH,EAAQ,MAAA,EAClBI,EAAaP,EAAOM,EAAQ,IAAKA,EAAQ,GAAG,EAC5C1B,EAAcX,EAAKqC,EAAQ,GAAG,EAAEA,EAAQ,GAAG,EAKjD,GAHAP,EAAU,IAAIQ,EAAY,EAAK,EAG3B3B,EAAY,UAAW,SAO3B,GAJAA,EAAY,UAAY,GACxBR,EAAoB,KAAKQ,CAAW,EAGhC0B,EAAQ,MAAQnC,EAAW,KAAOmC,EAAQ,MAAQnC,EAAW,IAE/D,OAAAgG,GAAgBlG,EAAMoF,EAAUnF,EAAWC,CAAU,EAC9CC,EAIT,MAAM0F,EAAaH,EACjBrD,EAAQ,IACRA,EAAQ,IACRA,EAAQ,OACRA,EAAQ,MAAA,EAGV,UAAW8D,KAAaN,EAAY,CAClC,MAAMO,EAAerE,EAAOoE,EAAU,IAAKA,EAAU,GAAG,EAClDE,EAAgBrG,EAAKmG,EAAU,GAAG,EAAEA,EAAU,GAAG,EAEvD,GAAIE,EAAc,UAAW,SAG7B,MAAM3D,GACHd,EAAO,IAAIU,CAAU,GAAK,KAC3Bd,EAAkBb,EAAa0F,CAAa,EAE9C,GAAI3D,GAAmBd,EAAO,IAAIwE,CAAY,GAAK,KAAW,CAE5DhB,EAAS,IAAIgB,EAAc9D,CAAU,EACrCV,EAAO,IAAIwE,EAAc1D,CAAe,EACxCb,EAAO,IACLuE,EACA1D,EAAkBlB,EAAkB6E,EAAenG,CAAU,CAAA,EAI/D,MAAMoF,EACJa,EAAU,MAAQ9D,EAAQ,IACtB,EACA8D,EAAU,IAAM9D,EAAQ,IACxB,EACA,GACAkD,EACJY,EAAU,MAAQ9D,EAAQ,IACtB,EACA8D,EAAU,IAAM9D,EAAQ,IACxB,EACA,GAEDP,EAAU,IAAIsE,CAAY,IAC7BlE,EAAQ,KAAK,CACX,IAAKiE,EAAU,IACf,IAAKA,EAAU,IACf,OAAAb,EACA,OAAAC,CAAA,CACD,EACDzD,EAAU,IAAIsE,EAAc,EAAI,EAEpC,CACF,CACF,CAGA,OAAOjG,CACT,CAMA,SAAS+F,GACPlG,EACAoF,EACAkB,EACApG,EACM,CACN,MAAMqG,EAAe,CAAA,EACrB,IAAIjE,EAA4B,GAAGpC,EAAW,GAAG,IAAIA,EAAW,GAAG,GAGnE,MAAMsG,EAAqB,CAAA,EAC3B,KAAOlE,IAAe,MAAM,CAC1B,KAAM,CAACzB,EAAKQ,CAAG,EAAIiB,EAAW,MAAM,GAAG,EAAE,IAAI,MAAM,EACnDkE,EAAW,QAAQxG,EAAKa,CAAG,EAAEQ,CAAG,CAAC,EACjCiB,EAAa8C,EAAS,IAAI9C,CAAU,GAAK,IAC3C,CAGA,QAAS,EAAI,EAAG,EAAIkE,EAAW,OAAS,EAAG,IAAK,CAC9C,MAAMC,EAAOD,EAAW,CAAC,EACnBE,EAAKF,EAAW,EAAI,CAAC,EAG3B,IAAIG,EAAaF,EAAK,IAClBG,EAAaH,EAAK,IAEtB,KAAOE,IAAeD,EAAG,KAAOE,IAAeF,EAAG,KAAK,CACrD,MAAM5F,EAAOd,EAAK2G,CAAU,EAAEC,CAAU,EACpCL,EAAK,OAAS,IAChBzF,EAAK,aAAeyF,EAAKA,EAAK,OAAS,CAAC,GAE1CA,EAAK,KAAKzF,CAAI,EAGV6F,EAAaD,EAAG,IAAKC,IAChBA,EAAaD,EAAG,IAAKC,IACrBC,EAAaF,EAAG,IAAKE,IACrBA,EAAaF,EAAG,KAAKE,GAChC,CACF,CAGIJ,EAAW,OAAS,IACtBtG,EAAW,aAAeqG,EAAK,OAAS,EAAIA,EAAKA,EAAK,OAAS,CAAC,EAAI,KACpEA,EAAK,KAAKrG,CAAU,EAExB,CAQO,SAASO,GAA4BP,EAA0B,CACpE,MAAMQ,EAAmC,CAAA,EACzC,IAAIC,EAA2BT,EAG/B,GAAI,CAACA,EAAW,UACd,OAAOQ,EAGT,KAAOC,IAAgB,MACrBD,EAAyB,QAAQC,CAAW,EAC5CA,EAAcA,EAAY,aAG5B,OAAOD,CACT,CCvWO,SAASmG,GACd7G,EACAC,EACAC,EACQ,CACR,MAAM4G,EAAuB,CAAA,EACvBxF,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxB,OAAA+G,EACE/G,EACA,EACAsB,EAAU,EACV,EACAC,EAAU,EACVyF,EAAkB1F,EAASC,CAAO,EAClCuF,EACA7G,EACAC,CAAA,EAGK4G,CACT,CAMA,SAASC,EACP/G,EACAiH,EACAC,EACAC,EACAC,EACAC,EACAP,EACA7G,EACAC,EACM,CAEN,MAAMoH,EAASJ,EAASD,EAAW,EAC7BM,EAAQH,EAASD,EAAW,EAGlC,GAAI,EAAAG,EAAS,GAAKC,EAAQ,GAK1B,GAAIF,IAAgB,aAAwB,CAE1C,MAAMG,EAAeC,EAAeR,EAAW,EAAGC,EAAS,CAAC,EAC5D,GAAIM,EAAa,SAAW,EAAG,OAE/B,MAAME,EAAUF,EAAa,KAAK,MAAM,KAAK,OAAA,EAAWA,EAAa,MAAM,CAAC,EAGtEG,EAAeC,EAAcT,EAAUC,CAAM,EACnD,GAAIO,EAAa,SAAW,EAAG,OAE/B,MAAME,EAASF,EAAa,KAAK,MAAM,KAAK,OAAA,EAAWA,EAAa,MAAM,CAAC,EAG3E,QAAStG,EAAM8F,EAAU9F,GAAO+F,EAAQ/F,IAClCA,IAAQwG,IACRC,EAAgBJ,EAASrG,EAAKpB,EAAWC,CAAU,GAEvD4G,EAAa,KAAK9G,EAAK0H,CAAO,EAAErG,CAAG,CAAC,GAKtC0F,EACE/G,EACAiH,EACAS,EAAU,EACVP,EACAC,EACAJ,EAAkBU,EAAU,EAAIT,EAAW,EAAGM,CAAK,EACnDT,EACA7G,EACAC,CAAA,EAIF6G,EACE/G,EACA0H,EAAU,EACVR,EACAC,EACAC,EACAJ,EAAkBE,GAAUQ,EAAU,GAAK,EAAGH,CAAK,EACnDT,EACA7G,EACAC,CAAA,CAEJ,KAAO,CAEL,MAAM6H,EAAeN,EAAeN,EAAW,EAAGC,EAAS,CAAC,EAC5D,GAAIW,EAAa,SAAW,EAAG,OAE/B,MAAMC,EAAUD,EAAa,KAAK,MAAM,KAAK,OAAA,EAAWA,EAAa,MAAM,CAAC,EAGtEJ,EAAeC,EAAcX,EAAUC,CAAM,EACnD,GAAIS,EAAa,SAAW,EAAG,OAE/B,MAAMM,EAASN,EAAa,KAAK,MAAM,KAAK,OAAA,EAAWA,EAAa,MAAM,CAAC,EAG3E,QAAS9G,EAAMoG,EAAUpG,GAAOqG,EAAQrG,IAClCA,IAAQoH,IACRH,EAAgBjH,EAAKmH,EAAS/H,EAAWC,CAAU,GAEvD4G,EAAa,KAAK9G,EAAKa,CAAG,EAAEmH,CAAO,CAAC,GAKtCjB,EACE/G,EACAiH,EACAC,EACAC,EACAa,EAAU,EACVhB,EAAkBM,EAAQU,EAAU,EAAIb,EAAW,CAAC,EACpDL,EACA7G,EACAC,CAAA,EAIF6G,EACE/G,EACAiH,EACAC,EACAc,EAAU,EACVZ,EACAJ,EAAkBM,EAAQF,GAAUY,EAAU,GAAK,CAAC,EACpDlB,EACA7G,EACAC,CAAA,CAEJ,CACF,CAMA,SAAS8G,EAAkBM,EAAgBC,EAA4B,CACrE,OAAID,EAASC,EACJ,aACEA,EAAQD,EACV,WAGA,KAAK,OAAA,EAAW,GAAM,aAAyB,UAE1D,CAKA,SAASG,EAAeS,EAAeC,EAAuB,CAC5D,MAAMC,EAAmB,CAAA,EACzB,QAASlE,EAAIgE,EAAOhE,GAAKiE,EAAKjE,IACxBA,EAAI,IAAM,GACZkE,EAAO,KAAKlE,CAAC,EAGjB,OAAOkE,CACT,CAKA,SAASR,EAAcM,EAAeC,EAAuB,CAC3D,MAAMC,EAAmB,CAAA,EACzB,QAASlE,EAAIgE,EAAOhE,GAAKiE,EAAKjE,IACxBA,EAAI,IAAM,GACZkE,EAAO,KAAKlE,CAAC,EAGjB,OAAOkE,CACT,CAKA,SAASN,EACPjH,EACAQ,EACApB,EACAC,EACS,CACT,OACGW,IAAQZ,EAAU,KAAOoB,IAAQpB,EAAU,KAC3CY,IAAQX,EAAW,KAAOmB,IAAQnB,EAAW,GAElD,CCxMO,SAASmI,GACdrI,EACAC,EACAC,EACQ,CACR,MAAMoB,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGlBsI,EAAuB,MAAM,KAAK,CAAE,OAAQhH,CAAA,EAAW,IAC3D,MAAMC,CAAO,EAAE,KAAK,EAAK,CAAA,EAW3BgH,EAAMvI,EAJW,EACA,EAGesI,EAPA,CAAA,CAOwB,EAGxDE,EAAiBxI,EAAMC,EAAWqI,CAAO,EACzCE,EAAiBxI,EAAME,EAAYoI,CAAO,EAG1C,MAAMxB,EAAuB,CAAA,EAG7B,QAASjG,EAAM,EAAGA,EAAMS,EAAST,IAC/B,QAASQ,EAAM,EAAGA,EAAME,EAASF,IAC1BiH,EAAQzH,CAAG,EAAEQ,CAAG,GAEdyG,GAAgBjH,EAAKQ,EAAKpB,EAAWC,CAAU,GAClD4G,EAAa,KAAK9G,EAAKa,CAAG,EAAEQ,CAAG,CAAC,EAMxC,OAAOyF,CACT,CAMA,SAASyB,EACPvI,EACAa,EACAQ,EACAiH,EACAG,EACM,CACN,MAAMnH,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxBsI,EAAQzH,CAAG,EAAEQ,CAAG,EAAI,GACpBoH,EAAgB,KAAKzI,EAAKa,CAAG,EAAEQ,CAAG,CAAC,EAGnC,MAAMD,EAAYF,GAAsBL,EAAKQ,EAAKC,EAASC,EAAS+G,CAAO,EAG3EI,GAAatH,CAAS,EAGtB,UAAWD,KAAYC,EAAW,CAChC,KAAM,CAACoE,EAASC,CAAO,EAAItE,EAG3B,GAAI,CAACmH,EAAQ9C,CAAO,EAAEC,CAAO,EAAG,CAE9B,MAAMiC,EAAU7G,GAAO2E,EAAU3E,GAAO,EAClCmH,EAAU3G,GAAOoE,EAAUpE,GAAO,EACxCiH,EAAQZ,CAAO,EAAEM,CAAO,EAAI,GAC5BS,EAAgB,KAAKzI,EAAK0H,CAAO,EAAEM,CAAO,CAAC,EAG3CO,EAAMvI,EAAMwF,EAASC,EAAS6C,EAASG,CAAe,CACxD,CACF,CACF,CAMA,SAASvH,GACPL,EACAQ,EACAC,EACAC,EACA+G,EACoB,CACpB,MAAMlH,EAAgC,CAAA,EAGhCuH,EAAiC,CACrC,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,SAAW,CAAC5C,EAAMC,CAAI,IAAK2C,EAAY,CACrC,MAAMC,EAAS/H,EAAMkF,EACf8C,EAASxH,EAAM2E,EAGjB4C,GAAU,GAAKA,EAAStH,GAAWuH,GAAU,GAAKA,EAAStH,IACxD+G,EAAQM,CAAM,EAAEC,CAAM,GACzBzH,EAAU,KAAK,CAACwH,EAAQC,CAAM,CAAC,EAGrC,CAEA,OAAOzH,CACT,CAMA,SAASsH,GAAgBI,EAAkB,CACzC,QAAS5E,EAAI4E,EAAM,OAAS,EAAG5E,EAAI,EAAGA,IAAK,CACzC,MAAM6E,EAAI,KAAK,MAAM,KAAK,UAAY7E,EAAI,EAAE,EAC5C,CAAC4E,EAAM5E,CAAC,EAAG4E,EAAMC,CAAC,CAAC,EAAI,CAACD,EAAMC,CAAC,EAAGD,EAAM5E,CAAC,CAAC,CAC5C,CACF,CAMA,SAASsE,EACPxI,EACAc,EACAwH,EACM,CACN,MAAMhH,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGxBsI,EAAQxH,EAAK,GAAG,EAAEA,EAAK,GAAG,EAAI,GAG9B,MAAM6H,EAAiC,CACrC,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,SAAW,CAAC5C,EAAMC,CAAI,IAAK2C,EAAY,CACrC,MAAMC,EAAS9H,EAAK,IAAMiF,EACpB8C,EAAS/H,EAAK,IAAMkF,EAGtB4C,GAAU,GAAKA,EAAStH,GAAWuH,GAAU,GAAKA,EAAStH,IAC7D+G,EAAQM,CAAM,EAAEC,CAAM,EAAI,GAE9B,CACF,CAKA,SAASf,GACPjH,EACAQ,EACApB,EACAC,EACS,CACT,OACGW,IAAQZ,EAAU,KAAOoB,IAAQpB,EAAU,KAC3CY,IAAQX,EAAW,KAAOmB,IAAQnB,EAAW,GAElD,CClLO,SAAS8I,GACdhJ,EACAC,EACAC,EACQ,CACR,MAAMoB,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAIlBiJ,EAAyB,MAAM,KAAK,CAAE,OAAQ3H,CAAA,EAAW,IAC7D,MAAMC,CAAO,EAAE,KAAK,EAAK,CAAA,EAIrB2H,MAAiB,IAGjBC,EAA+B,CAAA,EAG/BpH,EAAS,CAAClB,EAAaQ,IAAwB,GAAGR,CAAG,IAAIQ,CAAG,GAI5D4F,EAAW,KAAK,IAAI,EAAG,KAAK,IAAI3F,EAAU,EAAGrB,EAAU,IAAM,CAAC,CAAC,EAC/DkH,EAAW,KAAK,IAAI,EAAG,KAAK,IAAI5F,EAAU,EAAGtB,EAAU,IAAM,CAAC,CAAC,EAiBrE,IAdAgJ,EAAUhC,CAAQ,EAAEE,CAAQ,EAAI,GAGhCiC,EACEnC,EACAE,EACA7F,EACAC,EACA0H,EACAE,EACAD,CAAA,EAIKC,EAAS,OAAS,GAAG,CAE1B,MAAME,EAAc,KAAK,MAAM,KAAK,OAAA,EAAWF,EAAS,MAAM,EACxD,CAACtI,EAAKQ,CAAG,EAAI8H,EAASE,CAAW,EAOvC,GAJAF,EAAS,OAAOE,EAAa,CAAC,EAC9BH,EAAW,OAAOnH,EAAOlB,EAAKQ,CAAG,CAAC,EAG9B4H,EAAUpI,CAAG,EAAEQ,CAAG,EACpB,SAIF,MAAMiI,EAAmBC,GACvB1I,EACAQ,EACAC,EACAC,EACA0H,CAAA,EAGF,GAAIK,EAAiB,OAAS,EAAG,CAE/B,KAAM,CAACE,EAAaC,CAAW,EAC7BH,EAAiB,KAAK,MAAM,KAAK,OAAA,EAAWA,EAAiB,MAAM,CAAC,EAGtEL,EAAUpI,CAAG,EAAEQ,CAAG,EAAI,GAGtB,MAAMqG,GAAW7G,EAAM2I,GAAe,EAChCxB,GAAW3G,EAAMoI,GAAe,EACtCR,EAAUvB,CAAO,EAAEM,CAAO,EAAI,GAG9BoB,EAAYvI,EAAKQ,EAAKC,EAASC,EAAS0H,EAAWE,EAAUD,CAAU,CACzE,CACF,CAGAQ,EAAoBzJ,EAAWgJ,EAAW3H,EAASC,CAAO,EAC1DmI,EAAoBxJ,EAAY+I,EAAW3H,EAASC,CAAO,EAG3DoI,EACE1J,EAAU,IACVA,EAAU,IACVgJ,EACA3H,EACAC,CAAA,EAEFoI,EACEzJ,EAAW,IACXA,EAAW,IACX+I,EACA3H,EACAC,CAAA,EAKF,MAAMuF,EAAuB,CAAA,EAE7B,QAASjG,EAAM,EAAGA,EAAMS,EAAST,IAC/B,QAASQ,EAAM,EAAGA,EAAME,EAASF,IAG5BR,IAAQZ,EAAU,KAAOoB,IAAQpB,EAAU,KAC3CY,IAAQX,EAAW,KAAOmB,IAAQnB,EAAW,KAM3C+I,EAAUpI,CAAG,EAAEQ,CAAG,GACrByF,EAAa,KAAK9G,EAAKa,CAAG,EAAEQ,CAAG,CAAC,EAMtC,OAAAqH,GAAa5B,CAAY,EAElBA,CACT,CAMA,SAASsC,EACPvI,EACAQ,EACAC,EACAC,EACA0H,EACAE,EACAD,EACM,CACN,MAAMP,EAAa,CACjB,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,SAAW,CAAC5C,EAAMC,CAAI,IAAK2C,EAAY,CACrC,MAAMC,EAAS/H,EAAMkF,EACf8C,EAASxH,EAAM2E,EAGrB,GACE4C,GAAU,GACVA,EAAStH,EAAU,GACnBuH,GAAU,GACVA,EAAStH,EAAU,EACnB,CACA,MAAMS,EAAM,GAAG4G,CAAM,IAAIC,CAAM,GAG3B,CAACI,EAAUL,CAAM,EAAEC,CAAM,GAAK,CAACK,EAAW,IAAIlH,CAAG,IACnDmH,EAAS,KAAK,CAACP,EAAQC,CAAM,CAAC,EAC9BK,EAAW,IAAIlH,CAAG,EAEtB,CACF,CACF,CAKA,SAASuH,GACP1I,EACAQ,EACAC,EACAC,EACA0H,EACoB,CACpB,MAAM7H,EAAgC,CAAA,EAChCuH,EAAa,CACjB,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,SAAW,CAAC5C,EAAMC,CAAI,IAAK2C,EAAY,CACrC,MAAMC,EAAS/H,EAAMkF,EACf8C,EAASxH,EAAM2E,EAGjB4C,GAAU,GAAKA,EAAStH,GAAWuH,GAAU,GAAKA,EAAStH,GACzD0H,EAAUL,CAAM,EAAEC,CAAM,GAC1BzH,EAAU,KAAK,CAACwH,EAAQC,CAAM,CAAC,CAGrC,CAEA,OAAOzH,CACT,CAKA,SAASsI,EACP5I,EACAmI,EACA3H,EACAC,EACM,CAEJT,EAAK,KAAO,GACZA,EAAK,IAAMQ,GACXR,EAAK,KAAO,GACZA,EAAK,IAAMS,IAEX0H,EAAUnI,EAAK,GAAG,EAAEA,EAAK,GAAG,EAAI,GAEpC,CAKA,SAAS6I,EACP1C,EACAE,EACA8B,EACA3H,EACAC,EACM,CAEN,MAAM+G,MAAc,IACdzF,EAAgD,CACpD,CAACoE,EAAUE,EAAU,CAAA,CAAE,CAAA,EAEzBmB,EAAQ,IAAI,GAAGrB,CAAQ,IAAIE,CAAQ,EAAE,EAErC,MAAMwB,EAAa,CACjB,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,KAAO9F,EAAM,OAAS,GAAG,CACvB,KAAM,CAAChC,EAAKQ,EAAKkF,CAAI,EAAI1D,EAAM,MAAA,EAG/B,GAAIoG,EAAUpI,CAAG,EAAEQ,CAAG,GAAKkF,EAAK,OAAS,EAAG,CAC1C,SAAW,CAACqD,EAAMC,CAAI,IAAKtD,EACzB0C,EAAUW,CAAI,EAAEC,CAAI,EAAI,GAE1B,MACF,CAGA,SAAW,CAAC9D,EAAMC,CAAI,IAAK2C,EAAY,CACrC,MAAMC,EAAS/H,EAAMkF,EACf8C,EAASxH,EAAM2E,EACfhE,EAAM,GAAG4G,CAAM,IAAIC,CAAM,GAG7BD,GAAU,GACVA,EAAStH,GACTuH,GAAU,GACVA,EAAStH,GACT,CAAC+G,EAAQ,IAAItG,CAAG,IAEhBsG,EAAQ,IAAItG,CAAG,EACfa,EAAM,KAAK,CAAC+F,EAAQC,EAAQ,CAAC,GAAGtC,EAAM,CAACqC,EAAQC,CAAM,CAAC,CAAC,CAAC,EAE5D,CACF,CACF,CAKA,SAASH,GAAgBI,EAAkB,CACzC,QAAS5E,EAAI4E,EAAM,OAAS,EAAG5E,EAAI,EAAGA,IAAK,CACzC,MAAM6E,EAAI,KAAK,MAAM,KAAK,UAAY7E,EAAI,EAAE,EAC5C,CAAC4E,EAAM5E,CAAC,EAAG4E,EAAMC,CAAC,CAAC,EAAI,CAACD,EAAMC,CAAC,EAAGD,EAAM5E,CAAC,CAAC,CAC5C,CACF,CC1RO,SAAS4F,GACd9J,EACAC,EACAC,EACQ,CACR,MAAM4G,EAAuB,CAAA,EACvBxF,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAGlB+J,MAAqB,IAC3BA,EAAe,IAAI,GAAG9J,EAAU,GAAG,IAAIA,EAAU,GAAG,EAAE,EACtD8J,EAAe,IAAI,GAAG7J,EAAW,GAAG,IAAIA,EAAW,GAAG,EAAE,EAGxD8J,EACE/J,EAAU,IACVA,EAAU,IACVqB,EACAC,EACAwI,CAAA,EAEFC,EACE9J,EAAW,IACXA,EAAW,IACXoB,EACAC,EACAwI,CAAA,EAMF,MAAME,EAAY,CAACpJ,EAAaQ,IAE1B,EAAAR,EAAM,GAAKA,GAAOS,GAAWD,EAAM,GAAKA,GAAOE,GAE/CwI,EAAe,IAAI,GAAGlJ,CAAG,IAAIQ,CAAG,EAAE,GAElCrB,EAAKa,CAAG,EAAEQ,CAAG,EAAE,SAAWrB,EAAKa,CAAG,EAAEQ,CAAG,EAAE,UAOzC6I,EAAU,CAACrJ,EAAaQ,IAAsB,CAC9C4I,EAAUpJ,EAAKQ,CAAG,GACpByF,EAAa,KAAK9G,EAAKa,CAAG,EAAEQ,CAAG,CAAC,CAEpC,EAIA,QAASA,EAAM,EAAGA,EAAME,EAASF,IAC/B6I,EAAQ,EAAG7I,CAAG,EAGhB,QAASA,EAAM,EAAGA,EAAME,EAASF,IAC/B6I,EAAQ5I,EAAU,EAAGD,CAAG,EAG1B,QAASR,EAAM,EAAGA,EAAMS,EAAU,EAAGT,IACnCqJ,EAAQrJ,EAAK,CAAC,EAGhB,QAASA,EAAM,EAAGA,EAAMS,EAAU,EAAGT,IACnCqJ,EAAQrJ,EAAKU,EAAU,CAAC,EAK1B,IAAI4I,EAAM,EACNC,EAAS9I,EAAU,EACnB+I,EAAO,EACPC,EAAQ/I,EAAU,EAClBgJ,EAAY,EAEhB,KAAOJ,EAAMC,EAAS,GAAKC,EAAOC,EAAQ,GAAG,CAG3C,MAAME,EAAUD,EAAY,EAG5B,QAASlJ,EAAMgJ,EAAMhJ,GAAOiJ,EAAOjJ,IACnBmJ,IAAY,GAAKnJ,IAAQ,KAAK,OAAOgJ,EAAOC,GAAS,CAAC,GAElEJ,EAAQC,EAAK9I,CAAG,EAKpB,QAASR,EAAMsJ,EAAM,EAAGtJ,GAAOuJ,EAAQvJ,IACvB2J,IAAY,GAAK3J,IAAQ,KAAK,OAAOsJ,EAAMC,GAAU,CAAC,GAElEF,EAAQrJ,EAAKyJ,CAAK,EAKtB,QAASjJ,EAAMiJ,EAAQ,EAAGjJ,GAAOgJ,EAAMhJ,IACvBmJ,IAAY,GAAKnJ,IAAQ,KAAK,OAAOgJ,EAAOC,GAAS,CAAC,GAElEJ,EAAQE,EAAQ/I,CAAG,EAKvB,QAASR,EAAMuJ,EAAS,EAAGvJ,EAAMsJ,EAAKtJ,IACtB2J,IAAY,GAAK3J,IAAQ,KAAK,OAAOsJ,EAAMC,GAAU,CAAC,GAElEF,EAAQrJ,EAAKwJ,CAAI,EAKrBF,GAAO,EACPC,GAAU,EACVC,GAAQ,EACRC,GAAS,EACTC,GACF,CAEA,OAAOzD,CACT,CAKA,SAASkD,EACPnJ,EACAQ,EACAC,EACAC,EACAwI,EACM,CACN,MAAMpB,EAAa,CACjB,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,SAAW,CAAC8B,EAAIC,CAAE,IAAK/B,EAAY,CACjC,MAAMC,EAAS/H,EAAM4J,EACf5B,EAASxH,EAAMqJ,EACjB9B,GAAU,GAAKA,EAAStH,GAAWuH,GAAU,GAAKA,EAAStH,GAC7DwI,EAAe,IAAI,GAAGnB,CAAM,IAAIC,CAAM,EAAE,CAE5C,CACF,CC1JA,MAAM8B,GAAyC,CAC7C,kBAAmB,GACnB,WAAY,EACZ,WAAY,EACZ,YAAa,CACf,EAUO,SAASC,GACd5K,EACAC,EACAC,EACQ,CACR,MAAMoB,EAAUtB,EAAK,OACfuB,EAAUvB,EAAK,CAAC,EAAE,OAClB6K,EAASF,GAGf,IAAIG,EAAyBC,GAC3BzJ,EACAC,EACAsJ,EAAO,kBACP5K,EACAC,CAAA,EAIF,QAAS8K,EAAM,EAAGA,EAAMH,EAAO,YAAaG,IAC1CF,EAAYG,GACVH,EACAxJ,EACAC,EACAsJ,EAAO,WACPA,EAAO,UAAA,EAKXK,EAAgBJ,EAAW7K,EAAU,IAAKA,EAAU,IAAKqB,EAASC,CAAO,EACzE2J,EAAgBJ,EAAW5K,EAAW,IAAKA,EAAW,IAAKoB,EAASC,CAAO,EAG3E4J,GACEL,EACA7K,EAAU,IACVA,EAAU,IACVC,EAAW,IACXA,EAAW,IACXoB,EACAC,CAAA,EAIF6J,GAAeN,EAAWxJ,EAASC,EAAStB,EAAWC,CAAU,EAGjE,MAAM4G,EAAuB,CAAA,EAGvBwB,MAAc,IACdvG,EAAS,CAACsJ,EAAWC,IAAc,GAAGD,CAAC,IAAIC,CAAC,GAGlD,QAASC,EAAQ,EAAGA,EAAQ,KAAK,IAAIjK,EAASC,CAAO,EAAI,EAAGgK,IAAS,CAEnE,QAASD,EAAIC,EAAOD,EAAI/J,EAAUgK,EAAOD,IAAK,CAC5C,MAAMD,EAAIE,EACNF,EAAI/J,GAAW,CAACgH,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,IAC1ChD,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,EACpBR,EAAUO,CAAC,EAAEC,CAAC,GAAK,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,SAAW,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,UACxDxE,EAAa,KAAK9G,EAAKqL,CAAC,EAAEC,CAAC,CAAC,EAGlC,CAEA,QAASD,EAAIE,EAAQ,EAAGF,EAAI/J,EAAUiK,EAAOF,IAAK,CAChD,MAAMC,EAAI/J,EAAU,EAAIgK,EACpBD,GAAK,GAAK,CAAChD,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,IACrChD,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,EACpBR,EAAUO,CAAC,EAAEC,CAAC,GAAK,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,SAAW,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,UACxDxE,EAAa,KAAK9G,EAAKqL,CAAC,EAAEC,CAAC,CAAC,EAGlC,CAEA,QAASA,EAAI/J,EAAU,EAAIgK,EAAOD,GAAKC,EAAOD,IAAK,CACjD,MAAMD,EAAI/J,EAAU,EAAIiK,EACpBF,GAAK,GAAK,CAAC/C,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,IACrChD,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,EACpBR,EAAUO,CAAC,EAAEC,CAAC,GAAK,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,SAAW,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,UACxDxE,EAAa,KAAK9G,EAAKqL,CAAC,EAAEC,CAAC,CAAC,EAGlC,CAEA,QAASD,EAAI/J,EAAU,EAAIiK,EAAOF,EAAIE,EAAOF,IAAK,CAChD,MAAMC,EAAIC,EACND,EAAI/J,GAAW,CAAC+G,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,IAC1ChD,EAAQ,IAAIvG,EAAOsJ,EAAGC,CAAC,CAAC,EACpBR,EAAUO,CAAC,EAAEC,CAAC,GAAK,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,SAAW,CAACtL,EAAKqL,CAAC,EAAEC,CAAC,EAAE,UACxDxE,EAAa,KAAK9G,EAAKqL,CAAC,EAAEC,CAAC,CAAC,EAGlC,CACF,CAEA,OAAOxE,CACT,CAKA,SAASiE,GACPzJ,EACAC,EACAiK,EACAvL,EACAC,EACa,CACb,MAAMuL,EAAqB,CAAA,EAE3B,QAAS,EAAI,EAAG,EAAInK,EAAS,IAAK,CAChC,MAAMT,EAAiB,CAAA,EACvB,QAASyK,EAAI,EAAGA,EAAI/J,EAAS+J,IAGxB,IAAMrL,EAAU,KAAOqL,IAAMrL,EAAU,KACvC,IAAMC,EAAW,KAAOoL,IAAMpL,EAAW,IAE1CW,EAAI,KAAK,EAAK,EAEdA,EAAI,KAAK,KAAK,OAAA,EAAW2K,CAAU,EAGvCC,EAAM,KAAK5K,CAAG,CAChB,CAEA,OAAO4K,CACT,CAKA,SAASR,GACPS,EACApK,EACAC,EACAoK,EACAC,EACa,CACb,MAAMC,EAAwB,CAAA,EAE9B,QAAS,EAAI,EAAG,EAAIvK,EAAS,IAAK,CAChC,MAAMT,EAAiB,CAAA,EACvB,QAASyK,EAAI,EAAGA,EAAI/J,EAAS+J,IAAK,CAChC,MAAMQ,EAAgBC,GACpBL,EACA,EACAJ,EACAhK,EACAC,CAAA,EAGEmK,EAAa,CAAC,EAAEJ,CAAC,EAGnBzK,EAAI,KAAKiL,GAAiBF,CAAU,EAIpC/K,EAAI,KAAKiL,GAAiBH,CAAU,CAExC,CACAE,EAAS,KAAKhL,CAAG,CACnB,CAEA,OAAOgL,CACT,CAKA,SAASE,GACPC,EACAnL,EACAQ,EACAC,EACAC,EACQ,CACR,IAAI0K,EAAQ,EAEZ,QAASxB,EAAK,GAAIA,GAAM,EAAGA,IACzB,QAASC,EAAK,GAAIA,GAAM,EAAGA,IAAM,CAC/B,GAAID,IAAO,GAAKC,IAAO,EAAG,SAE1B,MAAMwB,EAAKrL,EAAM4J,EACX0B,EAAK9K,EAAMqJ,EAGbwB,EAAK,GAAKA,GAAM5K,GAAW6K,EAAK,GAAKA,GAAM5K,GAGpCyK,EAAME,CAAE,EAAEC,CAAE,GACrBF,GAEJ,CAGF,OAAOA,CACT,CAKA,SAASf,EACPc,EACAnL,EACAQ,EACAC,EACAC,EACM,CAENyK,EAAMnL,CAAG,EAAEQ,CAAG,EAAI,GAElB,MAAMsH,EAAa,CACjB,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,SAAW,CAAC8B,EAAIC,CAAE,IAAK/B,EAAY,CACjC,MAAMuD,EAAKrL,EAAM4J,EACX0B,EAAK9K,EAAMqJ,EACbwB,GAAM,GAAKA,EAAK5K,GAAW6K,GAAM,GAAKA,EAAK5K,IAC7CyK,EAAME,CAAE,EAAEC,CAAE,EAAI,GAEpB,CACF,CAMA,SAAShB,GACPa,EACA/E,EACAE,EACAiF,EACAC,EACA/K,EACAC,EACM,CAEN,MAAM+K,MAAgB,IAChBvK,EAAS,CAACsJ,EAAWC,IAAc,GAAGD,CAAC,IAAIC,CAAC,GAE5CzI,EAA4B,CAAC,CAACoE,EAAUE,CAAQ,CAAC,EAGvD,IAFAmF,EAAU,IAAIvK,EAAOkF,EAAUE,CAAQ,CAAC,EAEjCtE,EAAM,OAAS,GAAG,CACvB,KAAM,CAACwI,EAAGC,CAAC,EAAIzI,EAAM,MAAA,EAEf8F,EAAa,CACjB,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAGP,SAAW,CAAC8B,EAAIC,CAAE,IAAK/B,EAAY,CACjC,MAAMuD,EAAKb,EAAIZ,EACT0B,EAAKb,EAAIZ,EACT1I,EAAMD,EAAOmK,EAAIC,CAAE,EAGvBD,GAAM,GACNA,EAAK5K,GACL6K,GAAM,GACNA,EAAK5K,GACL,CAACyK,EAAME,CAAE,EAAEC,CAAE,GACb,CAACG,EAAU,IAAItK,CAAG,IAElBsK,EAAU,IAAItK,CAAG,EACjBa,EAAM,KAAK,CAACqJ,EAAIC,CAAE,CAAC,EAEvB,CACF,CAGIG,EAAU,IAAIvK,EAAOqK,EAAWC,CAAS,CAAC,GAK9CE,GACEP,EACA/E,EACAE,EACAiF,EACAC,EACA/K,EACAC,CAAA,CAEJ,CAKA,SAASgL,GACPP,EACA/E,EACAE,EACAD,EACAE,EACA9F,EACAC,EACM,CACN,IAAI8J,EAAIpE,EACJqE,EAAInE,EAKR,IAFA6E,EAAMX,CAAC,EAAEC,CAAC,EAAI,GAEPD,IAAMnE,GAAUoE,IAAMlE,GAAQ,CAKnC,GAHA4E,EAAMX,CAAC,EAAEC,CAAC,EAAI,GAGV,KAAK,OAAA,EAAW,GAAK,CACvB,MAAM3C,EAAa,CACjB,CAAC,GAAI,CAAC,EACN,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,EAAE,EACN,CAAC,EAAG,CAAC,CAAA,EAED,CAAC8B,EAAIC,CAAE,EACX/B,EAAW,KAAK,MAAM,KAAK,OAAA,EAAWA,EAAW,MAAM,CAAC,EACpDuD,EAAKb,EAAIZ,EACT0B,EAAKb,EAAIZ,EACXwB,EAAK,GAAKA,EAAK5K,EAAU,GAAK6K,EAAK,GAAKA,EAAK5K,EAAU,IACzDyK,EAAME,CAAE,EAAEC,CAAE,EAAI,GAEpB,CAGqB,KAAK,OAAA,EAAW,IAEjBd,IAAMnE,EACxBmE,GAAKA,EAAInE,EAAS,EAAI,GACboE,IAAMlE,EACfkE,GAAKA,EAAIlE,EAAS,EAAI,GACbiE,IAAMnE,IACfmE,GAAKA,EAAInE,EAAS,EAAI,GAE1B,CAGA8E,EAAM9E,CAAM,EAAEE,CAAM,EAAI,EAC1B,CAKA,SAASgE,GACPY,EACA1K,EACAC,EACAtB,EACAC,EACM,CAEN,QAAS,EAAI,EAAG,EAAIqB,EAAS,IAEzB,EAAEtB,EAAU,MAAQ,GAAKA,EAAU,MAAQ,IAC3C,EAAEC,EAAW,MAAQ,GAAKA,EAAW,MAAQ,KAE7C8L,EAAM,CAAC,EAAE,CAAC,EAAI,IAGd,EAAE/L,EAAU,MAAQqB,EAAU,GAAKrB,EAAU,MAAQ,IACrD,EAAEC,EAAW,MAAQoB,EAAU,GAAKpB,EAAW,MAAQ,KAEvD8L,EAAM1K,EAAU,CAAC,EAAE,CAAC,EAAI,IAK5B,QAAS+J,EAAI,EAAGA,EAAI/J,EAAS+J,IAEzB,EAAEpL,EAAU,MAAQoL,GAAKpL,EAAU,MAAQ,IAC3C,EAAEC,EAAW,MAAQmL,GAAKnL,EAAW,MAAQ,KAE7C8L,EAAMX,CAAC,EAAE,CAAC,EAAI,IAGd,EAAEpL,EAAU,MAAQoL,GAAKpL,EAAU,MAAQsB,EAAU,IACrD,EAAErB,EAAW,MAAQmL,GAAKnL,EAAW,MAAQqB,EAAU,KAEvDyK,EAAMX,CAAC,EAAE9J,EAAU,CAAC,EAAI,GAG9B"}