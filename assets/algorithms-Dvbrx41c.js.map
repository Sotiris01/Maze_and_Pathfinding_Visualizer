{"version":3,"file":"algorithms-Dvbrx41c.js","sources":["../../src/algorithms/pathfinding/dijkstra.ts","../../src/algorithms/pathfinding/astar.ts","../../src/algorithms/pathfinding/bfs.ts","../../src/algorithms/pathfinding/dfs.ts","../../src/algorithms/maze/recursiveDivision.ts","../../src/algorithms/maze/randomizedDFS.ts"],"sourcesContent":["/**\r\n * Dijkstra's Algorithm Implementation\r\n * Phase B: Basic Pathfinding\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Dijkstra's algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize start node distance to 0 (all others are Infinity)\r\n * 2. Create list of all unvisited nodes\r\n * 3. Loop:\r\n *    - Sort unvisited by distance, pick closest\r\n *    - If closest is Infinity → trapped (no path)\r\n *    - If closest is wall → skip\r\n *    - If closest is finish → done\r\n *    - Update neighbors' distances and previousNode\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n */\r\nexport function dijkstra(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Initialize start node distance\r\n  startNode.distance = 0;\r\n\r\n  // Get all nodes as unvisited list\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length > 0) {\r\n    // Sort by distance (smallest first)\r\n    sortNodesByDistance(unvisitedNodes);\r\n\r\n    // Get the closest node\r\n    const closestNode = unvisitedNodes.shift()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If closest node has Infinity distance, we're trapped\r\n    // (no path exists to remaining nodes)\r\n    if (closestNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Update all unvisited neighbors\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by dijkstra)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Flattens the 2D grid into a 1D array of all nodes.\r\n */\r\nfunction getAllNodes(grid: Grid): Node[] {\r\n  const nodes: Node[] = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/**\r\n * Sorts nodes by distance in ascending order (in-place).\r\n * Note: Simple array sort is O(n log n). A Min-Heap would be O(log n)\r\n * for production, but this is acceptable for visualization purposes.\r\n */\r\nfunction sortNodesByDistance(unvisitedNodes: Node[]): void {\r\n  unvisitedNodes.sort((a, b) => a.distance - b.distance);\r\n}\r\n\r\n/**\r\n * Updates the distance and previousNode of all unvisited neighbors.\r\n * Each neighbor's distance = current distance + 1 (uniform cost)\r\n */\r\nfunction updateUnvisitedNeighbors(node: Node, grid: Grid): void {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Distance to neighbor is current distance + 1\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","/**\r\n * A* (A-Star) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * A* is an informed search algorithm that uses a heuristic to guide\r\n * its search towards the goal, making it more efficient than Dijkstra\r\n * for pathfinding problems.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement (up, down, left, right), the Manhattan distance\r\n * provides an admissible heuristic (never overestimates the actual cost).\r\n *\r\n * @param nodeA - First node\r\n * @param nodeB - Second node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize gScore (distance from start) and fScore (gScore + heuristic)\r\n * 2. Add startNode to Open Set\r\n * 3. Loop while Open Set is not empty:\r\n *    - Pop node with lowest fScore\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each neighbor:\r\n *      - Calculate tentative gScore\r\n *      - If tentative < neighbor's gScore:\r\n *        - Update neighbor's previousNode, gScore, fScore\r\n *        - Add to Open Set if not present\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Key Difference from Dijkstra:\r\n * - Dijkstra uses only distance from start (gScore)\r\n * - A* uses distance from start + estimated distance to goal (fScore)\r\n * - This heuristic guides the search towards the goal more efficiently\r\n */\r\nexport function astar(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Use Maps to track scores (avoid mutating Node objects in React state)\r\n  // Key: \"row-col\", Value: score\r\n  const gScore = new Map<string, number>();\r\n  const fScore = new Map<string, number>();\r\n  const inOpenSet = new Map<string, boolean>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScore.set(key, Infinity);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScore.set(startKey, 0);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n\r\n  // Open Set - nodes to be evaluated (sorted by fScore)\r\n  const openSet: Node[] = [startNode];\r\n  inOpenSet.set(startKey, true);\r\n\r\n  while (openSet.length > 0) {\r\n    // Sort by fScore and get node with lowest fScore\r\n    openSet.sort((a, b) => {\r\n      const fA = fScore.get(getKey(a)) ?? Infinity;\r\n      const fB = fScore.get(getKey(b)) ?? Infinity;\r\n      return fA - fB;\r\n    });\r\n\r\n    const current = openSet.shift()!;\r\n    const currentKey = getKey(current);\r\n    inOpenSet.set(currentKey, false);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (current.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Check if we're trapped (no path exists)\r\n    const currentGScore = gScore.get(currentKey) ?? Infinity;\r\n    if (currentGScore === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Calculate tentative gScore (current gScore + 1 for uniform cost)\r\n      const tentativeGScore = currentGScore + 1;\r\n\r\n      // If this path is better than any previous one\r\n      const neighborGScore = gScore.get(neighborKey) ?? Infinity;\r\n      if (tentativeGScore < neighborGScore) {\r\n        // Update the path - this is the best path to this neighbor so far\r\n        neighbor.previousNode = current;\r\n        gScore.set(neighborKey, tentativeGScore);\r\n        fScore.set(neighborKey, tentativeGScore + manhattanDistance(neighbor, finishNode));\r\n\r\n        // Add to open set if not already there\r\n        if (!inOpenSet.get(neighborKey)) {\r\n          openSet.push(neighbor);\r\n          inOpenSet.set(neighborKey, true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Reuses the same logic as Dijkstra since both use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by astar)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nexport default astar;\r\n","/**\r\n * Breadth-First Search (BFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * BFS explores nodes layer by layer, guaranteeing the shortest path\r\n * in an unweighted graph (all edges have equal cost).\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Breadth-First Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize a queue with the start node\r\n * 2. Mark start node as visited\r\n * 3. While queue is not empty:\r\n *    - Dequeue the first node (FIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Get all unvisited neighbors (up, down, left, right)\r\n *    - For each neighbor:\r\n *      - Mark as visited\r\n *      - Set previousNode pointer\r\n *      - Enqueue the neighbor\r\n *      - Add to visitedNodesInOrder\r\n * 4. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path in unweighted graphs\r\n * - Explores nodes level by level (breadth-first)\r\n * - Uses a Queue (FIFO) data structure\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function bfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Queue for BFS - FIFO (First In, First Out)\r\n  const queue: Node[] = [];\r\n\r\n  // Initialize: mark start as visited and enqueue\r\n  startNode.isVisited = true;\r\n  startNode.distance = 0;\r\n  queue.push(startNode);\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  while (queue.length > 0) {\r\n    // Dequeue the first node (FIFO)\r\n    const currentNode = queue.shift()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Mark as visited\r\n      neighbor.isVisited = true;\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Set distance (optional for BFS, but useful for consistency)\r\n      neighbor.distance = currentNode.distance + 1;\r\n\r\n      // Enqueue the neighbor\r\n      queue.push(neighbor);\r\n\r\n      // Record visit order for animation\r\n      visitedNodesInOrder.push(neighbor);\r\n\r\n      // Early exit: if we just added the finish node, we can return\r\n      if (neighbor === finishNode) {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Identical to Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by bfs)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default bfs;\r\n","/**\r\n * Depth-First Search (DFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * DFS explores as far as possible along each branch before backtracking.\r\n * Unlike BFS, DFS does NOT guarantee the shortest path.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Depth-First Search to find a path (not necessarily shortest).\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps (Iterative):\r\n * 1. Initialize a stack with the start node\r\n * 2. While stack is not empty:\r\n *    - Pop the last node (LIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If already visited → skip\r\n *    - Mark as visited and add to visitedNodesInOrder\r\n *    - Get all unvisited neighbors\r\n *    - For each neighbor:\r\n *      - Set previousNode pointer\r\n *      - Push to stack\r\n * 3. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path (explores depth-first)\r\n * - Uses a Stack (LIFO) data structure\r\n * - Memory efficient for deep paths\r\n * - Creates a \"snake-like\" movement pattern\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function dfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Stack for DFS - LIFO (Last In, First Out)\r\n  const stack: Node[] = [];\r\n\r\n  // Initialize: push start node onto stack\r\n  stack.push(startNode);\r\n\r\n  while (stack.length > 0) {\r\n    // Pop the last node (LIFO)\r\n    const currentNode = stack.pop()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (currentNode.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n\r\n    // Record visit order for animation\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    // Order: Up, Right, Down, Left\r\n    // Since stack is LIFO, we push in reverse order so Up is explored first\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Skip already visited\r\n      if (neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Push to stack\r\n      stack.push(neighbor);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n * (Identical to BFS/Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by dfs)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n * Warning: For DFS, this path is NOT necessarily the shortest!\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n *\r\n * Order: Up, Right, Down, Left (reversed for stack to create consistent movement)\r\n * Since stack is LIFO, the last pushed neighbor is explored first.\r\n * We push Left, Down, Right, Up so that Up is explored first.\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Push in reverse order for LIFO stack: Left, Down, Right, Up\r\n  // This makes DFS explore in order: Up, Right, Down, Left\r\n\r\n  // Left (pushed first, explored last)\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  // Up (pushed last, explored first)\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default dfs;\r\n","/**\r\n * Recursive Division Maze Generation Algorithm\r\n * Phase C: Maze Generation\r\n *\r\n * This algorithm creates a maze by recursively dividing the grid into chambers\r\n * and adding walls with gaps to ensure a solvable path.\r\n *\r\n * Key Concepts:\r\n * - Start with empty grid (no walls)\r\n * - Recursively divide into smaller chambers\r\n * - Each division adds a wall with exactly one gap\r\n * - Orientation based on chamber dimensions (height > width = horizontal)\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Orientation enum for wall placement\r\n */\r\nenum Orientation {\r\n  HORIZONTAL = 'horizontal',\r\n  VERTICAL = 'vertical',\r\n}\r\n\r\n/**\r\n * Main function to generate a Recursive Division maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must not be overwritten)\r\n * @param finishNode - The finish node (must not be overwritten)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getRecursiveDivisionMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const wallsInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Start recursive division on the full grid (no border walls)\r\n  divide(\r\n    grid,\r\n    0, // startRow (full grid)\r\n    numRows - 1, // endRow (full grid)\r\n    0, // startCol (full grid)\r\n    numCols - 1, // endCol (full grid)\r\n    chooseOrientation(numRows, numCols),\r\n    wallsInOrder,\r\n    startNode,\r\n    finishNode\r\n  );\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Recursive division function\r\n * Divides a chamber by adding a wall with a gap\r\n */\r\nfunction divide(\r\n  grid: Grid,\r\n  startRow: number,\r\n  endRow: number,\r\n  startCol: number,\r\n  endCol: number,\r\n  orientation: Orientation,\r\n  wallsInOrder: Node[],\r\n  startNode: Node,\r\n  finishNode: Node\r\n): void {\r\n  // Calculate chamber dimensions\r\n  const height = endRow - startRow + 1;\r\n  const width = endCol - startCol + 1;\r\n\r\n  // Base case: chamber too small to divide\r\n  if (height < 3 || width < 3) {\r\n    return;\r\n  }\r\n\r\n  // Choose where to place the wall and the gap\r\n  if (orientation === Orientation.HORIZONTAL) {\r\n    // Horizontal wall - pick a row (must be even to align with passages)\r\n    const possibleRows = getEvenNumbers(startRow + 1, endRow - 1);\r\n    if (possibleRows.length === 0) return;\r\n\r\n    const wallRow = possibleRows[Math.floor(Math.random() * possibleRows.length)];\r\n\r\n    // Pick a gap position (must be odd to align with passages)\r\n    const possibleGaps = getOddNumbers(startCol, endCol);\r\n    if (possibleGaps.length === 0) return;\r\n\r\n    const gapCol = possibleGaps[Math.floor(Math.random() * possibleGaps.length)];\r\n\r\n    // Build the wall with a gap\r\n    for (let col = startCol; col <= endCol; col++) {\r\n      if (col === gapCol) continue; // Leave the gap\r\n      if (isStartOrFinish(wallRow, col, startNode, finishNode)) continue;\r\n\r\n      wallsInOrder.push(grid[wallRow][col]);\r\n    }\r\n\r\n    // Recursively divide the two new chambers\r\n    // Top chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      wallRow - 1,\r\n      startCol,\r\n      endCol,\r\n      chooseOrientation(wallRow - 1 - startRow + 1, width),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n\r\n    // Bottom chamber\r\n    divide(\r\n      grid,\r\n      wallRow + 1,\r\n      endRow,\r\n      startCol,\r\n      endCol,\r\n      chooseOrientation(endRow - (wallRow + 1) + 1, width),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  } else {\r\n    // Vertical wall - pick a column (must be even to align with passages)\r\n    const possibleCols = getEvenNumbers(startCol + 1, endCol - 1);\r\n    if (possibleCols.length === 0) return;\r\n\r\n    const wallCol = possibleCols[Math.floor(Math.random() * possibleCols.length)];\r\n\r\n    // Pick a gap position (must be odd to align with passages)\r\n    const possibleGaps = getOddNumbers(startRow, endRow);\r\n    if (possibleGaps.length === 0) return;\r\n\r\n    const gapRow = possibleGaps[Math.floor(Math.random() * possibleGaps.length)];\r\n\r\n    // Build the wall with a gap\r\n    for (let row = startRow; row <= endRow; row++) {\r\n      if (row === gapRow) continue; // Leave the gap\r\n      if (isStartOrFinish(row, wallCol, startNode, finishNode)) continue;\r\n\r\n      wallsInOrder.push(grid[row][wallCol]);\r\n    }\r\n\r\n    // Recursively divide the two new chambers\r\n    // Left chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      endRow,\r\n      startCol,\r\n      wallCol - 1,\r\n      chooseOrientation(height, wallCol - 1 - startCol + 1),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n\r\n    // Right chamber\r\n    divide(\r\n      grid,\r\n      startRow,\r\n      endRow,\r\n      wallCol + 1,\r\n      endCol,\r\n      chooseOrientation(height, endCol - (wallCol + 1) + 1),\r\n      wallsInOrder,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Chooses wall orientation based on chamber dimensions\r\n * Prefers to divide along the longer axis\r\n */\r\nfunction chooseOrientation(height: number, width: number): Orientation {\r\n  if (height > width) {\r\n    return Orientation.HORIZONTAL;\r\n  } else if (width > height) {\r\n    return Orientation.VERTICAL;\r\n  } else {\r\n    // Square chamber - random choice\r\n    return Math.random() < 0.5 ? Orientation.HORIZONTAL : Orientation.VERTICAL;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets all even numbers in a range (inclusive)\r\n */\r\nfunction getEvenNumbers(start: number, end: number): number[] {\r\n  const result: number[] = [];\r\n  for (let i = start; i <= end; i++) {\r\n    if (i % 2 === 0) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Gets all odd numbers in a range (inclusive)\r\n */\r\nfunction getOddNumbers(start: number, end: number): number[] {\r\n  const result: number[] = [];\r\n  for (let i = start; i <= end; i++) {\r\n    if (i % 2 !== 0) {\r\n      result.push(i);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks if a position is the start or finish node\r\n */\r\nfunction isStartOrFinish(\r\n  row: number,\r\n  col: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean {\r\n  return (\r\n    (row === startNode.row && col === startNode.col) ||\r\n    (row === finishNode.row && col === finishNode.col)\r\n  );\r\n}\r\n\r\nexport default getRecursiveDivisionMaze;\r\n","/**\r\n * Randomized DFS (Recursive Backtracker) Maze Generation Algorithm\r\n * Phase C: Maze Generation\r\n *\r\n * This algorithm creates a maze by \"carving\" passages through a grid of walls.\r\n * It uses depth-first search with random neighbor selection to create\r\n * organic, winding passages with long corridors.\r\n *\r\n * Key Concepts:\r\n * - Start with a grid conceptually full of walls\r\n * - Carve passages using DFS with random neighbor order\r\n * - Each step moves 2 cells to leave room for walls between passages\r\n * - Results in a \"perfect maze\" (exactly one path between any two points)\r\n *\r\n * Output: Returns array of wall nodes for animation (inverse of carved passages)\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Tracks which cells have been visited during maze generation\r\n * true = passage (carved), false = wall (uncarved)\r\n */\r\ntype VisitedGrid = boolean[][];\r\n\r\n/**\r\n * Main function to generate a Randomized DFS maze\r\n *\r\n * @param grid - The current grid\r\n * @param startNode - The start node (must remain accessible)\r\n * @param finishNode - The finish node (must remain accessible)\r\n * @returns Array of nodes representing walls in the order they should be built\r\n */\r\nexport function getRandomizedDFSMaze(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Initialize visited grid - all false (all walls)\r\n  const visited: VisitedGrid = Array.from({ length: numRows }, () =>\r\n    Array(numCols).fill(false)\r\n  );\r\n\r\n  // Track the order of carved passages (for potential future use)\r\n  const passagesInOrder: Node[] = [];\r\n\r\n  // Start carving from position (0, 0) - full grid without border\r\n  const startRow = 0;\r\n  const startCol = 0;\r\n\r\n  // Carve the maze using recursive DFS\r\n  carve(grid, startRow, startCol, visited, passagesInOrder);\r\n\r\n  // Ensure start and finish nodes are passages (not walls)\r\n  ensureAccessible(grid, startNode, visited);\r\n  ensureAccessible(grid, finishNode, visited);\r\n\r\n  // Build the walls array - all non-passage cells become walls\r\n  const wallsInOrder: Node[] = [];\r\n\r\n  // Add all walls (cells that weren't carved as passages) - no border frame\r\n  for (let row = 0; row < numRows; row++) {\r\n    for (let col = 0; col < numCols; col++) {\r\n      if (!visited[row][col]) {\r\n        // This cell is a wall (not carved)\r\n        if (!isStartOrFinish(row, col, startNode, finishNode)) {\r\n          wallsInOrder.push(grid[row][col]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return wallsInOrder;\r\n}\r\n\r\n/**\r\n * Recursive carving function using DFS\r\n * Carves passages by visiting cells 2 steps apart\r\n */\r\nfunction carve(\r\n  grid: Grid,\r\n  row: number,\r\n  col: number,\r\n  visited: VisitedGrid,\r\n  passagesInOrder: Node[]\r\n): void {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Mark current cell as passage\r\n  visited[row][col] = true;\r\n  passagesInOrder.push(grid[row][col]);\r\n\r\n  // Get neighbors 2 cells away (to leave room for walls)\r\n  const neighbors = getUnvisitedNeighbors(row, col, numRows, numCols, visited);\r\n\r\n  // Shuffle neighbors for randomness\r\n  shuffleArray(neighbors);\r\n\r\n  // Visit each neighbor\r\n  for (const neighbor of neighbors) {\r\n    const [nextRow, nextCol] = neighbor;\r\n\r\n    // Check if still unvisited (might have been visited from another path)\r\n    if (!visited[nextRow][nextCol]) {\r\n      // Carve the wall between current and neighbor\r\n      const wallRow = row + (nextRow - row) / 2;\r\n      const wallCol = col + (nextCol - col) / 2;\r\n      visited[wallRow][wallCol] = true;\r\n      passagesInOrder.push(grid[wallRow][wallCol]);\r\n\r\n      // Recursively carve from neighbor\r\n      carve(grid, nextRow, nextCol, visited, passagesInOrder);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Gets unvisited neighbors 2 cells away\r\n * Used to ensure walls remain between passages\r\n */\r\nfunction getUnvisitedNeighbors(\r\n  row: number,\r\n  col: number,\r\n  numRows: number,\r\n  numCols: number,\r\n  visited: VisitedGrid\r\n): [number, number][] {\r\n  const neighbors: [number, number][] = [];\r\n\r\n  // Check 2 cells in each direction\r\n  const directions: [number, number][] = [\r\n    [-2, 0], // Up\r\n    [2, 0],  // Down\r\n    [0, -2], // Left\r\n    [0, 2],  // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = row + dRow;\r\n    const newCol = col + dCol;\r\n\r\n    // Check bounds (allow full grid edges)\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      if (!visited[newRow][newCol]) {\r\n        neighbors.push([newRow, newCol]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\n/**\r\n * Fisher-Yates shuffle algorithm\r\n * Randomizes the order of neighbors for maze variety\r\n */\r\nfunction shuffleArray<T>(array: T[]): void {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n}\r\n\r\n/**\r\n * Ensures a specific node and its surroundings are accessible (not walls)\r\n * Creates a small clearing around start/finish nodes\r\n */\r\nfunction ensureAccessible(\r\n  grid: Grid,\r\n  node: Node,\r\n  visited: VisitedGrid\r\n): void {\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Mark the node itself as passage\r\n  visited[node.row][node.col] = true;\r\n\r\n  // Also clear adjacent cells to ensure connectivity\r\n  const directions: [number, number][] = [\r\n    [-1, 0], // Up\r\n    [1, 0],  // Down\r\n    [0, -1], // Left\r\n    [0, 1],  // Right\r\n  ];\r\n\r\n  for (const [dRow, dCol] of directions) {\r\n    const newRow = node.row + dRow;\r\n    const newCol = node.col + dCol;\r\n\r\n    // Allow clearing cells at edges (full grid bounds)\r\n    if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols) {\r\n      visited[newRow][newCol] = true;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a position is the start or finish node\r\n */\r\nfunction isStartOrFinish(\r\n  row: number,\r\n  col: number,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): boolean {\r\n  return (\r\n    (row === startNode.row && col === startNode.col) ||\r\n    (row === finishNode.row && col === finishNode.col)\r\n  );\r\n}\r\n\r\nexport default getRandomizedDFSMaze;\r\n"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","getAllNodes","sortNodesByDistance","closestNode","updateUnvisitedNeighbors","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","nodes","row","node","a","b","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","neighbors","col","numRows","numCols","manhattanDistance","nodeA","nodeB","astar","gScore","fScore","inOpenSet","getKey","key","startKey","openSet","fA","fB","current","currentKey","currentGScore","getNeighbors","neighborKey","tentativeGScore","neighborGScore","bfs","queue","dfs","stack","getRecursiveDivisionMaze","wallsInOrder","divide","chooseOrientation","startRow","endRow","startCol","endCol","orientation","height","width","possibleRows","getEvenNumbers","wallRow","possibleGaps","getOddNumbers","gapCol","isStartOrFinish","possibleCols","wallCol","gapRow","start","end","result","i","getRandomizedDFSMaze","visited","carve","ensureAccessible","passagesInOrder","shuffleArray","nextRow","nextCol","directions","dRow","dCol","newRow","newCol","array","j"],"mappings":"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"}