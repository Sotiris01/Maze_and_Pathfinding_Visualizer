{"version":3,"mappings":"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","names":["AlgorithmType","MazeType","GRID_ROWS","GRID_COLS","createNode","row","col","startRow","startCol","finishRow","finishCol","getSafeNodePositions","rows","cols","getInitialGrid","grid","currentRow","MIN_WEIGHT","MAX_WEIGHT","getNewGridWithWallSet","newGrid","node","newNode","getNewGridWithWallRemoved","getNewGridWithStartMoved","newRow","newCol","targetNode","oldRow","oldCol","r","c","getNewGridWithFinishMoved","resetGridForPathfinding","clearWalls","getNewGridWithWeightIncremented","getNewGridWithWeightDecremented","HISTORY_STORAGE_KEY","MAX_HISTORY_ITEMS","AVAILABLE_MAZE_TYPES","getRandomMazeType","randomIndex","defaultContextValue","GridContext","createContext","useGridContext","context","useContext","useGrid","GridProvider","children","rowCount","setRowCount","useState","colCount","setColCount","setGrid","isMousePressed","setIsMousePressed","drawMode","setDrawMode","isVisualizing","setIsVisualizing","selectedAlgorithm","setSelectedAlgorithm","selectedMaze","setSelectedMaze","isRaceMode","setIsRaceMode","secondAlgorithm","setSecondAlgorithm","animationSpeed","setAnimationSpeed","visualizationStats","setVisualizationStats","toastMsg","setToastMsg","isHiddenTargetMode","setIsHiddenTargetMode","runHistory","setRunHistory","stored","useEffect","showToast","useCallback","msg","clearToast","addRunRecord","record","newRecord","prev","clearRunHistory","deleteRunRecord","id","resetBoard","resizeGrid","newRows","newCols","clampedRows","clampedCols","clearPath","currentGrid","clearAllWalls","value","jsx","NodeComponent","memo","isStart","isFinish","isWall","isVisited","isPath","weight","onMouseDown","onMouseEnter","onMouseUp","onTouchStart","getNodeClassName","classNames","styles","getWeightLabel","getAriaLabel","label","e","prevProps","nextProps","Board","containerRef","useRef","nodeSize","setNodeSize","isCtrlModeRef","isMousePressedRef","isDraggingStartRef","isDraggingFinishRef","drawModeRef","processedNodesRef","calculateNodeSize","container","containerWidth","containerHeight","availableWidth","availableHeight","maxSizeByWidth","maxSizeByHeight","calculatedSize","resizeObserver","handleMouseDown","event","currentDrawMode","isCtrlPressed","handleTouchStart","handleMouseEnter","nodeKey","handleTouchMove","touch","element","nodeElement","handleTouchEnd","handleMouseUp","handleGlobalMouseUp","handleDragStart","handleContextMenu","boardStyle","Accordion","title","icon","defaultOpen","controlledIsOpen","onToggle","internalIsOpen","setInternalIsOpen","isControlled","isOpen","contentRef","contentHeight","setContentHeight","height","handleToggle","handleKeyDown","jsxs","ALGORITHM_OPTIONS","MAZE_OPTIONS","TERRAIN_SMOOTHNESS_OPTIONS","MOBILE_BREAKPOINT","useIsMobile","isMobile","setIsMobile","checkMobile","ControlPanel","onVisualize","onClearPath","onGenerateMaze","onVisualizeRace","onMobileAction","terrainSmoothness","setTerrainSmoothness","terrainIntensity","setTerrainIntensity","activeGenSection","setActiveGenSection","algorithmSupportsWeights","isHeuristicAlgorithm","alg","option","o","isAlgorithmDisabled","handleAlgorithmChange","newAlgorithm","handleSecondAlgorithmChange","handleHiddenTargetToggle","newMode","handleRaceModeToggle","newRaceMode","defaultSecond","handleVisualize","handleMazeChange","handleTerrainSmoothnessChange","handleGenerateMaze","handleClearPath","handleResetBoard","handleClearBoard","handleGenerateTerrain","smoothnessOption","handleRowChange","handleColChange","handleSpeedChange","newSpeed","getSpeedLabel","selectedAlgoOption","weightedAlgos","unweightedAlgos","bidirectionalAlgos","Fragment","isDisabled","disabledReason","isSameAsAgent1","isDisabledByMode","legendItems","Legend","orientation","compact","item","Toast","isExiting","setIsExiting","exitTimer","clearTimer","toastType","getIcon","toastClasses","calculateWeightedPathLength","path","sum","DEFAULT_MIN_DURATION","requestIdCounter","useBenchmarking","workerRef","pendingRequests","getWorker","requestId","success","data","error","pending","errorObj","serializeGrid","findPositions","startPos","finishPos","runBenchmark","algorithm","minDuration","worker","positions","serializedGrid","resolve","reject","terminateWorker","useVisualization","isAnimating","timeoutIds","BENCHMARK_MIN_DURATION","clearAllTimeouts","clearVisualizationClasses","visitedNodes","pathNodes","visitedNodesSecond","pathNodesSecond","overlapNodes","pathOverlapNodes","clearVisualization","animateVisitedNodes","visitedNodesInOrder","speed","onComplete","i","timeoutId","animateShortestPath","nodesInShortestPathOrder","runAlgorithm","algorithmGrid","startNode","finishNode","astar","getAstarPath","bfs","getBfsPath","dfs","getDfsPath","greedyBestFirst","getGreedyPath","bidirectionalBFS","getBidirectionalPath","bidirectionalAStar","getBidirectionalAStarPath","jumpPointSearch","getJPSPath","dijkstra","getNodesInShortestPathOrder","visualizePathfinding","_setGrid","statsCallbacks","benchmarkResult","fallbackStart","fallbackTime","executionTime","pathFound","stats","pathDelay","clearWallClasses","clearWeightClasses","w","weightSpan","animateMazeWalls","wallsInOrder","animateTerrainMap","terrainNodes","batchSize","batchIndex","batch","terrain","generateMaze","mazeType","terrainConfig","resetGrid","clearedGrid","terrainNodesInOrder","isTerrain","getRecursiveDivisionMaze","getRandomizedDFSMaze","getPrimsMaze","getSpiralMaze","getCellularAutomataMaze","generateTerrainMap","wall","visualizeRace","algo1","algo2","benchmark1Result","benchmark2Result","b1","b2","createGridCopy","findNodes","g","start","finish","grid1","nodes1","fallback1Start","result1","fallback1Time","grid2","nodes2","fallback2Start","result2","fallback2Time","executionTime1","executionTime2","visited1","visited2","path1","path2","path1Found","path2Found","stats1","stats2","winner","weightedLength1","weightedLength2","raceStats","visitedByAgent1","visitedByAgent2","maxVisitedLen","node1","key1","element1","node2","key2","element2","path1Keys","path2Keys","maxPathLen","j","pathTimeoutId","pathNode1","pathNode2","winnerName","StatisticsSection","lazy","HistorySection","MainContent","statsSectionRef","isSidebarOpen","setIsSidebarOpen","hasGeneratedInitialMaze","setHasGeneratedInitialMaze","timer","toggleSidebar","closeSidebar","scrollToStats","_a","handleVisualizeRace","Suspense","App","ReactDOM","React"],"ignoreList":[],"sources":["../../src/types/index.ts","../../src/utils/gridUtils.ts","../../src/context/GridContext.tsx","../../src/components/Node/NodeComponent.tsx","../../src/components/Board/Board.tsx","../../src/components/Controls/Accordion.tsx","../../src/components/Controls/ControlPanel.tsx","../../src/components/Legend/Legend.tsx","../../src/components/UI/Toast.tsx","../../src/utils/pathUtils.ts","../../src/hooks/useBenchmarking.ts","../../src/hooks/useVisualization.ts","../../src/App.tsx","../../src/main.tsx"],"sourcesContent":["/**\r\n * Node Interface - Core data model for each cell in the grid\r\n * As specified in Section 3.1 of the project requirements\r\n */\r\nexport interface Node {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  distance: number; // For Dijkstra/A* - initialized to Infinity\r\n  previousNode: Node | null; // For backtracking the shortest path\r\n  weight: number; // Terrain weight: 1 = normal, higher = heavier terrain (e.g., 5, 10)\r\n}\r\n\r\n/**\r\n * Draw Mode - Determines what the user is painting on the grid\r\n */\r\nexport type DrawMode = \"WALL\" | \"WEIGHT\";\r\n\r\n/**\r\n * Grid Type - 2D array of Nodes\r\n */\r\nexport type Grid = Node[][];\r\n\r\n/**\r\n * Algorithm Types\r\n */\r\nexport enum AlgorithmType {\r\n  DIJKSTRA = \"dijkstra\",\r\n  ASTAR = \"astar\",\r\n  BFS = \"bfs\",\r\n  DFS = \"dfs\",\r\n  GREEDY_BEST_FIRST = \"greedyBestFirst\",\r\n  BIDIRECTIONAL_BFS = \"bidirectionalBFS\",\r\n  BIDIRECTIONAL_ASTAR = \"bidirectionalAStar\",\r\n  JUMP_POINT_SEARCH = \"jumpPointSearch\",\r\n}\r\n\r\n/**\r\n * Maze Generation Types\r\n */\r\nexport enum MazeType {\r\n  RECURSIVE_DIVISION = \"recursiveDivision\",\r\n  RANDOMIZED_DFS = \"randomizedDFS\",\r\n  PRIMS = \"prims\",\r\n  SPIRAL = \"spiral\",\r\n  CELLULAR_AUTOMATA = \"cellularAutomata\",\r\n  TERRAIN_MAP = \"terrainMap\",\r\n}\r\n\r\n/**\r\n * Terrain Generation Configuration\r\n * Used with TERRAIN_MAP maze type to control terrain smoothness\r\n */\r\nexport interface TerrainConfig {\r\n  /** Base frequency - lower = smoother terrain (default: 0.12) */\r\n  frequency: number;\r\n}\r\n\r\n/**\r\n * Node State for styling purposes\r\n */\r\nexport enum NodeState {\r\n  UNVISITED = \"unvisited\",\r\n  VISITED = \"visited\",\r\n  WALL = \"wall\",\r\n  START = \"start\",\r\n  FINISH = \"finish\",\r\n  PATH = \"path\",\r\n  WEIGHT_LIGHT = \"weight-light\",\r\n  WEIGHT_HEAVY = \"weight-heavy\",\r\n}\r\n\r\n/**\r\n * Algorithm Result - returned after algorithm execution\r\n */\r\nexport interface AlgorithmResult {\r\n  visitedNodesInOrder: Node[];\r\n  shortestPath: Node[];\r\n  executionTimeMs: number;\r\n  visitedCount: number;\r\n  pathLength: number;\r\n}\r\n\r\n/**\r\n * Run Record - stored in localStorage for history tracking\r\n */\r\nexport interface RunRecord {\r\n  id: string; // UUID\r\n  timestamp: number; // Unix timestamp for sorting\r\n  date: string; // ISO format for display\r\n  mode: \"Single\" | \"Race\";\r\n  algorithm1: string; // Display name of algorithm 1\r\n  algorithm2?: string; // Display name of algorithm 2 (Race mode only)\r\n  gridSize: string; // e.g., \"20x30\"\r\n  // Algorithm 1 stats\r\n  time1: number; // Execution time in ms\r\n  pathLength1: number;\r\n  visitedCount1: number;\r\n  // Algorithm 2 stats (Race mode only)\r\n  time2?: number;\r\n  pathLength2?: number;\r\n  visitedCount2?: number;\r\n  // Race mode result\r\n  winner?: string; // \"Algorithm 1 Name\" | \"Algorithm 2 Name\" | \"Tie\" | \"Both Failed\"\r\n}\r\n\r\n/**\r\n * Grid Configuration Constants\r\n */\r\nexport const GRID_ROWS = 20;\r\nexport const GRID_COLS = 30;\r\n// Default Start: Top-left corner (1,1) for nice padding from edge\r\nexport const DEFAULT_START_ROW = 1;\r\nexport const DEFAULT_START_COL = 1;\r\n// Default Finish: Center of the grid (calculated dynamically)\r\nexport const DEFAULT_FINISH_ROW = Math.floor(GRID_ROWS / 2);\r\nexport const DEFAULT_FINISH_COL = Math.floor(GRID_COLS / 2);\r\n","import { Node, Grid, GRID_ROWS, GRID_COLS } from \"../types\";\r\n\r\n/**\r\n * Creates a single Node with configurable start/finish positions\r\n */\r\nexport const createNode = (\r\n  row: number,\r\n  col: number,\r\n  startRow: number,\r\n  startCol: number,\r\n  finishRow: number,\r\n  finishCol: number\r\n): Node => {\r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === startRow && col === startCol,\r\n    isFinish: row === finishRow && col === finishCol,\r\n    isWall: false,\r\n    isVisited: false,\r\n    distance: Infinity,\r\n    previousNode: null,\r\n    weight: 1, // Default weight: 1 = normal terrain\r\n  };\r\n};\r\n\r\n/**\r\n * Calculates safe start/finish positions based on grid dimensions\r\n * Start: Top-left corner (1,1) with padding from edge\r\n * Finish: Exact center of the grid\r\n */\r\nexport const getSafeNodePositions = (\r\n  rows: number,\r\n  cols: number\r\n): {\r\n  startRow: number;\r\n  startCol: number;\r\n  finishRow: number;\r\n  finishCol: number;\r\n} => {\r\n  // Start node: Top-left corner with 1 cell padding from edge\r\n  // For very small grids (5x5), use row 1, col 1\r\n  const startRow = Math.min(1, rows - 2);\r\n  const startCol = Math.min(1, cols - 2);\r\n\r\n  // Finish node: Exact center of the grid\r\n  const finishRow = Math.floor(rows / 2);\r\n  const finishCol = Math.floor(cols / 2);\r\n\r\n  // Ensure start and finish don't overlap (for very small grids)\r\n  // If they would overlap, move finish slightly\r\n  if (startRow === finishRow && startCol === finishCol) {\r\n    // Move finish to bottom-right area for small grids\r\n    return {\r\n      startRow,\r\n      startCol,\r\n      finishRow: Math.max(startRow + 1, rows - 2),\r\n      finishCol: Math.max(startCol + 1, cols - 2),\r\n    };\r\n  }\r\n\r\n  return { startRow, startCol, finishRow, finishCol };\r\n};\r\n\r\n/**\r\n * Creates the initial grid with configurable dimensions\r\n * @param rows - Number of rows (default: GRID_ROWS = 30)\r\n * @param cols - Number of columns (default: GRID_COLS = 50)\r\n * Start and Finish nodes are placed safely within bounds\r\n */\r\nexport const getInitialGrid = (\r\n  rows: number = GRID_ROWS,\r\n  cols: number = GRID_COLS\r\n): Grid => {\r\n  const { startRow, startCol, finishRow, finishCol } = getSafeNodePositions(\r\n    rows,\r\n    cols\r\n  );\r\n  const grid: Grid = [];\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    const currentRow: Node[] = [];\r\n    for (let col = 0; col < cols; col++) {\r\n      currentRow.push(\r\n        createNode(row, col, startRow, startCol, finishRow, finishCol)\r\n      );\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n\r\n  return grid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with a wall toggled at the specified position\r\n */\r\nexport const getNewGridWithWallToggled = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow walls on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Weight constants\r\n */\r\nexport const MIN_WEIGHT = 1;\r\nexport const MAX_WEIGHT = 10;\r\n\r\n/**\r\n * Creates a new grid with wall TOGGLED to ON at the specified position\r\n * Used for WALL mode: Sets tile to wall () regardless of current weight\r\n * Skips if already a wall\r\n */\r\nexport const getNewGridWithWallSet = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow walls on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Already a wall, no change needed\r\n  if (node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: true,\r\n    weight: 1,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with wall TOGGLED to OFF at the specified position\r\n * Used for WALL mode: Sets tile to weight=1 (removes wall)\r\n * Skips if not a wall\r\n */\r\nexport const getNewGridWithWallRemoved = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't modify start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Not a wall, no change needed\r\n  if (!node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    isWall: false,\r\n    weight: 1,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Moves the start node to a new position\r\n * Auto-finds current Start position and overwrites walls at new position\r\n */\r\nexport const getNewGridWithStartMoved = (\r\n  grid: Grid,\r\n  newRow: number,\r\n  newCol: number\r\n): Grid => {\r\n  const targetNode = grid[newRow][newCol];\r\n\r\n  // Can't move to finish node or if already start\r\n  if (targetNode.isFinish || targetNode.isStart) {\r\n    return grid;\r\n  }\r\n\r\n  // Find current start position\r\n  let oldRow = -1;\r\n  let oldCol = -1;\r\n  for (let r = 0; r < grid.length; r++) {\r\n    for (let c = 0; c < grid[r].length; c++) {\r\n      if (grid[r][c].isStart) {\r\n        oldRow = r;\r\n        oldCol = c;\r\n        break;\r\n      }\r\n    }\r\n    if (oldRow !== -1) break;\r\n  }\r\n\r\n  // Safety check\r\n  if (oldRow === -1) return grid;\r\n\r\n  const newGrid = grid.map((row) => row.slice());\r\n\r\n  // Remove start from old position\r\n  newGrid[oldRow][oldCol] = {\r\n    ...newGrid[oldRow][oldCol],\r\n    isStart: false,\r\n  };\r\n\r\n  // Set start at new position (overwrites wall if present)\r\n  newGrid[newRow][newCol] = {\r\n    ...newGrid[newRow][newCol],\r\n    isStart: true,\r\n    isWall: false,\r\n  };\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Moves the finish node to a new position\r\n * Auto-finds current Finish position and overwrites walls at new position\r\n */\r\nexport const getNewGridWithFinishMoved = (\r\n  grid: Grid,\r\n  newRow: number,\r\n  newCol: number\r\n): Grid => {\r\n  const targetNode = grid[newRow][newCol];\r\n\r\n  // Can't move to start node or if already finish\r\n  if (targetNode.isStart || targetNode.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Find current finish position\r\n  let oldRow = -1;\r\n  let oldCol = -1;\r\n  for (let r = 0; r < grid.length; r++) {\r\n    for (let c = 0; c < grid[r].length; c++) {\r\n      if (grid[r][c].isFinish) {\r\n        oldRow = r;\r\n        oldCol = c;\r\n        break;\r\n      }\r\n    }\r\n    if (oldRow !== -1) break;\r\n  }\r\n\r\n  // Safety check\r\n  if (oldRow === -1) return grid;\r\n\r\n  const newGrid = grid.map((row) => row.slice());\r\n\r\n  // Remove finish from old position\r\n  newGrid[oldRow][oldCol] = {\r\n    ...newGrid[oldRow][oldCol],\r\n    isFinish: false,\r\n  };\r\n\r\n  // Set finish at new position (overwrites wall if present)\r\n  newGrid[newRow][newCol] = {\r\n    ...newGrid[newRow][newCol],\r\n    isFinish: true,\r\n    isWall: false,\r\n  };\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Resets the grid for a new pathfinding run (clears visited/path states)\r\n * Keeps walls, start, finish, and weights intact\r\n */\r\nexport const resetGridForPathfinding = (grid: Grid): Grid => {\r\n  return grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isVisited: false,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n      // weight is preserved\r\n    }))\r\n  );\r\n};\r\n\r\n/**\r\n * Clears all walls and weights from the grid\r\n */\r\nexport const clearWalls = (grid: Grid): Grid => {\r\n  return grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isWall: false,\r\n      weight: 1, // Reset to normal terrain\r\n    }))\r\n  );\r\n};\r\n\r\n/**\r\n * Completely resets the grid to initial state\r\n */\r\nexport const resetGrid = (): Grid => {\r\n  return getInitialGrid();\r\n};\r\n\r\n/**\r\n * Gets the node at a specific position\r\n */\r\nexport const getNode = (grid: Grid, row: number, col: number): Node | null => {\r\n  if (row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS) {\r\n    return null;\r\n  }\r\n  return grid[row][col];\r\n};\r\n\r\n/**\r\n * Gets all neighboring nodes (up, down, left, right)\r\n */\r\nexport const getNeighbors = (grid: Grid, node: Node): Node[] => {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]); // Up\r\n  if (row < GRID_ROWS - 1) neighbors.push(grid[row + 1][col]); // Down\r\n  if (col > 0) neighbors.push(grid[row][col - 1]); // Left\r\n  if (col < GRID_COLS - 1) neighbors.push(grid[row][col + 1]); // Right\r\n\r\n  return neighbors;\r\n};\r\n\r\n/**\r\n * Gets unvisited neighbors that are not walls\r\n */\r\nexport const getUnvisitedNeighbors = (grid: Grid, node: Node): Node[] => {\r\n  return getNeighbors(grid, node).filter(\r\n    (neighbor) => !neighbor.isVisited && !neighbor.isWall\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a new grid with the weight INCREMENTED at the specified position\r\n * Increments weight: 1  2  ...  10  wall ()\r\n * Returns unchanged grid if already a wall\r\n */\r\nexport const getNewGridWithWeightIncremented = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow changes on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Already a wall, no change (stop at wall)\r\n  if (node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  // At max weight (10), convert to wall\r\n  if (node.weight >= MAX_WEIGHT) {\r\n    const newNode: Node = {\r\n      ...node,\r\n      isWall: true,\r\n      weight: 1, // Reset weight when becoming wall\r\n    };\r\n    newGrid[row] = newGrid[row].slice();\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  // Increment weight by 1\r\n  const newNode: Node = {\r\n    ...node,\r\n    weight: node.weight + 1,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with the weight DECREMENTED at the specified position\r\n * Decrements weight: wall ()  10  ...  2  1\r\n * Returns unchanged grid if already at min weight (1)\r\n */\r\nexport const getNewGridWithWeightDecremented = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow changes on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Wall: convert to max weight (10)\r\n  if (node.isWall) {\r\n    const newNode: Node = {\r\n      ...node,\r\n      isWall: false,\r\n      weight: MAX_WEIGHT,\r\n    };\r\n    newGrid[row] = newGrid[row].slice();\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  // Already at min weight (1), no change\r\n  if (node.weight <= MIN_WEIGHT) {\r\n    return grid;\r\n  }\r\n\r\n  // Decrement weight by 1\r\n  const newNode: Node = {\r\n    ...node,\r\n    weight: node.weight - 1,\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n\r\n/**\r\n * Creates a new grid with the weight SET at the specified position\r\n * Used for consistent drag-to-paint weight functionality\r\n * Note: Adding weight removes any wall on the node\r\n */\r\nexport const getNewGridWithWeightSet = (\r\n  grid: Grid,\r\n  row: number,\r\n  col: number,\r\n  weight: number\r\n): Grid => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n\r\n  // Don't allow weights on start or finish nodes\r\n  if (node.isStart || node.isFinish) {\r\n    return grid;\r\n  }\r\n\r\n  // Already has this weight, no change needed\r\n  if (node.weight === weight && !node.isWall) {\r\n    return grid;\r\n  }\r\n\r\n  const newNode: Node = {\r\n    ...node,\r\n    weight,\r\n    isWall: false, // Remove wall when setting weight\r\n  };\r\n\r\n  newGrid[row] = newGrid[row].slice();\r\n  newGrid[row][col] = newNode;\r\n\r\n  return newGrid;\r\n};\r\n","import React, {\r\n  createContext,\r\n  useContext,\r\n  useState,\r\n  useCallback,\r\n  useEffect,\r\n  ReactNode,\r\n} from \"react\";\r\nimport {\r\n  Grid,\r\n  AlgorithmType,\r\n  MazeType,\r\n  RunRecord,\r\n  DrawMode,\r\n  GRID_ROWS,\r\n  GRID_COLS,\r\n} from \"../types\";\r\nimport {\r\n  getInitialGrid,\r\n  resetGridForPathfinding,\r\n  clearWalls,\r\n} from \"../utils/gridUtils\";\r\nimport { AlgorithmStats, RaceStats } from \"../components/Modals/StatsModal\";\r\n\r\nconst HISTORY_STORAGE_KEY = \"pathfinder_run_history\";\r\nconst MAX_HISTORY_ITEMS = 50;\r\n\r\n/**\r\n * Available maze types for random selection\r\n */\r\nconst AVAILABLE_MAZE_TYPES: MazeType[] = [\r\n  MazeType.RECURSIVE_DIVISION,\r\n  MazeType.RANDOMIZED_DFS,\r\n  MazeType.PRIMS,\r\n  MazeType.SPIRAL,\r\n];\r\n\r\n/**\r\n * Get a random maze type from available options\r\n */\r\nconst getRandomMazeType = (): MazeType => {\r\n  const randomIndex = Math.floor(Math.random() * AVAILABLE_MAZE_TYPES.length);\r\n  return AVAILABLE_MAZE_TYPES[randomIndex];\r\n};\r\n\r\n/**\r\n * Grid Context Type Definition\r\n */\r\ninterface GridContextType {\r\n  // Grid State\r\n  grid: Grid;\r\n  setGrid: React.Dispatch<React.SetStateAction<Grid>>;\r\n\r\n  // Grid Dimensions\r\n  rowCount: number;\r\n  colCount: number;\r\n  resizeGrid: (newRows: number, newCols: number) => void;\r\n\r\n  // Mouse State (for wall drawing)\r\n  isMousePressed: boolean;\r\n  setIsMousePressed: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Draw Mode (Wall or Weight painting)\r\n  drawMode: DrawMode;\r\n  setDrawMode: React.Dispatch<React.SetStateAction<DrawMode>>;\r\n\r\n  // Visualization State\r\n  isVisualizing: boolean;\r\n  setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Algorithm Selection\r\n  selectedAlgorithm: AlgorithmType;\r\n  setSelectedAlgorithm: React.Dispatch<React.SetStateAction<AlgorithmType>>;\r\n\r\n  // Race Mode State\r\n  isRaceMode: boolean;\r\n  setIsRaceMode: React.Dispatch<React.SetStateAction<boolean>>;\r\n  secondAlgorithm: AlgorithmType | null;\r\n  setSecondAlgorithm: React.Dispatch<\r\n    React.SetStateAction<AlgorithmType | null>\r\n  >;\r\n\r\n  // Maze Selection\r\n  selectedMaze: MazeType;\r\n  setSelectedMaze: React.Dispatch<React.SetStateAction<MazeType>>;\r\n\r\n  // Speed Control (delay in ms)\r\n  animationSpeed: number;\r\n  setAnimationSpeed: React.Dispatch<React.SetStateAction<number>>;\r\n\r\n  // Visualization Stats (for Statistics Section)\r\n  visualizationStats: AlgorithmStats | RaceStats | null;\r\n  setVisualizationStats: React.Dispatch<\r\n    React.SetStateAction<AlgorithmStats | RaceStats | null>\r\n  >;\r\n\r\n  // Toast Notification State\r\n  toastMsg: string | null;\r\n  showToast: (msg: string) => void;\r\n  clearToast: () => void;\r\n\r\n  // Hidden Target Mode (Fog of War)\r\n  isHiddenTargetMode: boolean;\r\n  setIsHiddenTargetMode: React.Dispatch<React.SetStateAction<boolean>>;\r\n\r\n  // Run History\r\n  runHistory: RunRecord[];\r\n  addRunRecord: (record: Omit<RunRecord, \"id\" | \"timestamp\" | \"date\">) => void;\r\n  clearRunHistory: () => void;\r\n  deleteRunRecord: (id: string) => void;\r\n\r\n  // Helper Functions\r\n  resetBoard: () => void;\r\n  clearPath: () => void;\r\n  clearAllWalls: () => void;\r\n}\r\n\r\n/**\r\n * Default Context Value\r\n */\r\nconst defaultContextValue: GridContextType = {\r\n  grid: [],\r\n  setGrid: () => {},\r\n  rowCount: GRID_ROWS,\r\n  colCount: GRID_COLS,\r\n  resizeGrid: () => {},\r\n  isMousePressed: false,\r\n  setIsMousePressed: () => {},\r\n  drawMode: \"WALL\",\r\n  setDrawMode: () => {},\r\n  isVisualizing: false,\r\n  setIsVisualizing: () => {},\r\n  selectedAlgorithm: AlgorithmType.DIJKSTRA,\r\n  setSelectedAlgorithm: () => {},\r\n  isRaceMode: false,\r\n  setIsRaceMode: () => {},\r\n  secondAlgorithm: null,\r\n  setSecondAlgorithm: () => {},\r\n  selectedMaze: MazeType.RECURSIVE_DIVISION,\r\n  setSelectedMaze: () => {},\r\n  animationSpeed: 10,\r\n  setAnimationSpeed: () => {},\r\n  visualizationStats: null,\r\n  setVisualizationStats: () => {},\r\n  toastMsg: null,\r\n  showToast: () => {},\r\n  clearToast: () => {},\r\n  isHiddenTargetMode: false,\r\n  setIsHiddenTargetMode: () => {},\r\n  runHistory: [],\r\n  addRunRecord: () => {},\r\n  clearRunHistory: () => {},\r\n  deleteRunRecord: () => {},\r\n  resetBoard: () => {},\r\n  clearPath: () => {},\r\n  clearAllWalls: () => {},\r\n};\r\n\r\n/**\r\n * Create the Context\r\n */\r\nconst GridContext = createContext<GridContextType>(defaultContextValue);\r\n\r\n/**\r\n * Custom Hook to use Grid Context\r\n */\r\nexport const useGridContext = (): GridContextType => {\r\n  const context = useContext(GridContext);\r\n  if (!context) {\r\n    throw new Error(\"useGridContext must be used within a GridProvider\");\r\n  }\r\n  return context;\r\n};\r\n\r\n// Alias for shorter import in components\r\nexport const useGrid = useGridContext;\r\n\r\n/**\r\n * Provider Props\r\n */\r\ninterface GridProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\n/**\r\n * Grid Provider Component\r\n */\r\nexport const GridProvider: React.FC<GridProviderProps> = ({ children }) => {\r\n  // Grid Dimension State\r\n  const [rowCount, setRowCount] = useState<number>(GRID_ROWS);\r\n  const [colCount, setColCount] = useState<number>(GRID_COLS);\r\n\r\n  // Core Grid State\r\n  const [grid, setGrid] = useState<Grid>(() =>\r\n    getInitialGrid(GRID_ROWS, GRID_COLS)\r\n  );\r\n\r\n  // Mouse State for wall drawing\r\n  const [isMousePressed, setIsMousePressed] = useState<boolean>(false);\r\n\r\n  // Draw Mode State (Wall or Weight painting)\r\n  const [drawMode, setDrawMode] = useState<DrawMode>(\"WALL\");\r\n\r\n  // Visualization State\r\n  const [isVisualizing, setIsVisualizing] = useState<boolean>(false);\r\n\r\n  // Algorithm Selection\r\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState<AlgorithmType>(\r\n    AlgorithmType.DIJKSTRA\r\n  );\r\n\r\n  // Maze Selection - initialized with random maze type for first paint experience\r\n  const [selectedMaze, setSelectedMaze] = useState<MazeType>(getRandomMazeType);\r\n\r\n  // Race Mode State\r\n  const [isRaceMode, setIsRaceMode] = useState<boolean>(false);\r\n  const [secondAlgorithm, setSecondAlgorithm] = useState<AlgorithmType | null>(\r\n    null\r\n  );\r\n\r\n  // Animation Speed (delay between node animations in ms)\r\n  const [animationSpeed, setAnimationSpeed] = useState<number>(10);\r\n\r\n  // Visualization Stats (displayed in Statistics Section)\r\n  const [visualizationStats, setVisualizationStats] = useState<\r\n    AlgorithmStats | RaceStats | null\r\n  >(null);\r\n\r\n  // Toast Notification State\r\n  const [toastMsg, setToastMsg] = useState<string | null>(null);\r\n\r\n  // Hidden Target Mode State (Fog of War)\r\n  const [isHiddenTargetMode, setIsHiddenTargetMode] = useState<boolean>(false);\r\n\r\n  // Run History State with localStorage persistence\r\n  const [runHistory, setRunHistory] = useState<RunRecord[]>(() => {\r\n    try {\r\n      const stored = localStorage.getItem(HISTORY_STORAGE_KEY);\r\n      if (stored) {\r\n        return JSON.parse(stored) as RunRecord[];\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to load history from localStorage:\", error);\r\n      localStorage.removeItem(HISTORY_STORAGE_KEY);\r\n    }\r\n    return [];\r\n  });\r\n\r\n  // Persist history to localStorage whenever it changes\r\n  useEffect(() => {\r\n    try {\r\n      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(runHistory));\r\n    } catch (error) {\r\n      console.error(\"Failed to save history to localStorage:\", error);\r\n    }\r\n  }, [runHistory]);\r\n\r\n  /**\r\n   * Shows a toast notification message\r\n   */\r\n  const showToast = useCallback((msg: string): void => {\r\n    setToastMsg(msg);\r\n  }, []);\r\n\r\n  /**\r\n   * Clears the current toast notification\r\n   */\r\n  const clearToast = useCallback((): void => {\r\n    setToastMsg(null);\r\n  }, []);\r\n\r\n  /**\r\n   * Adds a new run record to history\r\n   */\r\n  const addRunRecord = useCallback(\r\n    (record: Omit<RunRecord, \"id\" | \"timestamp\" | \"date\">): void => {\r\n      const newRecord: RunRecord = {\r\n        ...record,\r\n        id: crypto.randomUUID(),\r\n        timestamp: Date.now(),\r\n        date: new Date().toISOString(),\r\n      };\r\n      setRunHistory((prev) => {\r\n        const updated = [newRecord, ...prev];\r\n        return updated.slice(0, MAX_HISTORY_ITEMS);\r\n      });\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Clears all run history\r\n   */\r\n  const clearRunHistory = useCallback((): void => {\r\n    setRunHistory([]);\r\n  }, []);\r\n\r\n  /**\r\n   * Deletes a single run record by ID\r\n   */\r\n  const deleteRunRecord = useCallback((id: string): void => {\r\n    setRunHistory((prev) => prev.filter((record) => record.id !== id));\r\n  }, []);\r\n\r\n  /**\r\n   * Resets the entire board to initial state with current dimensions\r\n   */\r\n  const resetBoard = useCallback((): void => {\r\n    if (isVisualizing) return; // Don't reset while visualizing\r\n    setGrid(getInitialGrid(rowCount, colCount));\r\n  }, [isVisualizing, rowCount, colCount]);\r\n\r\n  /**\r\n   * Resizes the grid to new dimensions\r\n   * Generates a completely new grid (walls are cleared)\r\n   */\r\n  const resizeGrid = useCallback(\r\n    (newRows: number, newCols: number): void => {\r\n      if (isVisualizing) return; // Don't resize while visualizing\r\n\r\n      // Clamp values to reasonable bounds\r\n      const clampedRows = Math.max(5, Math.min(50, newRows));\r\n      const clampedCols = Math.max(5, Math.min(80, newCols));\r\n\r\n      setRowCount(clampedRows);\r\n      setColCount(clampedCols);\r\n      setGrid(getInitialGrid(clampedRows, clampedCols));\r\n    },\r\n    [isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Clears only the path/visited nodes, keeps walls\r\n   */\r\n  const clearPath = useCallback((): void => {\r\n    if (isVisualizing) return;\r\n    setGrid((currentGrid) => resetGridForPathfinding(currentGrid));\r\n  }, [isVisualizing]);\r\n\r\n  /**\r\n   * Clears all walls from the grid\r\n   */\r\n  const clearAllWalls = useCallback((): void => {\r\n    if (isVisualizing) return;\r\n    setGrid((currentGrid) => clearWalls(currentGrid));\r\n  }, [isVisualizing]);\r\n\r\n  const value: GridContextType = {\r\n    grid,\r\n    setGrid,\r\n    rowCount,\r\n    colCount,\r\n    resizeGrid,\r\n    isMousePressed,\r\n    setIsMousePressed,\r\n    drawMode,\r\n    setDrawMode,\r\n    isVisualizing,\r\n    setIsVisualizing,\r\n    selectedAlgorithm,\r\n    setSelectedAlgorithm,\r\n    isRaceMode,\r\n    setIsRaceMode,\r\n    secondAlgorithm,\r\n    setSecondAlgorithm,\r\n    selectedMaze,\r\n    setSelectedMaze,\r\n    animationSpeed,\r\n    setAnimationSpeed,\r\n    visualizationStats,\r\n    setVisualizationStats,\r\n    toastMsg,\r\n    showToast,\r\n    clearToast,\r\n    isHiddenTargetMode,\r\n    setIsHiddenTargetMode,\r\n    runHistory,\r\n    addRunRecord,\r\n    clearRunHistory,\r\n    deleteRunRecord,\r\n    resetBoard,\r\n    clearPath,\r\n    clearAllWalls,\r\n  };\r\n\r\n  return <GridContext.Provider value={value}>{children}</GridContext.Provider>;\r\n};\r\n\r\nexport default GridContext;\r\n","import React, { memo } from \"react\";\r\nimport { useGridContext } from \"../../context/GridContext\";\r\nimport styles from \"./Node.module.css\";\r\n\r\n/**\r\n * Props for the NodeComponent\r\n * Extends Node properties with event handlers\r\n */\r\nexport interface NodeComponentProps {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  isPath?: boolean; // For shortest path highlighting\r\n  weight?: number; // Terrain weight: 1 = normal, 5 = light, 10 = heavy\r\n  onMouseDown: (row: number, col: number, event: React.MouseEvent) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n  onTouchStart?: (row: number, col: number, event: React.TouchEvent) => void;\r\n}\r\n\r\n/**\r\n * NodeComponent - Represents a single cell in the grid\r\n *\r\n * Wrapped in React.memo to prevent unnecessary re-renders\r\n * of all 1500 nodes during visualization updates.\r\n * Only re-renders when its own props change.\r\n */\r\nconst NodeComponent: React.FC<NodeComponentProps> = memo(\r\n  ({\r\n    row,\r\n    col,\r\n    isStart,\r\n    isFinish,\r\n    isWall,\r\n    isVisited,\r\n    isPath = false,\r\n    weight = 1,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n    onMouseUp,\r\n    onTouchStart,\r\n  }) => {\r\n    const { isHiddenTargetMode } = useGridContext();\r\n\r\n    /**\r\n     * Compute the dynamic class name based on node state\r\n     * Priority order: Start > Finish > Path > Wall > Visited > Weight > Default\r\n     *\r\n     * Hidden Target Mode: If finish node is hidden and not yet visited,\r\n     * show it with a blinking animation (visible to user, hidden from algorithm)\r\n     */\r\n    const getNodeClassName = (): string => {\r\n      const classNames = [styles.node];\r\n\r\n      if (isStart) {\r\n        classNames.push(styles[\"node-start\"]);\r\n      } else if (isFinish) {\r\n        // Hidden Target Mode: Show blinking animation until discovered by algorithm\r\n        if (isHiddenTargetMode && !isVisited) {\r\n          classNames.push(styles[\"node-finish-hidden\"]);\r\n        } else {\r\n          classNames.push(styles[\"node-finish\"]);\r\n        }\r\n      } else if (isPath) {\r\n        classNames.push(styles[\"node-path\"]);\r\n      } else if (isWall) {\r\n        classNames.push(styles[\"node-wall\"]);\r\n      } else if (isVisited) {\r\n        classNames.push(styles[\"node-visited\"]);\r\n      } else if (weight >= 2 && weight <= 10) {\r\n        // Weight terrain - use specific class for each weight level\r\n        classNames.push(styles[`node-weight-${weight}`]);\r\n      }\r\n\r\n      return classNames.join(\" \");\r\n    };\r\n\r\n    /**\r\n     * Get the weight label to display on the node\r\n     * Normal tiles (weight=1): \"1\"\r\n     * Weighted tiles (weight>1): the weight value\r\n     * Wall tiles: \"\"\r\n     */\r\n    const getWeightLabel = (): string => {\r\n      if (isStart || isFinish) return \"\";\r\n      if (isWall) return \"\";\r\n      return weight.toString();\r\n    };\r\n\r\n    /**\r\n     * Build aria-label including weight information\r\n     */\r\n    const getAriaLabel = (): string => {\r\n      let label = `Node at row ${row}, column ${col}`;\r\n      if (isStart) label += \" (Start)\";\r\n      if (isFinish) label += \" (Finish)\";\r\n      if (isWall) label += \" (Wall)\";\r\n      if (weight > 1 && !isWall) label += ` (Weight: ${weight})`;\r\n      return label;\r\n    };\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={getNodeClassName()}\r\n        data-row={row}\r\n        data-col={col}\r\n        onMouseDown={(e) => onMouseDown(row, col, e)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={onMouseUp}\r\n        onTouchStart={\r\n          onTouchStart ? (e) => onTouchStart(row, col, e) : undefined\r\n        }\r\n        role=\"button\"\r\n        tabIndex={-1}\r\n        aria-label={getAriaLabel()}\r\n      >\r\n        <span className={styles.weightLabel}>{getWeightLabel()}</span>\r\n      </div>\r\n    );\r\n  },\r\n  // Custom comparison function for memo\r\n  (prevProps, nextProps) => {\r\n    return (\r\n      prevProps.isStart === nextProps.isStart &&\r\n      prevProps.isFinish === nextProps.isFinish &&\r\n      prevProps.isWall === nextProps.isWall &&\r\n      prevProps.isVisited === nextProps.isVisited &&\r\n      prevProps.isPath === nextProps.isPath &&\r\n      prevProps.weight === nextProps.weight &&\r\n      prevProps.row === nextProps.row &&\r\n      prevProps.col === nextProps.col\r\n    );\r\n  }\r\n);\r\n\r\nNodeComponent.displayName = \"NodeComponent\";\r\n\r\nexport default NodeComponent;\r\n","import React, { useCallback, useRef, useEffect, useState } from \"react\";\r\nimport { useGridContext } from \"../../context/GridContext\";\r\nimport NodeComponent from \"../Node\";\r\nimport {\r\n  getNewGridWithWallSet,\r\n  getNewGridWithWallRemoved,\r\n  getNewGridWithStartMoved,\r\n  getNewGridWithFinishMoved,\r\n  getNewGridWithWeightIncremented,\r\n  getNewGridWithWeightDecremented,\r\n} from \"../../utils/gridUtils\";\r\nimport styles from \"./Board.module.css\";\r\n\r\n/**\r\n * Board Component - Renders the 2D grid of nodes\r\n *\r\n * Uses GridContext for state management and handles\r\n * mouse events for wall/weight painting functionality.\r\n *\r\n * All tiles have weight from 1-10 or are walls ()\r\n * - WALL mode: Click = wall (), Ctrl+Click = remove wall (1)\r\n * - WEIGHT mode: Click = increment (12...10), Ctrl+Click = decrement\r\n */\r\nconst Board: React.FC = () => {\r\n  const {\r\n    grid,\r\n    setGrid,\r\n    setIsMousePressed,\r\n    isVisualizing,\r\n    colCount,\r\n    rowCount,\r\n    isHiddenTargetMode,\r\n    drawMode,\r\n  } = useGridContext();\r\n\r\n  // Ref for the board container to measure available space\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Dynamic node size state\r\n  const [nodeSize, setNodeSize] = useState<number>(25);\r\n\r\n  // Track if Ctrl/Cmd was held at start of drag (decrement/erase mode)\r\n  const isCtrlModeRef = useRef<boolean>(false);\r\n  // Track mouse pressed state with ref to avoid stale closure issues\r\n  const isMousePressedRef = useRef<boolean>(false);\r\n  // Track dragging Start node\r\n  const isDraggingStartRef = useRef<boolean>(false);\r\n  // Track dragging Finish node\r\n  const isDraggingFinishRef = useRef<boolean>(false);\r\n  // Track draw mode at start of drag operation (WALL or WEIGHT)\r\n  const drawModeRef = useRef<\"WALL\" | \"WEIGHT\">(drawMode);\r\n  // Track all nodes processed during current drag to prevent double-processing\r\n  const processedNodesRef = useRef<Set<string>>(new Set());\r\n\r\n  // Keep drawModeRef always in sync with drawMode state\r\n  useEffect(() => {\r\n    drawModeRef.current = drawMode;\r\n  }, [drawMode]);\r\n\r\n  /**\r\n   * Calculate and set the optimal node size based on container dimensions\r\n   * Ensures the entire grid fits without scrollbars\r\n   */\r\n  const calculateNodeSize = useCallback(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const container = containerRef.current;\r\n    const containerWidth = container.clientWidth;\r\n    const containerHeight = container.clientHeight;\r\n\r\n    // Account for border (2px on each side = 4px total)\r\n    const availableWidth = containerWidth - 4;\r\n    const availableHeight = containerHeight - 4;\r\n\r\n    // Calculate max size that fits both dimensions\r\n    const maxSizeByWidth = availableWidth / colCount;\r\n    const maxSizeByHeight = availableHeight / rowCount;\r\n\r\n    // Use the smaller value to ensure grid fits in both dimensions\r\n    // Floor to avoid sub-pixel rendering issues, min 10px for usability\r\n    const calculatedSize = Math.max(\r\n      10,\r\n      Math.floor(Math.min(maxSizeByWidth, maxSizeByHeight))\r\n    );\r\n\r\n    setNodeSize(calculatedSize);\r\n  }, [colCount, rowCount]);\r\n\r\n  /**\r\n   * ResizeObserver to recalculate node size when container changes\r\n   */\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    // Initial calculation\r\n    calculateNodeSize();\r\n\r\n    // Create ResizeObserver to watch for container size changes\r\n    const resizeObserver = new ResizeObserver(() => {\r\n      calculateNodeSize();\r\n    });\r\n\r\n    resizeObserver.observe(container);\r\n\r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [calculateNodeSize]);\r\n\r\n  /**\r\n   * Recalculate when grid dimensions change\r\n   */\r\n  useEffect(() => {\r\n    calculateNodeSize();\r\n  }, [rowCount, colCount, calculateNodeSize]);\r\n\r\n  /**\r\n   * Handle mouse down on a node - starts wall/weight painting or Start/Finish dragging\r\n   * Priority: Start node drag > Finish node drag > Wall/Weight interaction\r\n   *\r\n   * WALL mode: Click = set wall (), Ctrl+Click = remove wall (1)\r\n   * WEIGHT mode: Click = increment (12...10), Ctrl+Click = decrement (10...1)\r\n   */\r\n  const handleMouseDown = useCallback(\r\n    (row: number, col: number, event: React.MouseEvent): void => {\r\n      // Prevent default browser behavior (e.g., Ctrl+Click selection on Windows)\r\n      event.preventDefault();\r\n\r\n      if (isVisualizing) return;\r\n\r\n      const node = grid[row][col];\r\n      isMousePressedRef.current = true;\r\n      setIsMousePressed(true);\r\n\r\n      // Priority 1: Start node - begin dragging\r\n      if (node.isStart) {\r\n        isDraggingStartRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 2: Finish node - begin dragging\r\n      if (node.isFinish) {\r\n        // Hidden Target Mode: Prevent dragging the finish node when it's hidden\r\n        if (isHiddenTargetMode) {\r\n          return; // Do nothing - user shouldn't move invisible target\r\n        }\r\n        isDraggingFinishRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 3: Wall or Weight interaction based on drawMode\r\n      // Read from ref to get latest value (avoids stale closure in memoized components)\r\n      const currentDrawMode = drawModeRef.current;\r\n      const isCtrlPressed = event.ctrlKey || event.metaKey;\r\n\r\n      // Store in refs for drag continuity\r\n      isCtrlModeRef.current = isCtrlPressed;\r\n\r\n      // Clear and track this node to prevent double-processing during drag\r\n      processedNodesRef.current.clear();\r\n      processedNodesRef.current.add(`${row}-${col}`);\r\n\r\n      // Apply the appropriate transformation\r\n      setGrid((currentGrid) => {\r\n        if (currentDrawMode === \"WALL\") {\r\n          // WALL mode: Click = wall, Ctrl+Click = remove wall\r\n          if (isCtrlPressed) {\r\n            return getNewGridWithWallRemoved(currentGrid, row, col);\r\n          } else {\r\n            return getNewGridWithWallSet(currentGrid, row, col);\r\n          }\r\n        } else {\r\n          // WEIGHT mode: Click = increment, Ctrl+Click = decrement\r\n          if (isCtrlPressed) {\r\n            return getNewGridWithWeightDecremented(currentGrid, row, col);\r\n          } else {\r\n            return getNewGridWithWeightIncremented(currentGrid, row, col);\r\n          }\r\n        }\r\n      });\r\n    },\r\n    [grid, setGrid, setIsMousePressed, isVisualizing, isHiddenTargetMode]\r\n  );\r\n\r\n  /**\r\n   * Handle touch start on a node - mobile equivalent of mousedown\r\n   * Touch always increments/sets wall (no Ctrl key on mobile)\r\n   */\r\n  const handleTouchStart = useCallback(\r\n    (row: number, col: number, event: React.TouchEvent): void => {\r\n      event.preventDefault(); // Prevent scrolling while drawing\r\n\r\n      if (isVisualizing) return;\r\n\r\n      const node = grid[row][col];\r\n      isMousePressedRef.current = true;\r\n      setIsMousePressed(true);\r\n      isCtrlModeRef.current = false; // No Ctrl mode on touch\r\n\r\n      // Priority 1: Start node - begin dragging\r\n      if (node.isStart) {\r\n        isDraggingStartRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 2: Finish node - begin dragging\r\n      if (node.isFinish) {\r\n        if (isHiddenTargetMode) {\r\n          return; // Do nothing - user shouldn't move invisible target\r\n        }\r\n        isDraggingFinishRef.current = true;\r\n        return;\r\n      }\r\n\r\n      // Priority 3: Wall or Weight interaction based on drawMode\r\n      // Read from ref to get latest value (avoids stale closure in memoized components)\r\n      const currentDrawMode = drawModeRef.current;\r\n      processedNodesRef.current.clear();\r\n      processedNodesRef.current.add(`${row}-${col}`);\r\n\r\n      setGrid((currentGrid) => {\r\n        if (currentDrawMode === \"WALL\") {\r\n          // WALL mode on touch: set wall\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        } else {\r\n          // WEIGHT mode on touch: increment\r\n          return getNewGridWithWeightIncremented(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [grid, setGrid, setIsMousePressed, isVisualizing, isHiddenTargetMode]\r\n  );\r\n\r\n  /**\r\n   * Handle mouse enter on a node - continues wall/weight painting or Start/Finish dragging\r\n   * Uses the mode (draw/decrement) that was set on mouse down\r\n   *\r\n   * WALL mode: Only process each node once during drag (prevents toggle flickering)\r\n   * WEIGHT mode: Process each time mouse enters (allows continuous weight increase)\r\n   */\r\n  const handleMouseEnter = useCallback(\r\n    (row: number, col: number): void => {\r\n      // Use ref to check mouse state to avoid stale closure\r\n      if (!isMousePressedRef.current || isVisualizing) return;\r\n\r\n      const nodeKey = `${row}-${col}`;\r\n\r\n      // Handle Start node dragging\r\n      if (isDraggingStartRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithStartMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle Finish node dragging\r\n      if (isDraggingFinishRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithFinishMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // In WALL mode, skip if this node was already processed during this drag\r\n      // (prevents rapid wall toggle on/off when hovering)\r\n      if (\r\n        drawModeRef.current === \"WALL\" &&\r\n        processedNodesRef.current.has(nodeKey)\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      // Mark this node as processed (for WALL mode tracking)\r\n      processedNodesRef.current.add(nodeKey);\r\n\r\n      // Apply transformation based on mode set at drag start\r\n      setGrid((currentGrid) => {\r\n        if (drawModeRef.current === \"WALL\") {\r\n          // WALL mode: Click = wall, Ctrl+Click = remove wall\r\n          if (isCtrlModeRef.current) {\r\n            return getNewGridWithWallRemoved(currentGrid, row, col);\r\n          } else {\r\n            return getNewGridWithWallSet(currentGrid, row, col);\r\n          }\r\n        } else {\r\n          // WEIGHT mode: Click = increment, Ctrl+Click = decrement\r\n          if (isCtrlModeRef.current) {\r\n            return getNewGridWithWeightDecremented(currentGrid, row, col);\r\n          } else {\r\n            return getNewGridWithWeightIncremented(currentGrid, row, col);\r\n          }\r\n        }\r\n      });\r\n    },\r\n    [setGrid, isVisualizing]\r\n  );\r\n\r\n  /**\r\n   * Handle touch move - mobile equivalent of mouseenter\r\n   * Uses document.elementFromPoint to find which node is under the finger\r\n   *\r\n   * WALL mode: Only process each node once during drag\r\n   * WEIGHT mode: Process each time finger moves over node\r\n   */\r\n  const handleTouchMove = useCallback(\r\n    (event: React.TouchEvent): void => {\r\n      if (!isMousePressedRef.current || isVisualizing) return;\r\n\r\n      const touch = event.touches[0];\r\n      const element = document.elementFromPoint(touch.clientX, touch.clientY);\r\n\r\n      if (!element) return;\r\n\r\n      // Find the node element (may be the element or a parent)\r\n      const nodeElement = element.closest(\"[data-row][data-col]\");\r\n      if (!nodeElement) return;\r\n\r\n      const row = parseInt(nodeElement.getAttribute(\"data-row\") || \"-1\", 10);\r\n      const col = parseInt(nodeElement.getAttribute(\"data-col\") || \"-1\", 10);\r\n\r\n      if (row < 0 || col < 0 || row >= rowCount || col >= colCount) return;\r\n\r\n      const nodeKey = `${row}-${col}`;\r\n\r\n      // Handle Start node dragging\r\n      if (isDraggingStartRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithStartMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // Handle Finish node dragging\r\n      if (isDraggingFinishRef.current) {\r\n        setGrid((currentGrid) =>\r\n          getNewGridWithFinishMoved(currentGrid, row, col)\r\n        );\r\n        return;\r\n      }\r\n\r\n      // In WALL mode, skip if this node was already processed during this drag\r\n      if (\r\n        drawModeRef.current === \"WALL\" &&\r\n        processedNodesRef.current.has(nodeKey)\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      // Mark this node as processed (for WALL mode tracking)\r\n      processedNodesRef.current.add(nodeKey);\r\n\r\n      // Touch always uses \"increment\" mode (no Ctrl on mobile)\r\n      setGrid((currentGrid) => {\r\n        if (drawModeRef.current === \"WALL\") {\r\n          return getNewGridWithWallSet(currentGrid, row, col);\r\n        } else {\r\n          return getNewGridWithWeightIncremented(currentGrid, row, col);\r\n        }\r\n      });\r\n    },\r\n    [setGrid, isVisualizing, rowCount, colCount]\r\n  );\r\n\r\n  /**\r\n   * Handle touch end - mobile equivalent of mouseup\r\n   */\r\n  const handleTouchEnd = useCallback((): void => {\r\n    isMousePressedRef.current = false;\r\n    isCtrlModeRef.current = false;\r\n    isDraggingStartRef.current = false;\r\n    isDraggingFinishRef.current = false;\r\n    processedNodesRef.current.clear();\r\n    setIsMousePressed(false);\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Handle mouse up - stops all interactions\r\n   * Resets all mode refs for the next interaction\r\n   */\r\n  const handleMouseUp = useCallback((): void => {\r\n    isMousePressedRef.current = false;\r\n    isCtrlModeRef.current = false;\r\n    isDraggingStartRef.current = false;\r\n    isDraggingFinishRef.current = false;\r\n    processedNodesRef.current.clear();\r\n    setIsMousePressed(false);\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Global mouseup listener to handle edge cases where mouseup\r\n   * fires outside of any node (e.g., clicking on tile edges)\r\n   */\r\n  useEffect(() => {\r\n    const handleGlobalMouseUp = (): void => {\r\n      if (isMousePressedRef.current) {\r\n        isMousePressedRef.current = false;\r\n        isCtrlModeRef.current = false;\r\n        isDraggingStartRef.current = false;\r\n        isDraggingFinishRef.current = false;\r\n        processedNodesRef.current.clear();\r\n        setIsMousePressed(false);\r\n      }\r\n    };\r\n\r\n    // Listen to mouseup on the entire document\r\n    document.addEventListener(\"mouseup\", handleGlobalMouseUp);\r\n\r\n    return () => {\r\n      document.removeEventListener(\"mouseup\", handleGlobalMouseUp);\r\n    };\r\n  }, [setIsMousePressed]);\r\n\r\n  /**\r\n   * Prevent default drag behavior on the board\r\n   */\r\n  const handleDragStart = (e: React.DragEvent): void => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  /**\r\n   * Prevent context menu on right-click or Ctrl+click\r\n   */\r\n  const handleContextMenu = (e: React.MouseEvent): void => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  // Dynamic grid styling with calculated node size\r\n  const boardStyle: React.CSSProperties = {\r\n    display: \"grid\",\r\n    gridTemplateColumns: `repeat(${colCount}, ${nodeSize}px)`,\r\n    gridTemplateRows: `repeat(${rowCount}, ${nodeSize}px)`,\r\n    // Set CSS variable for node components to use\r\n    [\"--node-size\" as string]: `${nodeSize}px`,\r\n  };\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={styles.boardContainer}\r\n      onMouseLeave={handleMouseUp}\r\n      onDragStart={handleDragStart}\r\n      onContextMenu={handleContextMenu}\r\n      onTouchMove={handleTouchMove}\r\n      onTouchEnd={handleTouchEnd}\r\n    >\r\n      {/* eslint-disable-next-line react/forbid-dom-props */}\r\n      <div\r\n        className={styles.board}\r\n        style={boardStyle}\r\n        role=\"presentation\"\r\n        aria-label=\"Pathfinding Grid\"\r\n      >\r\n        {grid.map((row) =>\r\n          row.map((node) => (\r\n            <NodeComponent\r\n              key={`${node.row}-${node.col}`}\r\n              row={node.row}\r\n              col={node.col}\r\n              isStart={node.isStart}\r\n              isFinish={node.isFinish}\r\n              isWall={node.isWall}\r\n              isVisited={node.isVisited}\r\n              weight={node.weight}\r\n              onMouseDown={handleMouseDown}\r\n              onMouseEnter={handleMouseEnter}\r\n              onMouseUp={handleMouseUp}\r\n              onTouchStart={handleTouchStart}\r\n            />\r\n          ))\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Board;\r\n","/**\r\n * Accordion Component\r\n * Reusable collapsible section for grouped controls\r\n *\r\n * Features:\r\n * - Smooth expand/collapse animation\r\n * - Chevron icon rotation\r\n * - Dark minimalist styling\r\n * - Accessible keyboard navigation\r\n */\r\n\r\nimport React, { useState, useRef, useEffect } from \"react\";\r\nimport styles from \"./Accordion.module.css\";\r\n\r\ninterface AccordionProps {\r\n  title: string;\r\n  icon?: string;\r\n  children: React.ReactNode;\r\n  defaultOpen?: boolean;\r\n  /** Controlled mode: external open state */\r\n  isOpen?: boolean;\r\n  /** Controlled mode: callback when toggled */\r\n  onToggle?: () => void;\r\n}\r\n\r\nconst Accordion: React.FC<AccordionProps> = ({\r\n  title,\r\n  icon,\r\n  children,\r\n  defaultOpen = false,\r\n  isOpen: controlledIsOpen,\r\n  onToggle,\r\n}) => {\r\n  const [internalIsOpen, setInternalIsOpen] = useState(defaultOpen);\r\n\r\n  // Use controlled mode if isOpen prop is provided\r\n  const isControlled = controlledIsOpen !== undefined;\r\n  const isOpen = isControlled ? controlledIsOpen : internalIsOpen;\r\n\r\n  const contentRef = useRef<HTMLDivElement>(null);\r\n  const [contentHeight, setContentHeight] = useState<number | undefined>(\r\n    defaultOpen ? undefined : 0\r\n  );\r\n\r\n  // Update height when content changes or accordion opens/closes\r\n  useEffect(() => {\r\n    if (contentRef.current) {\r\n      const height = contentRef.current.scrollHeight;\r\n      setContentHeight(isOpen ? height : 0);\r\n    }\r\n  }, [isOpen, children]);\r\n\r\n  const handleToggle = () => {\r\n    if (isControlled && onToggle) {\r\n      onToggle();\r\n    } else {\r\n      setInternalIsOpen(!internalIsOpen);\r\n    }\r\n  };\r\n\r\n  const handleKeyDown = (e: React.KeyboardEvent) => {\r\n    if (e.key === \"Enter\" || e.key === \" \") {\r\n      e.preventDefault();\r\n      handleToggle();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.accordion} ${isOpen ? styles.open : \"\"}`}>\r\n      <button\r\n        className={styles.header}\r\n        onClick={handleToggle}\r\n        onKeyDown={handleKeyDown}\r\n        aria-expanded={isOpen ? \"true\" : \"false\"}\r\n        type=\"button\"\r\n      >\r\n        <span className={styles.titleWrapper}>\r\n          {icon && <span className={styles.icon}>{icon}</span>}\r\n          <span className={styles.title}>{title}</span>\r\n        </span>\r\n        <svg\r\n          className={`${styles.chevron} ${isOpen ? styles.chevronOpen : \"\"}`}\r\n          width=\"16\"\r\n          height=\"16\"\r\n          viewBox=\"0 0 16 16\"\r\n          fill=\"none\"\r\n          xmlns=\"http://www.w3.org/2000/svg\"\r\n        >\r\n          <path\r\n            d=\"M4 6L8 10L12 6\"\r\n            stroke=\"currentColor\"\r\n            strokeWidth=\"2\"\r\n            strokeLinecap=\"round\"\r\n            strokeLinejoin=\"round\"\r\n          />\r\n        </svg>\r\n      </button>\r\n      <div\r\n        className={styles.contentWrapper}\r\n        style={{\r\n          height: contentHeight !== undefined ? `${contentHeight}px` : \"auto\",\r\n        }}\r\n      >\r\n        <div ref={contentRef} className={styles.content}>\r\n          {children}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Accordion;\r\n","/**\r\n * ControlPanel Component\r\n * Professional sidebar with grouped accordion sections\r\n *\r\n * UX-Focused Redesign featuring:\r\n * - Clear visual hierarchy with prominent Primary CTA\r\n * - Algorithms grouped by category (Weighted/Unweighted, Standard/Advanced)\r\n * - Descriptive labels with algorithm characteristics\r\n * - Mobile auto-close on action for better UX\r\n * - Increased whitespace and polish\r\n */\r\n\r\nimport React, { useEffect, useState } from \"react\";\r\nimport { useGridContext } from \"../../context/GridContext\";\r\nimport { AlgorithmType, MazeType } from \"../../types\";\r\nimport Accordion from \"./Accordion\";\r\nimport styles from \"./ControlPanel.module.css\";\r\n\r\n/**\r\n * Props for the ControlPanel component\r\n */\r\ninterface ControlPanelProps {\r\n  onVisualize: () => void;\r\n  onClearPath: () => void;\r\n  onGenerateMaze: (\r\n    mazeType: MazeType,\r\n    terrainConfig?: { frequency: number; intensity?: number }\r\n  ) => void;\r\n  onVisualizeRace: () => void;\r\n  /** Callback to close sidebar on mobile after action */\r\n  onMobileAction?: () => void;\r\n}\r\n\r\n// ============================================================================\r\n// Algorithm Configuration - Organized by Category\r\n// ============================================================================\r\n\r\ninterface AlgorithmOption {\r\n  value: AlgorithmType;\r\n  label: string;\r\n  shortLabel: string;\r\n  usesHeuristic: boolean;\r\n  guaranteesShortestPath: boolean;\r\n  category: \"weighted\" | \"unweighted\" | \"bidirectional\";\r\n  /** Whether this algorithm correctly handles weighted terrain */\r\n  supportsWeights: boolean;\r\n}\r\n\r\n/**\r\n * Algorithms grouped logically:\r\n * - WEIGHTED: Consider edge weights (Dijkstra, A*, Bidirectional A*)\r\n * - UNWEIGHTED: Treat all edges equally (BFS, DFS, Greedy, JPS, Bidirectional BFS)\r\n * - BIDIRECTIONAL: Search from both ends\r\n */\r\nconst ALGORITHM_OPTIONS: AlgorithmOption[] = [\r\n  // === Weighted / Optimal Algorithms ===\r\n  {\r\n    value: AlgorithmType.DIJKSTRA,\r\n    label: \"Dijkstra  Guarantees Shortest Path\",\r\n    shortLabel: \"Dijkstra\",\r\n    usesHeuristic: false,\r\n    guaranteesShortestPath: true,\r\n    category: \"weighted\",\r\n    supportsWeights: true,\r\n  },\r\n  {\r\n    value: AlgorithmType.ASTAR,\r\n    label: \"A* Search  Fast & Optimal\",\r\n    shortLabel: \"A*\",\r\n    usesHeuristic: true,\r\n    guaranteesShortestPath: true,\r\n    category: \"weighted\",\r\n    supportsWeights: true,\r\n  },\r\n  {\r\n    value: AlgorithmType.JUMP_POINT_SEARCH,\r\n    label: \"Jump Point Search  Optimized A*\",\r\n    shortLabel: \"JPS\",\r\n    usesHeuristic: true,\r\n    guaranteesShortestPath: true,\r\n    category: \"weighted\",\r\n    supportsWeights: false, // JPS assumes uniform cost grid\r\n  },\r\n\r\n  // === Unweighted / Exploration Algorithms ===\r\n  {\r\n    value: AlgorithmType.BFS,\r\n    label: \"BFS  Shortest Path (Unweighted)\",\r\n    shortLabel: \"BFS\",\r\n    usesHeuristic: false,\r\n    guaranteesShortestPath: true,\r\n    category: \"unweighted\",\r\n    supportsWeights: false,\r\n  },\r\n  {\r\n    value: AlgorithmType.DFS,\r\n    label: \"DFS  Explores Deeply (Not Shortest)\",\r\n    shortLabel: \"DFS\",\r\n    usesHeuristic: false,\r\n    guaranteesShortestPath: false,\r\n    category: \"unweighted\",\r\n    supportsWeights: false,\r\n  },\r\n  {\r\n    value: AlgorithmType.GREEDY_BEST_FIRST,\r\n    label: \"Greedy Best-First  Fast but Suboptimal\",\r\n    shortLabel: \"Greedy\",\r\n    usesHeuristic: true,\r\n    guaranteesShortestPath: false,\r\n    category: \"unweighted\",\r\n    supportsWeights: false,\r\n  },\r\n\r\n  // === Bidirectional / Advanced Algorithms ===\r\n  {\r\n    value: AlgorithmType.BIDIRECTIONAL_BFS,\r\n    label: \"Bidirectional BFS  Searches Both Ends\",\r\n    shortLabel: \"Bi-BFS\",\r\n    usesHeuristic: true, // Needs target location\r\n    guaranteesShortestPath: true,\r\n    category: \"bidirectional\",\r\n    supportsWeights: false,\r\n  },\r\n  {\r\n    value: AlgorithmType.BIDIRECTIONAL_ASTAR,\r\n    label: \"Bidirectional A*  Advanced Optimal\",\r\n    shortLabel: \"Bi-A*\",\r\n    usesHeuristic: true,\r\n    guaranteesShortestPath: true,\r\n    category: \"bidirectional\",\r\n    supportsWeights: true,\r\n  },\r\n];\r\n\r\n// ============================================================================\r\n// Maze Configuration\r\n// ============================================================================\r\n\r\ninterface MazeOption {\r\n  value: MazeType;\r\n  label: string;\r\n  description: string;\r\n}\r\n\r\n/**\r\n * Maze generation options with descriptions\r\n */\r\nconst MAZE_OPTIONS: MazeOption[] = [\r\n  {\r\n    value: MazeType.RECURSIVE_DIVISION,\r\n    label: \"Recursive Division\",\r\n    description: \"Creates rooms with passages\",\r\n  },\r\n  {\r\n    value: MazeType.RANDOMIZED_DFS,\r\n    label: \"Randomized DFS\",\r\n    description: \"Long, winding corridors\",\r\n  },\r\n  {\r\n    value: MazeType.PRIMS,\r\n    label: \"Prim's Algorithm\",\r\n    description: \"Organic, branching paths\",\r\n  },\r\n  {\r\n    value: MazeType.CELLULAR_AUTOMATA,\r\n    label: \"Cellular Automata\",\r\n    description: \"Cave-like structures\",\r\n  },\r\n  {\r\n    value: MazeType.SPIRAL,\r\n    label: \"Spiral Pattern\",\r\n    description: \"Spiraling maze pattern\",\r\n  },\r\n];\r\n\r\n// ============================================================================\r\n// Terrain Smoothness Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Terrain smoothness presets\r\n * Lower frequency = smoother, larger terrain features\r\n * Higher frequency = rougher, more detailed terrain\r\n */\r\ntype TerrainSmoothness = \"smooth\" | \"medium\" | \"rough\" | \"jagged\";\r\n\r\ninterface TerrainSmoothnessOption {\r\n  value: TerrainSmoothness;\r\n  label: string;\r\n  description: string;\r\n  frequency: number;\r\n}\r\n\r\nconst TERRAIN_SMOOTHNESS_OPTIONS: TerrainSmoothnessOption[] = [\r\n  {\r\n    value: \"smooth\",\r\n    label: \"Smooth\",\r\n    description: \"Large, rolling hills\",\r\n    frequency: 0.06,\r\n  },\r\n  {\r\n    value: \"medium\",\r\n    label: \"Medium\",\r\n    description: \"Balanced terrain\",\r\n    frequency: 0.12,\r\n  },\r\n  {\r\n    value: \"rough\",\r\n    label: \"Rough\",\r\n    description: \"Detailed landscape\",\r\n    frequency: 0.2,\r\n  },\r\n  {\r\n    value: \"jagged\",\r\n    label: \"Jagged\",\r\n    description: \"Extreme variation\",\r\n    frequency: 0.35,\r\n  },\r\n];\r\n\r\n// ============================================================================\r\n// Mobile Detection Hook\r\n// ============================================================================\r\n\r\nconst MOBILE_BREAKPOINT = 900;\r\n\r\nfunction useIsMobile(): boolean {\r\n  const [isMobile, setIsMobile] = useState(\r\n    typeof window !== \"undefined\" && window.innerWidth <= MOBILE_BREAKPOINT\r\n  );\r\n\r\n  useEffect(() => {\r\n    const checkMobile = () => {\r\n      setIsMobile(window.innerWidth <= MOBILE_BREAKPOINT);\r\n    };\r\n\r\n    window.addEventListener(\"resize\", checkMobile);\r\n    return () => window.removeEventListener(\"resize\", checkMobile);\r\n  }, []);\r\n\r\n  return isMobile;\r\n}\r\n\r\n// ============================================================================\r\n// ControlPanel Component\r\n// ============================================================================\r\n\r\n/**\r\n * ControlPanel - UX-focused sidebar with clear hierarchy\r\n */\r\nconst ControlPanel: React.FC<ControlPanelProps> = ({\r\n  onVisualize,\r\n  onClearPath,\r\n  onGenerateMaze,\r\n  onVisualizeRace,\r\n  onMobileAction,\r\n}) => {\r\n  const isMobile = useIsMobile();\r\n  const {\r\n    setGrid,\r\n    selectedAlgorithm,\r\n    setSelectedAlgorithm,\r\n    selectedMaze,\r\n    setSelectedMaze,\r\n    isVisualizing,\r\n    isRaceMode,\r\n    setIsRaceMode,\r\n    secondAlgorithm,\r\n    setSecondAlgorithm,\r\n    rowCount,\r\n    colCount,\r\n    resizeGrid,\r\n    resetBoard,\r\n    clearAllWalls,\r\n    animationSpeed,\r\n    setAnimationSpeed,\r\n    isHiddenTargetMode,\r\n    setIsHiddenTargetMode,\r\n    drawMode,\r\n    setDrawMode,\r\n  } = useGridContext();\r\n\r\n  // === Local State ===\r\n  const [terrainSmoothness, setTerrainSmoothness] =\r\n    useState<TerrainSmoothness>(\"medium\");\r\n  const [terrainIntensity, setTerrainIntensity] = useState<number>(0.7);\r\n\r\n  // Track which generation section is open (mutually exclusive)\r\n  // \"maze\" = Maze Generator open, \"terrain\" = Terrain Generation open\r\n  const [activeGenSection, setActiveGenSection] = useState<\"maze\" | \"terrain\">(\r\n    \"maze\"\r\n  );\r\n\r\n  // === Effects ===\r\n\r\n  /**\r\n   * Sync Weight Mode with active section:\r\n   * - Terrain section open  Weight Mode ON\r\n   * - Maze section open  Weight Mode OFF (and convert weights)\r\n   */\r\n  useEffect(() => {\r\n    if (activeGenSection === \"terrain\" && drawMode !== \"WEIGHT\") {\r\n      // Switching to Weight Mode - auto-switch algorithms if needed\r\n      if (!algorithmSupportsWeights(selectedAlgorithm)) {\r\n        setSelectedAlgorithm(AlgorithmType.DIJKSTRA);\r\n      }\r\n      if (secondAlgorithm && !algorithmSupportsWeights(secondAlgorithm)) {\r\n        setSecondAlgorithm(AlgorithmType.ASTAR);\r\n      }\r\n      setDrawMode(\"WEIGHT\");\r\n    } else if (activeGenSection === \"maze\" && drawMode !== \"WALL\") {\r\n      // Switching to Wall Mode - convert weighted tiles\r\n      setGrid((currentGrid) => {\r\n        return currentGrid.map((row) =>\r\n          row.map((node) => {\r\n            // Skip start, finish, and already-wall nodes\r\n            if (node.isStart || node.isFinish || node.isWall) {\r\n              return node;\r\n            }\r\n            // Weight > 5: convert to wall\r\n            if (node.weight > 5) {\r\n              return { ...node, isWall: true, weight: 1 };\r\n            }\r\n            // Weight > 1: convert to normal tile (weight 1)\r\n            if (node.weight > 1) {\r\n              return { ...node, weight: 1 };\r\n            }\r\n            return node;\r\n          })\r\n        );\r\n      });\r\n      setDrawMode(\"WALL\");\r\n    }\r\n  }, [activeGenSection]); // Only run when section changes\r\n\r\n  // === Handlers ===\r\n\r\n  /**\r\n   * Helper to check if an algorithm needs visible target\r\n   */\r\n  const isHeuristicAlgorithm = (alg: AlgorithmType): boolean => {\r\n    const option = ALGORITHM_OPTIONS.find((o) => o.value === alg);\r\n    return option?.usesHeuristic ?? false;\r\n  };\r\n\r\n  /**\r\n   * Helper to check if an algorithm supports weighted terrain\r\n   */\r\n  const algorithmSupportsWeights = (alg: AlgorithmType): boolean => {\r\n    const option = ALGORITHM_OPTIONS.find((o) => o.value === alg);\r\n    return option?.supportsWeights ?? false;\r\n  };\r\n\r\n  /**\r\n   * Check if an algorithm is disabled due to current mode/terrain\r\n   */\r\n  const isAlgorithmDisabled = (alg: AlgorithmType): boolean => {\r\n    // Disabled if hidden target mode + uses heuristic\r\n    if (isHiddenTargetMode && isHeuristicAlgorithm(alg)) {\r\n      return true;\r\n    }\r\n    // Disabled if weight mode ON + doesn't support weights\r\n    if (drawMode === \"WEIGHT\" && !algorithmSupportsWeights(alg)) {\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const handleAlgorithmChange = (\r\n    e: React.ChangeEvent<HTMLSelectElement>\r\n  ): void => {\r\n    const newAlgorithm = e.target.value as AlgorithmType;\r\n\r\n    // If hidden target mode is on and user selects a heuristic algorithm, switch to Dijkstra\r\n    if (isHiddenTargetMode && isHeuristicAlgorithm(newAlgorithm)) {\r\n      setSelectedAlgorithm(AlgorithmType.DIJKSTRA);\r\n      return;\r\n    }\r\n\r\n    // If weight mode ON and algorithm doesn't support weights, switch to Dijkstra\r\n    if (drawMode === \"WEIGHT\" && !algorithmSupportsWeights(newAlgorithm)) {\r\n      setSelectedAlgorithm(AlgorithmType.DIJKSTRA);\r\n      return;\r\n    }\r\n\r\n    setSelectedAlgorithm(newAlgorithm);\r\n  };\r\n\r\n  const handleSecondAlgorithmChange = (\r\n    e: React.ChangeEvent<HTMLSelectElement>\r\n  ): void => {\r\n    const newAlgorithm = e.target.value as AlgorithmType;\r\n\r\n    // If hidden target mode is on and user selects a heuristic algorithm, switch to BFS\r\n    if (isHiddenTargetMode && isHeuristicAlgorithm(newAlgorithm)) {\r\n      setSecondAlgorithm(AlgorithmType.BFS);\r\n      return;\r\n    }\r\n\r\n    // If weight mode ON and algorithm doesn't support weights, switch to Dijkstra\r\n    if (drawMode === \"WEIGHT\" && !algorithmSupportsWeights(newAlgorithm)) {\r\n      setSecondAlgorithm(AlgorithmType.DIJKSTRA);\r\n      return;\r\n    }\r\n\r\n    setSecondAlgorithm(newAlgorithm);\r\n  };\r\n\r\n  const handleHiddenTargetToggle = (): void => {\r\n    if (isVisualizing) return;\r\n    const newMode = !isHiddenTargetMode;\r\n    setIsHiddenTargetMode(newMode);\r\n\r\n    // If enabling hidden target mode and a heuristic algorithm is selected, switch to blind search\r\n    if (newMode) {\r\n      if (isHeuristicAlgorithm(selectedAlgorithm)) {\r\n        setSelectedAlgorithm(AlgorithmType.DIJKSTRA);\r\n      }\r\n      if (secondAlgorithm && isHeuristicAlgorithm(secondAlgorithm)) {\r\n        setSecondAlgorithm(AlgorithmType.BFS);\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleRaceModeToggle = (): void => {\r\n    if (isVisualizing) return;\r\n    const newRaceMode = !isRaceMode;\r\n    setIsRaceMode(newRaceMode);\r\n    if (newRaceMode && !secondAlgorithm) {\r\n      const defaultSecond =\r\n        selectedAlgorithm === AlgorithmType.DIJKSTRA\r\n          ? AlgorithmType.ASTAR\r\n          : AlgorithmType.DIJKSTRA;\r\n      setSecondAlgorithm(defaultSecond);\r\n    }\r\n  };\r\n\r\n  const handleVisualize = (): void => {\r\n    if (isRaceMode && secondAlgorithm) {\r\n      onVisualizeRace();\r\n    } else {\r\n      onVisualize();\r\n    }\r\n    // Auto-close on mobile\r\n    if (isMobile && onMobileAction) {\r\n      setTimeout(() => onMobileAction(), 150);\r\n    }\r\n  };\r\n\r\n  const handleMazeChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {\r\n    setSelectedMaze(e.target.value as MazeType);\r\n  };\r\n\r\n  const handleTerrainSmoothnessChange = (\r\n    e: React.ChangeEvent<HTMLSelectElement>\r\n  ): void => {\r\n    setTerrainSmoothness(e.target.value as TerrainSmoothness);\r\n  };\r\n\r\n  const handleGenerateMaze = (): void => {\r\n    onGenerateMaze(selectedMaze);\r\n    // Auto-close on mobile\r\n    if (isMobile && onMobileAction) {\r\n      setTimeout(() => onMobileAction(), 150);\r\n    }\r\n  };\r\n\r\n  const handleClearPath = (): void => {\r\n    onClearPath();\r\n    // Auto-close on mobile\r\n    if (isMobile && onMobileAction) {\r\n      setTimeout(() => onMobileAction(), 150);\r\n    }\r\n  };\r\n\r\n  const handleResetBoard = (): void => {\r\n    resetBoard();\r\n    // Auto-close on mobile\r\n    if (isMobile && onMobileAction) {\r\n      setTimeout(() => onMobileAction(), 150);\r\n    }\r\n  };\r\n\r\n  const handleClearBoard = (): void => {\r\n    // Clear both walls and weights\r\n    clearAllWalls();\r\n    setGrid((currentGrid) =>\r\n      currentGrid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          weight: 1,\r\n        }))\r\n      )\r\n    );\r\n    // Auto-close on mobile\r\n    if (isMobile && onMobileAction) {\r\n      setTimeout(() => onMobileAction(), 150);\r\n    }\r\n  };\r\n\r\n  const handleGenerateTerrain = (): void => {\r\n    const smoothnessOption = TERRAIN_SMOOTHNESS_OPTIONS.find(\r\n      (o) => o.value === terrainSmoothness\r\n    );\r\n    onGenerateMaze(MazeType.TERRAIN_MAP, {\r\n      frequency: smoothnessOption?.frequency ?? 0.12,\r\n      intensity: terrainIntensity,\r\n    });\r\n    // Auto-close on mobile\r\n    if (isMobile && onMobileAction) {\r\n      setTimeout(() => onMobileAction(), 150);\r\n    }\r\n  };\r\n\r\n  const handleRowChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newRows = parseInt(e.target.value, 10);\r\n    resizeGrid(newRows, colCount);\r\n  };\r\n\r\n  const handleColChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newCols = parseInt(e.target.value, 10);\r\n    resizeGrid(rowCount, newCols);\r\n  };\r\n\r\n  const handleSpeedChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const newSpeed = parseInt(e.target.value, 10);\r\n    setAnimationSpeed(newSpeed);\r\n  };\r\n\r\n  const getSpeedLabel = (): string => {\r\n    if (animationSpeed <= 5) return \"Very Fast\";\r\n    if (animationSpeed <= 10) return \"Fast\";\r\n    if (animationSpeed <= 20) return \"Normal\";\r\n    if (animationSpeed <= 40) return \"Slow\";\r\n    return \"Very Slow\";\r\n  };\r\n\r\n  // Get selected algorithm details for display\r\n  const selectedAlgoOption = ALGORITHM_OPTIONS.find(\r\n    (o) => o.value === selectedAlgorithm\r\n  );\r\n\r\n  // Group algorithms by category for organized display\r\n  const weightedAlgos = ALGORITHM_OPTIONS.filter(\r\n    (o) => o.category === \"weighted\"\r\n  );\r\n  const unweightedAlgos = ALGORITHM_OPTIONS.filter(\r\n    (o) => o.category === \"unweighted\"\r\n  );\r\n  const bidirectionalAlgos = ALGORITHM_OPTIONS.filter(\r\n    (o) => o.category === \"bidirectional\"\r\n  );\r\n\r\n  return (\r\n    <aside className={styles.panel}>\r\n      {/* Panel Header */}\r\n      <header className={styles.panelHeader}>\r\n        <h2 className={styles.panelTitle}>Controls</h2>\r\n        <p className={styles.panelSubtitle}>Configure & Visualize</p>\r\n      </header>\r\n\r\n      {/* ================================================================\r\n          PRIMARY ACTION SECTION - Most Prominent\r\n          ================================================================ */}\r\n      <div className={styles.primarySection}>\r\n        {/* Main CTA - Always Visible at Top */}\r\n        <button\r\n          onClick={handleVisualize}\r\n          disabled={isVisualizing || (isRaceMode && !secondAlgorithm)}\r\n          className={`${styles.buttonPrimary} ${\r\n            isRaceMode ? styles.buttonRace : \"\"\r\n          }`}\r\n        >\r\n          {isVisualizing ? (\r\n            <>\r\n              <span className={styles.spinner} />\r\n              Visualizing...\r\n            </>\r\n          ) : isRaceMode ? (\r\n            \" Start Race!\"\r\n          ) : (\r\n            \" Visualize Path\"\r\n          )}\r\n        </button>\r\n\r\n        {/* Quick Action Buttons */}\r\n        <div className={styles.quickActions}>\r\n          <button\r\n            onClick={handleClearPath}\r\n            disabled={isVisualizing}\r\n            className={styles.buttonQuick}\r\n            title=\"Clear visualized path\"\r\n          >\r\n             Clear Path\r\n          </button>\r\n          <button\r\n            onClick={handleResetBoard}\r\n            disabled={isVisualizing}\r\n            className={styles.buttonQuick}\r\n            title=\"Reset entire board\"\r\n          >\r\n             Reset\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Accordion Sections */}\r\n      <div className={styles.accordionContainer}>\r\n        {/* === Section 1: Algorithm Selection === */}\r\n        <Accordion title=\"Algorithm\" icon=\"\" defaultOpen={true}>\r\n          {/* Current Selection Display */}\r\n          {selectedAlgoOption && (\r\n            <div className={styles.currentSelection}>\r\n              <span className={styles.currentLabel}>Selected:</span>\r\n              <span className={styles.currentValue}>\r\n                {selectedAlgoOption.shortLabel}\r\n              </span>\r\n              {selectedAlgoOption.guaranteesShortestPath ? (\r\n                <span className={styles.badgeOptimal}> Optimal</span>\r\n              ) : (\r\n                <span className={styles.badgeSuboptimal}>Not Shortest</span>\r\n              )}\r\n            </div>\r\n          )}\r\n\r\n          {/* Algorithm Selection with Categories */}\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>Choose Algorithm</label>\r\n            <select\r\n              value={selectedAlgorithm}\r\n              onChange={handleAlgorithmChange}\r\n              disabled={isVisualizing}\r\n              className={styles.select}\r\n              title=\"Select pathfinding algorithm\"\r\n            >\r\n              {/* Weighted / Optimal Group */}\r\n              <optgroup label=\" Optimal Algorithms\">\r\n                {weightedAlgos.map((option) => {\r\n                  const isDisabled = isAlgorithmDisabled(option.value);\r\n                  const disabledReason =\r\n                    isHiddenTargetMode && option.usesHeuristic\r\n                      ? \" (Hidden Mode)\"\r\n                      : drawMode === \"WEIGHT\" && !option.supportsWeights\r\n                      ? \" (Unweighted)\"\r\n                      : \"\";\r\n                  return (\r\n                    <option\r\n                      key={option.value}\r\n                      value={option.value}\r\n                      disabled={isDisabled}\r\n                    >\r\n                      {option.label}\r\n                      {disabledReason}\r\n                    </option>\r\n                  );\r\n                })}\r\n              </optgroup>\r\n\r\n              {/* Unweighted / Exploration Group */}\r\n              <optgroup label=\" Exploration Algorithms\">\r\n                {unweightedAlgos.map((option) => {\r\n                  const isDisabled = isAlgorithmDisabled(option.value);\r\n                  const disabledReason =\r\n                    isHiddenTargetMode && option.usesHeuristic\r\n                      ? \" (Hidden Mode)\"\r\n                      : drawMode === \"WEIGHT\" && !option.supportsWeights\r\n                      ? \" (Unweighted)\"\r\n                      : \"\";\r\n                  return (\r\n                    <option\r\n                      key={option.value}\r\n                      value={option.value}\r\n                      disabled={isDisabled}\r\n                    >\r\n                      {option.label}\r\n                      {disabledReason}\r\n                    </option>\r\n                  );\r\n                })}\r\n              </optgroup>\r\n\r\n              {/* Bidirectional / Advanced Group */}\r\n              <optgroup label=\" Advanced (Bidirectional)\">\r\n                {bidirectionalAlgos.map((option) => {\r\n                  const isDisabled = isAlgorithmDisabled(option.value);\r\n                  const disabledReason =\r\n                    isHiddenTargetMode && option.usesHeuristic\r\n                      ? \" (Hidden Mode)\"\r\n                      : drawMode === \"WEIGHT\" && !option.supportsWeights\r\n                      ? \" (Unweighted)\"\r\n                      : \"\";\r\n                  return (\r\n                    <option\r\n                      key={option.value}\r\n                      value={option.value}\r\n                      disabled={isDisabled}\r\n                    >\r\n                      {option.label}\r\n                      {disabledReason}\r\n                    </option>\r\n                  );\r\n                })}\r\n              </optgroup>\r\n            </select>\r\n            {isHiddenTargetMode && (\r\n              <p className={styles.hint}>\r\n                 Heuristic algorithms disabled in Hidden Mode\r\n              </p>\r\n            )}\r\n            {drawMode === \"WEIGHT\" && (\r\n              <p className={styles.hint}>\r\n                 Unweighted algorithms disabled due to terrain\r\n              </p>\r\n            )}\r\n          </div>\r\n\r\n          {/* Mode Toggles - Visually Separated */}\r\n          <div className={styles.modeSection}>\r\n            <div className={styles.modeSectionTitle}>Game Modes</div>\r\n\r\n            {/* Hidden Target Mode Toggle */}\r\n            <div className={styles.toggleRow}>\r\n              <div className={styles.toggleInfo}>\r\n                <span className={styles.toggleLabel}> Hidden Target</span>\r\n                <span className={styles.toggleDesc}>Fog of War mode</span>\r\n              </div>\r\n              <button\r\n                type=\"button\"\r\n                className={`${styles.toggle} ${\r\n                  isHiddenTargetMode ? styles.toggleActive : \"\"\r\n                }`}\r\n                onClick={handleHiddenTargetToggle}\r\n                disabled={isVisualizing}\r\n                aria-pressed={isHiddenTargetMode ? \"true\" : \"false\"}\r\n                title=\"Hide target node (Fog of War mode)\"\r\n              >\r\n                <span className={styles.toggleKnob} />\r\n              </button>\r\n            </div>\r\n\r\n            {/* Race Mode Toggle */}\r\n            <div className={styles.toggleRow}>\r\n              <div className={styles.toggleInfo}>\r\n                <span className={styles.toggleLabel}> Race Mode</span>\r\n                <span className={styles.toggleDesc}>Compare algorithms</span>\r\n              </div>\r\n              <button\r\n                type=\"button\"\r\n                className={`${styles.toggle} ${\r\n                  isRaceMode ? styles.toggleActive : \"\"\r\n                }`}\r\n                onClick={handleRaceModeToggle}\r\n                disabled={isVisualizing}\r\n                aria-pressed={isRaceMode ? \"true\" : \"false\"}\r\n                title=\"Toggle race mode to compare two algorithms\"\r\n              >\r\n                <span className={styles.toggleKnob} />\r\n              </button>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Second Algorithm (Race Mode) */}\r\n          {isRaceMode && (\r\n            <div className={styles.controlGroup}>\r\n              <label className={styles.labelSecondary}>\r\n                 Agent 2 Algorithm\r\n              </label>\r\n              <select\r\n                value={secondAlgorithm || \"\"}\r\n                onChange={handleSecondAlgorithmChange}\r\n                disabled={isVisualizing}\r\n                className={`${styles.select} ${styles.selectSecondary}`}\r\n                title=\"Select second algorithm for race mode\"\r\n              >\r\n                <optgroup label=\" Optimal\">\r\n                  {weightedAlgos.map((option) => {\r\n                    const isSameAsAgent1 = option.value === selectedAlgorithm;\r\n                    const isDisabledByMode = isAlgorithmDisabled(option.value);\r\n                    const isDisabled = isSameAsAgent1 || isDisabledByMode;\r\n                    const disabledReason = isSameAsAgent1\r\n                      ? \" (Agent 1)\"\r\n                      : isHiddenTargetMode && option.usesHeuristic\r\n                      ? \" (Hidden)\"\r\n                      : drawMode === \"WEIGHT\" && !option.supportsWeights\r\n                      ? \" (Unweighted)\"\r\n                      : \"\";\r\n                    return (\r\n                      <option\r\n                        key={option.value}\r\n                        value={option.value}\r\n                        disabled={isDisabled}\r\n                      >\r\n                        {option.shortLabel}\r\n                        {disabledReason}\r\n                      </option>\r\n                    );\r\n                  })}\r\n                </optgroup>\r\n                <optgroup label=\" Exploration\">\r\n                  {unweightedAlgos.map((option) => {\r\n                    const isSameAsAgent1 = option.value === selectedAlgorithm;\r\n                    const isDisabledByMode = isAlgorithmDisabled(option.value);\r\n                    const isDisabled = isSameAsAgent1 || isDisabledByMode;\r\n                    const disabledReason = isSameAsAgent1\r\n                      ? \" (Agent 1)\"\r\n                      : isHiddenTargetMode && option.usesHeuristic\r\n                      ? \" (Hidden)\"\r\n                      : drawMode === \"WEIGHT\" && !option.supportsWeights\r\n                      ? \" (Unweighted)\"\r\n                      : \"\";\r\n                    return (\r\n                      <option\r\n                        key={option.value}\r\n                        value={option.value}\r\n                        disabled={isDisabled}\r\n                      >\r\n                        {option.shortLabel}\r\n                        {disabledReason}\r\n                      </option>\r\n                    );\r\n                  })}\r\n                </optgroup>\r\n                <optgroup label=\" Advanced\">\r\n                  {bidirectionalAlgos.map((option) => {\r\n                    const isSameAsAgent1 = option.value === selectedAlgorithm;\r\n                    const isDisabledByMode = isAlgorithmDisabled(option.value);\r\n                    const isDisabled = isSameAsAgent1 || isDisabledByMode;\r\n                    const disabledReason = isSameAsAgent1\r\n                      ? \" (Agent 1)\"\r\n                      : isHiddenTargetMode && option.usesHeuristic\r\n                      ? \" (Hidden)\"\r\n                      : drawMode === \"WEIGHT\" && !option.supportsWeights\r\n                      ? \" (Unweighted)\"\r\n                      : \"\";\r\n                    return (\r\n                      <option\r\n                        key={option.value}\r\n                        value={option.value}\r\n                        disabled={isDisabled}\r\n                      >\r\n                        {option.shortLabel}\r\n                        {disabledReason}\r\n                      </option>\r\n                    );\r\n                  })}\r\n                </optgroup>\r\n              </select>\r\n            </div>\r\n          )}\r\n        </Accordion>\r\n\r\n        {/* === Section 2: Maze Generation === */}\r\n        <Accordion\r\n          title=\"Maze Generator\"\r\n          icon=\"\"\r\n          isOpen={activeGenSection === \"maze\"}\r\n          onToggle={() =>\r\n            setActiveGenSection(\r\n              activeGenSection === \"maze\" ? \"terrain\" : \"maze\"\r\n            )\r\n          }\r\n        >\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>Maze Type</label>\r\n            <select\r\n              value={selectedMaze || \"none\"}\r\n              onChange={handleMazeChange}\r\n              disabled={isVisualizing}\r\n              className={styles.select}\r\n              title=\"Select maze generation algorithm\"\r\n            >\r\n              {MAZE_OPTIONS.map((option) => (\r\n                <option key={option.value} value={option.value}>\r\n                  {option.label}  {option.description}\r\n                </option>\r\n              ))}\r\n            </select>\r\n          </div>\r\n\r\n          <div className={styles.mazeActions}>\r\n            <button\r\n              onClick={handleGenerateMaze}\r\n              disabled={isVisualizing || !selectedMaze}\r\n              className={styles.buttonSecondary}\r\n            >\r\n               Generate\r\n            </button>\r\n            <button\r\n              onClick={handleClearBoard}\r\n              disabled={isVisualizing}\r\n              className={styles.buttonGhost}\r\n            >\r\n               Clear Board\r\n            </button>\r\n          </div>\r\n\r\n          <p className={styles.hint}>Click: wall, Ctrl+click: remove</p>\r\n        </Accordion>\r\n\r\n        {/* === Section 3: Terrain Generation === */}\r\n        <Accordion\r\n          title=\"Terrain Generation\"\r\n          icon=\"\"\r\n          isOpen={activeGenSection === \"terrain\"}\r\n          onToggle={() =>\r\n            setActiveGenSection(\r\n              activeGenSection === \"terrain\" ? \"maze\" : \"terrain\"\r\n            )\r\n          }\r\n        >\r\n          <p className={styles.hint}>\r\n            Click: 12...10, Ctrl+click: decrement\r\n          </p>\r\n\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>Terrain Smoothness</label>\r\n            <select\r\n              value={terrainSmoothness}\r\n              onChange={handleTerrainSmoothnessChange}\r\n              disabled={isVisualizing}\r\n              className={styles.select}\r\n              title=\"Adjust terrain feature scale\"\r\n            >\r\n              {TERRAIN_SMOOTHNESS_OPTIONS.map((option) => (\r\n                <option key={option.value} value={option.value}>\r\n                  {option.label}  {option.description}\r\n                </option>\r\n              ))}\r\n            </select>\r\n          </div>\r\n\r\n          <div className={styles.controlGroup}>\r\n            <label className={styles.label}>\r\n              Peak Intensity: {Math.round((1 - terrainIntensity) * 100)}%\r\n            </label>\r\n            <input\r\n              type=\"range\"\r\n              min=\"0.3\"\r\n              max=\"1.2\"\r\n              step=\"0.05\"\r\n              value={terrainIntensity}\r\n              onChange={(e) => setTerrainIntensity(parseFloat(e.target.value))}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Lower = more high-weight peaks, Higher = more low-weight valleys\"\r\n            />\r\n            <div className={styles.sliderLabels}>\r\n              <span>More Peaks</span>\r\n              <span>More Valleys</span>\r\n            </div>\r\n          </div>\r\n\r\n          <div className={styles.mazeActions}>\r\n            <button\r\n              onClick={handleGenerateTerrain}\r\n              disabled={isVisualizing}\r\n              className={styles.buttonSecondary}\r\n              title=\"Generate terrain map\"\r\n            >\r\n               Generate Terrain\r\n            </button>\r\n            <button\r\n              onClick={handleClearBoard}\r\n              disabled={isVisualizing}\r\n              className={styles.buttonGhost}\r\n            >\r\n               Clear Board\r\n            </button>\r\n          </div>\r\n        </Accordion>\r\n\r\n        {/* === Section 4: Grid Settings === */}\r\n        <Accordion title=\"Settings\" icon=\"\">\r\n          {/* Speed Control */}\r\n          <div className={styles.controlGroup}>\r\n            <div className={styles.sliderHeader}>\r\n              <label className={styles.label}>Animation Speed</label>\r\n              <span className={styles.sliderValue}>{getSpeedLabel()}</span>\r\n            </div>\r\n            <input\r\n              type=\"range\"\r\n              min=\"1\"\r\n              max=\"50\"\r\n              value={animationSpeed}\r\n              onChange={handleSpeedChange}\r\n              disabled={isVisualizing}\r\n              className={styles.slider}\r\n              title=\"Adjust animation speed\"\r\n            />\r\n            <div className={styles.sliderLabels}>\r\n              <span>Fast</span>\r\n              <span>Slow</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* Grid Size Controls */}\r\n          <div className={styles.gridSizeSection}>\r\n            <div className={styles.modeSectionTitle}>Grid Size</div>\r\n\r\n            {/* Row Count */}\r\n            <div className={styles.controlGroup}>\r\n              <div className={styles.sliderHeader}>\r\n                <label className={styles.label}>Rows</label>\r\n                <span className={styles.sliderValue}>{rowCount}</span>\r\n              </div>\r\n              <input\r\n                type=\"range\"\r\n                min=\"5\"\r\n                max=\"40\"\r\n                value={rowCount}\r\n                onChange={handleRowChange}\r\n                disabled={isVisualizing}\r\n                className={styles.slider}\r\n                title=\"Adjust number of rows\"\r\n              />\r\n            </div>\r\n\r\n            {/* Column Count */}\r\n            <div className={styles.controlGroup}>\r\n              <div className={styles.sliderHeader}>\r\n                <label className={styles.label}>Columns</label>\r\n                <span className={styles.sliderValue}>{colCount}</span>\r\n              </div>\r\n              <input\r\n                type=\"range\"\r\n                min=\"5\"\r\n                max=\"60\"\r\n                value={colCount}\r\n                onChange={handleColChange}\r\n                disabled={isVisualizing}\r\n                className={styles.slider}\r\n                title=\"Adjust number of columns\"\r\n              />\r\n            </div>\r\n          </div>\r\n        </Accordion>\r\n      </div>\r\n\r\n      {/* Footer Instructions */}\r\n      <footer className={styles.footer}>\r\n        <div className={styles.instructionTitle}>Quick Tips</div>\r\n        <ul className={styles.instructionList}>\r\n          <li>\r\n            <kbd>Click</kbd> + drag to draw walls\r\n          </li>\r\n          <li>\r\n            <kbd>Ctrl</kbd> + click to erase\r\n          </li>\r\n          <li>\r\n            Drag <span className={styles.nodeHint}></span> or{\" \"}\r\n            <span className={styles.nodeHint}></span> to move\r\n          </li>\r\n        </ul>\r\n      </footer>\r\n    </aside>\r\n  );\r\n};\r\n\r\nexport default ControlPanel;\r\n","/**\r\n * Legend Component\r\n * Displays color legend for grid node types\r\n *\r\n * Shows all possible node states with their corresponding colors\r\n */\r\n\r\nimport React from \"react\";\r\nimport styles from \"./Legend.module.css\";\r\n\r\ninterface LegendItem {\r\n  label: string;\r\n  color?: string;\r\n  gradient?: string;\r\n  border?: string;\r\n  glow?: \"a1\" | \"a2\" | \"overlap\";\r\n  text?: string;\r\n}\r\n\r\nconst legendItems: LegendItem[] = [\r\n  // Basic nodes\r\n  { label: \"Start\", color: \"#4caf50\", border: \"2px solid #2e7d32\" },\r\n  { label: \"Target\", color: \"#f44336\", border: \"2px solid #c62828\" },\r\n  { label: \"Wall\", color: \"#34495e\", border: \"2px solid #2c3e50\" },\r\n\r\n  // Agent 1 (default) - blue\r\n  { label: \"Visited (A1)\", color: \"#b8c6db\", glow: \"a1\" },\r\n  { label: \"Path (A1)\", color: \"#1565c0\", border: \"3px solid #0d47a1\" },\r\n\r\n  // Agent 2 (race mode) - yellow\r\n  { label: \"Visited (A2)\", color: \"#b8c6db\", glow: \"a2\" },\r\n  { label: \"Path (A2)\", color: \"#fdd835\", border: \"3px solid #f9a825\" },\r\n\r\n  // Overlap - green\r\n  { label: \"Visited Overlap\", color: \"#b8c6db\", glow: \"overlap\" },\r\n  { label: \"Path Overlap\", color: \"#43a047\", border: \"3px solid #2e7d32\" },\r\n\r\n  // Terrain weights\r\n  { label: \"Weight 1\", color: \"#f5f0e6\", text: \"1\" },\r\n  { label: \"Weight 5\", color: \"#b8c6db\", text: \"5\" },\r\n  { label: \"Weight 10\", color: \"#64748b\", text: \"10\" },\r\n];\r\n\r\ninterface LegendProps {\r\n  orientation?: \"horizontal\" | \"vertical\";\r\n  compact?: boolean;\r\n}\r\n\r\nconst Legend: React.FC<LegendProps> = ({\r\n  orientation = \"horizontal\",\r\n  compact = false,\r\n}) => {\r\n  return (\r\n    <div\r\n      className={`${styles.legend} ${styles[orientation]} ${\r\n        compact ? styles.compact : \"\"\r\n      }`}\r\n      role=\"region\"\r\n      aria-label=\"Color Legend\"\r\n    >\r\n      <span className={styles.title}>Legend:</span>\r\n      <div className={styles.items}>\r\n        {legendItems.map((item) => (\r\n          <div key={item.label} className={styles.item}>\r\n            {/* eslint-disable-next-line react/forbid-dom-props */}\r\n            <div\r\n              className={`${styles.colorBox} ${\r\n                item.glow === \"a1\" ? styles.glowingA1 : \"\"\r\n              } ${item.glow === \"a2\" ? styles.glowingA2 : \"\"} ${\r\n                item.glow === \"overlap\" ? styles.glowingOverlap : \"\"\r\n              }`}\r\n              style={{\r\n                background: item.gradient || item.color,\r\n                border: item.border || \"none\",\r\n              }}\r\n              aria-hidden=\"true\"\r\n            >\r\n              {item.text && (\r\n                <span className={styles.weightText}>{item.text}</span>\r\n              )}\r\n            </div>\r\n            <span className={styles.label}>{item.label}</span>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Legend;\r\n","import { useEffect, useState } from \"react\";\r\nimport { useGrid } from \"../../context/GridContext\";\r\nimport styles from \"./Toast.module.css\";\r\n\r\n/**\r\n * Toast Notification Component\r\n * Displays slide-up notifications at bottom-center of screen\r\n * Auto-dismisses after 3 seconds with exit animation\r\n */\r\nconst Toast = () => {\r\n  const { toastMsg, clearToast } = useGrid();\r\n  const [isExiting, setIsExiting] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (!toastMsg) {\r\n      setIsExiting(false);\r\n      return;\r\n    }\r\n\r\n    // Start exit animation after 2.7s, then clear after 3s total\r\n    const exitTimer = setTimeout(() => {\r\n      setIsExiting(true);\r\n    }, 2700);\r\n\r\n    const clearTimer = setTimeout(() => {\r\n      clearToast();\r\n      setIsExiting(false);\r\n    }, 3000);\r\n\r\n    return () => {\r\n      clearTimeout(exitTimer);\r\n      clearTimeout(clearTimer);\r\n    };\r\n  }, [toastMsg, clearToast]);\r\n\r\n  if (!toastMsg) return null;\r\n\r\n  // Determine toast type based on message content\r\n  const getToastType = (): \"error\" | \"warning\" | \"success\" | undefined => {\r\n    if (\r\n      toastMsg.toLowerCase().includes(\"unreachable\") ||\r\n      toastMsg.toLowerCase().includes(\"no path\")\r\n    ) {\r\n      return \"error\";\r\n    }\r\n    if (toastMsg.toLowerCase().includes(\"warning\")) {\r\n      return \"warning\";\r\n    }\r\n    if (\r\n      toastMsg.toLowerCase().includes(\"success\") ||\r\n      toastMsg.toLowerCase().includes(\"complete\")\r\n    ) {\r\n      return \"success\";\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  const toastType = getToastType();\r\n\r\n  // Icon based on type\r\n  const getIcon = () => {\r\n    switch (toastType) {\r\n      case \"error\":\r\n        return \"\";\r\n      case \"warning\":\r\n        return \"\";\r\n      case \"success\":\r\n        return \"\";\r\n      default:\r\n        return \"\";\r\n    }\r\n  };\r\n\r\n  const toastClasses = [\r\n    styles.toast,\r\n    toastType ? styles[toastType] : \"\",\r\n    isExiting ? styles.exiting : \"\",\r\n  ]\r\n    .filter(Boolean)\r\n    .join(\" \");\r\n\r\n  return (\r\n    <div className={styles.toastContainer}>\r\n      <div className={toastClasses} role=\"alert\" aria-live=\"polite\">\r\n        <span className={styles.icon}>{getIcon()}</span>\r\n        <span className={styles.message}>{toastMsg}</span>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Toast;\r\n","/**\n * Path Visualization Utilities\n *\n * HARD RESET: All complex 8-segment/conic-gradient logic has been removed.\n * Path visualization will be handled by an SVG Overlay component instead.\n *\n * This file contains utility functions for path calculations.\n */\n\nimport { Node } from \"../types\";\n\n/**\n * Calculates the total weighted length of a path.\n * The path length is the sum of all node weights in the path.\n *\n * @param path - Array of nodes in the path\n * @returns Sum of weights of all nodes in the path, or -1 if path is invalid\n */\nexport function calculateWeightedPathLength(path: Node[]): number {\n  if (path.length <= 1) return -1;\n\n  // Sum the weights of all nodes in the path\n  return path.reduce((sum, node) => sum + node.weight, 0);\n}\n","/**\r\n * useBenchmarking Hook\r\n * Bridge between Main Thread and Benchmark Web Worker\r\n *\r\n * Provides a clean API for running isolated, high-precision benchmarks\r\n * without blocking the UI thread.\r\n *\r\n * Features:\r\n * - Automatic worker lifecycle management\r\n * - Promise-based API for async/await usage\r\n * - Cleanup on unmount (prevents memory leaks)\r\n * - Error handling with fallback\r\n */\r\n\r\nimport { useRef, useCallback, useEffect } from \"react\";\r\nimport { Grid, AlgorithmType } from \"../types\";\r\n\r\n// === TYPE DEFINITIONS ===\r\n\r\nexport interface BenchmarkResult {\r\n  avgTime: number; // Average time per execution in ms\r\n  iterations: number; // Number of iterations completed\r\n  opsPerSec: number; // Operations per second\r\n  totalTime: number; // Total benchmark duration\r\n}\r\n\r\ninterface WorkerResponse {\r\n  success: boolean;\r\n  data?: BenchmarkResult;\r\n  error?: string;\r\n  requestId: number; // Unique ID to match request with response\r\n}\r\n\r\n// Serialized format for transfer to worker\r\ntype SerializedNode = {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n};\r\n\r\ntype SerializedGrid = SerializedNode[][];\r\n\r\n// === HOOK CONFIGURATION ===\r\n\r\nconst DEFAULT_MIN_DURATION = 200; // Run benchmark for at least 200ms\r\n\r\n// === MAIN HOOK ===\r\n\r\n// Counter for unique request IDs (outside hook to persist across re-renders)\r\nlet requestIdCounter = 0;\r\n\r\nexport function useBenchmarking() {\r\n  // Worker instance ref (persists across renders)\r\n  const workerRef = useRef<Worker | null>(null);\r\n  // Map of pending promise resolvers keyed by request ID\r\n  // This allows multiple concurrent benchmark requests (e.g., race mode)\r\n  const pendingRequests = useRef<\r\n    Map<\r\n      number,\r\n      {\r\n        resolve: (value: BenchmarkResult) => void;\r\n        reject: (error: Error) => void;\r\n      }\r\n    >\r\n  >(new Map());\r\n\r\n  /**\r\n   * Initialize the worker on first use\r\n   */\r\n  const getWorker = useCallback((): Worker => {\r\n    if (!workerRef.current) {\r\n      // Vite-specific syntax for module workers\r\n      workerRef.current = new Worker(\r\n        new URL(\"../workers/benchmark.worker.ts\", import.meta.url),\r\n        { type: \"module\" }\r\n      );\r\n\r\n      // Set up message handler\r\n      workerRef.current.onmessage = (event: MessageEvent<WorkerResponse>) => {\r\n        const { requestId, success, data, error } = event.data;\r\n        const pending = pendingRequests.current.get(requestId);\r\n\r\n        if (pending) {\r\n          if (success && data) {\r\n            pending.resolve(data);\r\n          } else {\r\n            pending.reject(new Error(error || \"Benchmark failed\"));\r\n          }\r\n          pendingRequests.current.delete(requestId);\r\n        }\r\n      };\r\n\r\n      // Handle worker errors (reject all pending requests)\r\n      workerRef.current.onerror = (error) => {\r\n        console.error(\"Benchmark worker error:\", error);\r\n        const errorObj = new Error(\"Worker error: \" + error.message);\r\n        pendingRequests.current.forEach((pending) => {\r\n          pending.reject(errorObj);\r\n        });\r\n        pendingRequests.current.clear();\r\n      };\r\n    }\r\n\r\n    return workerRef.current;\r\n  }, []);\r\n\r\n  /**\r\n   * Serialize grid for transfer to worker\r\n   * Removes circular references (previousNode) and resets state\r\n   */\r\n  const serializeGrid = useCallback((grid: Grid): SerializedGrid => {\r\n    return grid.map((row) =>\r\n      row.map((node) => ({\r\n        row: node.row,\r\n        col: node.col,\r\n        isStart: node.isStart,\r\n        isFinish: node.isFinish,\r\n        isWall: node.isWall,\r\n      }))\r\n    );\r\n  }, []);\r\n\r\n  /**\r\n   * Find start and finish positions in grid\r\n   */\r\n  const findPositions = useCallback(\r\n    (\r\n      grid: Grid\r\n    ): {\r\n      startPos: { row: number; col: number };\r\n      finishPos: { row: number; col: number };\r\n    } | null => {\r\n      let startPos: { row: number; col: number } | null = null;\r\n      let finishPos: { row: number; col: number } | null = null;\r\n\r\n      for (const row of grid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startPos = { row: node.row, col: node.col };\r\n          if (node.isFinish) finishPos = { row: node.row, col: node.col };\r\n        }\r\n      }\r\n\r\n      if (!startPos || !finishPos) return null;\r\n      return { startPos, finishPos };\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Run a benchmark for the specified algorithm\r\n   *\r\n   * @param algorithm - The algorithm to benchmark\r\n   * @param grid - The current grid state\r\n   * @param minDuration - Minimum benchmark duration (default: 200ms)\r\n   * @returns Promise resolving to benchmark results\r\n   */\r\n  const runBenchmark = useCallback(\r\n    async (\r\n      algorithm: AlgorithmType,\r\n      grid: Grid,\r\n      minDuration: number = DEFAULT_MIN_DURATION\r\n    ): Promise<BenchmarkResult> => {\r\n      const worker = getWorker();\r\n      const positions = findPositions(grid);\r\n\r\n      if (!positions) {\r\n        throw new Error(\"Start or Finish node not found\");\r\n      }\r\n\r\n      // Serialize grid for transfer (removes circular refs)\r\n      const serializedGrid = serializeGrid(grid);\r\n\r\n      // Generate unique request ID for this benchmark\r\n      const requestId = ++requestIdCounter;\r\n\r\n      return new Promise((resolve, reject) => {\r\n        // Store resolvers keyed by request ID\r\n        pendingRequests.current.set(requestId, { resolve, reject });\r\n\r\n        // Send benchmark request to worker with request ID\r\n        worker.postMessage({\r\n          requestId,\r\n          algorithmName: algorithm,\r\n          gridData: serializedGrid,\r\n          startPos: positions.startPos,\r\n          finishPos: positions.finishPos,\r\n          minDuration,\r\n        });\r\n      });\r\n    },\r\n    [getWorker, findPositions, serializeGrid]\r\n  );\r\n\r\n  /**\r\n   * Terminate the worker (for cleanup)\r\n   */\r\n  const terminateWorker = useCallback(() => {\r\n    if (workerRef.current) {\r\n      workerRef.current.terminate();\r\n      workerRef.current = null;\r\n    }\r\n    // Reject all pending requests\r\n    pendingRequests.current.forEach((pending) => {\r\n      pending.reject(new Error(\"Worker terminated\"));\r\n    });\r\n    pendingRequests.current.clear();\r\n  }, []);\r\n\r\n  /**\r\n   * Cleanup on unmount\r\n   */\r\n  useEffect(() => {\r\n    return () => {\r\n      terminateWorker();\r\n    };\r\n  }, [terminateWorker]);\r\n\r\n  return {\r\n    runBenchmark,\r\n    terminateWorker,\r\n  };\r\n}\r\n\r\nexport default useBenchmarking;\r\n","/**\r\n * useVisualization Hook\r\n * Phase B & C: Animation System for Pathfinding and Maze Generation\r\n *\r\n * ARCHITECTURE: Industrial-Grade Benchmarking with Web Worker Isolation\r\n * - Timing runs in dedicated Web Worker (zero UI interference)\r\n * - Main thread only handles animation (DOM manipulation)\r\n * - Scientific precision: adaptive sampling until 200ms elapsed\r\n *\r\n * Uses direct DOM manipulation for performance (1000+ nodes).\r\n * Does NOT use React setState inside animation loops.\r\n */\r\n\r\nimport { useCallback, useRef } from \"react\";\r\nimport { Grid, Node, MazeType, AlgorithmType } from \"../types\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/pathfinding/dijkstra\";\r\nimport {\r\n  astar,\r\n  getNodesInShortestPathOrder as getAstarPath,\r\n} from \"../algorithms/pathfinding/astar\";\r\nimport {\r\n  bfs,\r\n  getNodesInShortestPathOrder as getBfsPath,\r\n} from \"../algorithms/pathfinding/bfs\";\r\nimport {\r\n  dfs,\r\n  getNodesInShortestPathOrder as getDfsPath,\r\n} from \"../algorithms/pathfinding/dfs\";\r\nimport {\r\n  greedyBestFirst,\r\n  getNodesInShortestPathOrder as getGreedyPath,\r\n} from \"../algorithms/pathfinding/greedyBestFirst\";\r\nimport {\r\n  bidirectionalBFS,\r\n  getNodesInShortestPathOrder as getBidirectionalPath,\r\n} from \"../algorithms/pathfinding/bidirectionalBFS\";\r\nimport {\r\n  bidirectionalAStar,\r\n  getNodesInShortestPathOrder as getBidirectionalAStarPath,\r\n} from \"../algorithms/pathfinding/bidirectionalAStar\";\r\nimport {\r\n  jumpPointSearch,\r\n  getNodesInShortestPathOrder as getJPSPath,\r\n} from \"../algorithms/pathfinding/jumpPointSearch\";\r\nimport { getRecursiveDivisionMaze } from \"../algorithms/maze/recursiveDivision\";\r\nimport { getRandomizedDFSMaze } from \"../algorithms/maze/randomizedDFS\";\r\nimport { getPrimsMaze } from \"../algorithms/maze/prims\";\r\nimport { getSpiralMaze } from \"../algorithms/maze/spiralMaze\";\r\nimport { getCellularAutomataMaze } from \"../algorithms/maze/cellularAutomata\";\r\nimport { generateTerrainMap, TerrainNode } from \"../algorithms/maze/terrainMap\";\r\nimport { resetGridForPathfinding, clearWalls } from \"../utils/gridUtils\";\r\nimport { calculateWeightedPathLength } from \"../utils/pathUtils\";\r\nimport { AlgorithmStats, RaceStats } from \"../components/Modals/StatsModal\";\r\nimport { useBenchmarking } from \"./useBenchmarking\";\r\nimport { RunRecord } from \"../types\";\r\n\r\n/**\r\n * Callbacks for stats and scroll behavior\r\n */\r\ninterface StatsCallbacks {\r\n  setVisualizationStats: React.Dispatch<\r\n    React.SetStateAction<AlgorithmStats | RaceStats | null>\r\n  >;\r\n  scrollToStats: () => void;\r\n  showToast?: (msg: string) => void;\r\n  addRunRecord?: (record: Omit<RunRecord, \"id\" | \"timestamp\" | \"date\">) => void;\r\n  gridSize?: string; // e.g., \"20x30\"\r\n}\r\n\r\n/**\r\n * Return type for the useVisualization hook\r\n */\r\ninterface UseVisualizationReturn {\r\n  visualizePathfinding: (\r\n    algorithm: AlgorithmType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number,\r\n    statsCallbacks?: StatsCallbacks\r\n  ) => void;\r\n  visualizeRace: (\r\n    algo1: AlgorithmType,\r\n    algo2: AlgorithmType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number,\r\n    statsCallbacks?: StatsCallbacks\r\n  ) => void;\r\n  generateMaze: (\r\n    mazeType: MazeType,\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n    setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n    speed: number,\r\n    terrainConfig?: { frequency: number; intensity?: number }\r\n  ) => void;\r\n  clearVisualization: (\r\n    grid: Grid,\r\n    setGrid: React.Dispatch<React.SetStateAction<Grid>>\r\n  ) => void;\r\n  isAnimating: React.MutableRefObject<boolean>;\r\n}\r\n\r\n/**\r\n * Custom hook for managing pathfinding visualization animations\r\n *\r\n * Key Design Decisions:\r\n * - Direct DOM manipulation via getElementById (bypasses React for performance)\r\n * - setTimeout-based animation queue (non-blocking UI)\r\n * - CSS class toggling for visual effects\r\n * - Ref-based animation state to prevent stale closures\r\n */\r\nexport const useVisualization = (): UseVisualizationReturn => {\r\n  // Track animation state with ref (not state - to avoid stale closures)\r\n  const isAnimating = useRef<boolean>(false);\r\n  // Store timeout IDs for cleanup\r\n  const timeoutIds = useRef<ReturnType<typeof setTimeout>[]>([]);\r\n\r\n  // === WEB WORKER BENCHMARKING ===\r\n  // Industrial-grade timing isolated from UI thread\r\n  const { runBenchmark } = useBenchmarking();\r\n\r\n  // Benchmark duration: run algorithm repeatedly for 1 second to get stable average\r\n  const BENCHMARK_MIN_DURATION = 1000;\r\n\r\n  /**\r\n   * Clears all pending animation timeouts\r\n   */\r\n  const clearAllTimeouts = useCallback((): void => {\r\n    timeoutIds.current.forEach((id) => clearTimeout(id));\r\n    timeoutIds.current = [];\r\n  }, []);\r\n\r\n  /**\r\n   * Removes visualization CSS classes from all nodes via DOM\r\n   * SIMPLIFIED: Only handles basic visited/path classes\r\n   */\r\n  const clearVisualizationClasses = useCallback((): void => {\r\n    // Remove visited and path classes from all nodes (both agents)\r\n    const visitedNodes = document.querySelectorAll(\".node-visited\");\r\n    const pathNodes = document.querySelectorAll(\".node-path\");\r\n    const visitedNodesSecond = document.querySelectorAll(\r\n      \".node-visited-second\"\r\n    );\r\n    const pathNodesSecond = document.querySelectorAll(\".node-path-second\");\r\n    const overlapNodes = document.querySelectorAll(\".node-visited-overlap\");\r\n    // Simple path overlap class (for mixed color)\r\n    const pathOverlapNodes = document.querySelectorAll(\".node-path-overlap\");\r\n\r\n    visitedNodes.forEach((node) => {\r\n      node.classList.remove(\"node-visited\");\r\n    });\r\n\r\n    pathNodes.forEach((node) => {\r\n      node.classList.remove(\"node-path\");\r\n    });\r\n\r\n    visitedNodesSecond.forEach((node) => {\r\n      node.classList.remove(\"node-visited-second\");\r\n    });\r\n\r\n    pathNodesSecond.forEach((node) => {\r\n      node.classList.remove(\"node-path-second\");\r\n    });\r\n\r\n    overlapNodes.forEach((node) => {\r\n      node.classList.remove(\"node-visited-overlap\");\r\n    });\r\n\r\n    // Clear simple path overlap class\r\n    pathOverlapNodes.forEach((node) => {\r\n      node.classList.remove(\"node-path-overlap\");\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Clears the visualization (both DOM and React state)\r\n   */\r\n  const clearVisualization = useCallback(\r\n    (grid: Grid, setGrid: React.Dispatch<React.SetStateAction<Grid>>): void => {\r\n      // Stop any ongoing animation\r\n      clearAllTimeouts();\r\n      isAnimating.current = false;\r\n\r\n      // Clear DOM classes\r\n      clearVisualizationClasses();\r\n\r\n      // Reset React state (distance, previousNode, isVisited)\r\n      setGrid(resetGridForPathfinding(grid));\r\n    },\r\n    [clearAllTimeouts, clearVisualizationClasses]\r\n  );\r\n\r\n  /**\r\n   * Animates the visited nodes one by one\r\n   * Uses setTimeout with increasing delays based on index\r\n   */\r\n  const animateVisitedNodes = useCallback(\r\n    (\r\n      visitedNodesInOrder: Node[],\r\n      speed: number,\r\n      onComplete: () => void\r\n    ): void => {\r\n      for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n\r\n          // Skip Start and Finish nodes (preserve their colors)\r\n          if (node.isStart || node.isFinish) {\r\n            // If this is the last node, trigger path animation\r\n            if (i === visitedNodesInOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation for performance\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            element.classList.add(\"node-visited\");\r\n          }\r\n\r\n          // If this is the last node, trigger path animation\r\n          if (i === visitedNodesInOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Animates the shortest path nodes\r\n   * Called after visited animation completes\r\n   */\r\n  const animateShortestPath = useCallback(\r\n    (\r\n      nodesInShortestPathOrder: Node[],\r\n      speed: number,\r\n      onComplete: () => void\r\n    ): void => {\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n\r\n          // Skip Start and Finish nodes (preserve their colors)\r\n          if (node.isStart || node.isFinish) {\r\n            if (i === nodesInShortestPathOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            // Remove visited class first, then add path class\r\n            element.classList.remove(\"node-visited\");\r\n            element.classList.add(\"node-path\");\r\n          }\r\n\r\n          // If this is the last node, mark animation as complete\r\n          if (i === nodesInShortestPathOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * (speed * 3)); // Path animation is slower (3x)\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Helper function to run an algorithm and get results\r\n   * Extracted for reuse in benchmarking and race mode\r\n   */\r\n  const runAlgorithm = useCallback(\r\n    (\r\n      algorithm: AlgorithmType,\r\n      algorithmGrid: Grid,\r\n      startNode: Node,\r\n      finishNode: Node\r\n    ): { visitedNodes: Node[]; pathNodes: Node[] } => {\r\n      let visitedNodes: Node[] = [];\r\n      let pathNodes: Node[] = [];\r\n\r\n      switch (algorithm) {\r\n        case AlgorithmType.ASTAR:\r\n          visitedNodes = astar(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getAstarPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BFS:\r\n          visitedNodes = bfs(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getBfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DFS:\r\n          visitedNodes = dfs(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getDfsPath(finishNode);\r\n          break;\r\n        case AlgorithmType.GREEDY_BEST_FIRST:\r\n          visitedNodes = greedyBestFirst(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getGreedyPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BIDIRECTIONAL_BFS:\r\n          visitedNodes = bidirectionalBFS(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getBidirectionalPath(finishNode);\r\n          break;\r\n        case AlgorithmType.BIDIRECTIONAL_ASTAR:\r\n          visitedNodes = bidirectionalAStar(\r\n            algorithmGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          pathNodes = getBidirectionalAStarPath(finishNode);\r\n          break;\r\n        case AlgorithmType.JUMP_POINT_SEARCH:\r\n          visitedNodes = jumpPointSearch(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getJPSPath(finishNode);\r\n          break;\r\n        case AlgorithmType.DIJKSTRA:\r\n        default:\r\n          visitedNodes = dijkstra(algorithmGrid, startNode, finishNode);\r\n          pathNodes = getNodesInShortestPathOrder(finishNode);\r\n          break;\r\n      }\r\n\r\n      return { visitedNodes, pathNodes };\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Main visualization function for pathfinding algorithms\r\n   *\r\n   * ARCHITECTURE: Web Worker Isolation for Scientific Timing\r\n   * - Phase 1: ASYNC BENCHMARK - Run in Web Worker (isolated from UI thread)\r\n   * - Phase 2: LOCAL EXECUTION - Run once on main thread for animation data\r\n   * - Phase 3: ANIMATION - DOM manipulation for visual feedback\r\n   * - Phase 4: CLEANUP - Reset animation state\r\n   *\r\n   * The timing number comes from the Worker (rock-solid stable).\r\n   * The animation data comes from a single main-thread run (visual only).\r\n   */\r\n  const visualizePathfinding = useCallback(\r\n    async (\r\n      algorithm: AlgorithmType,\r\n      grid: Grid,\r\n      _setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number,\r\n      statsCallbacks?: StatsCallbacks\r\n    ): Promise<void> => {\r\n      // Prevent multiple visualizations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous visualization (DOM classes)\r\n      clearAllTimeouts();\r\n      clearVisualizationClasses();\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // === PHASE 1: WEB WORKER BENCHMARK (Isolated Thread) ===\r\n      // This runs in a separate thread - no UI interference\r\n      let benchmarkResult: { avgTime: number } | null = null;\r\n      try {\r\n        benchmarkResult = await runBenchmark(\r\n          algorithm,\r\n          grid,\r\n          BENCHMARK_MIN_DURATION\r\n        );\r\n      } catch (error) {\r\n        console.warn(\"Worker benchmark failed, using fallback:\", error);\r\n        // Fallback: single measurement on main thread\r\n        benchmarkResult = null;\r\n      }\r\n\r\n      // === PHASE 2: LOCAL EXECUTION (For Animation Data) ===\r\n      // Run algorithm once on main thread to get visitedNodes for animation\r\n      // This execution time is NOT reported - only used for visual data\r\n      const algorithmGrid: Grid = grid.map((row) =>\r\n        row.map((node) => ({\r\n          ...node,\r\n          isVisited: false,\r\n          distance: Infinity,\r\n          previousNode: null,\r\n        }))\r\n      );\r\n\r\n      let startNode: Node | null = null;\r\n      let finishNode: Node | null = null;\r\n      for (const row of algorithmGrid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode = node;\r\n          if (node.isFinish) finishNode = node;\r\n        }\r\n      }\r\n\r\n      if (!startNode || !finishNode) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n        return;\r\n      }\r\n\r\n      // Fallback timing if worker failed\r\n      const fallbackStart = performance.now();\r\n      const { visitedNodes, pathNodes } = runAlgorithm(\r\n        algorithm,\r\n        algorithmGrid,\r\n        startNode,\r\n        finishNode\r\n      );\r\n      const fallbackTime = performance.now() - fallbackStart;\r\n\r\n      // Use worker time if available, otherwise fallback\r\n      const executionTime = benchmarkResult?.avgTime ?? fallbackTime;\r\n\r\n      const visitedNodesInOrder = visitedNodes;\r\n      const nodesInShortestPathOrder = pathNodes;\r\n\r\n      // Check if path was found\r\n      const pathFound = nodesInShortestPathOrder.length > 1;\r\n\r\n      // Capture stats\r\n      const stats: AlgorithmStats = {\r\n        algorithm,\r\n        executionTime,\r\n        visitedCount: visitedNodesInOrder.length,\r\n        pathLength: calculateWeightedPathLength(nodesInShortestPathOrder),\r\n      };\r\n\r\n      // === PHASE 3: ANIMATION (DOM Manipulation) ===\r\n      animateVisitedNodes(visitedNodesInOrder, speed, () => {\r\n        if (!pathFound) {\r\n          isAnimating.current = false;\r\n          setIsVisualizing(false);\r\n\r\n          if (statsCallbacks) {\r\n            statsCallbacks.setVisualizationStats(stats);\r\n            // Add to run history\r\n            if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n              statsCallbacks.addRunRecord({\r\n                mode: \"Single\",\r\n                algorithm1: stats.algorithm,\r\n                gridSize: statsCallbacks.gridSize,\r\n                time1: stats.executionTime,\r\n                pathLength1: stats.pathLength,\r\n                visitedCount1: stats.visitedCount,\r\n              });\r\n            }\r\n            if (statsCallbacks.showToast) {\r\n              statsCallbacks.showToast(\r\n                \"Target is unreachable! No path exists.\"\r\n              );\r\n            }\r\n            setTimeout(() => {\r\n              statsCallbacks.scrollToStats();\r\n            }, 500);\r\n          }\r\n          return;\r\n        }\r\n\r\n        const pathDelay = setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder, speed, () => {\r\n            // === PHASE 4: CLEANUP ===\r\n            isAnimating.current = false;\r\n            setIsVisualizing(false);\r\n\r\n            if (statsCallbacks) {\r\n              statsCallbacks.setVisualizationStats(stats);\r\n              // Add to run history\r\n              if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n                statsCallbacks.addRunRecord({\r\n                  mode: \"Single\",\r\n                  algorithm1: stats.algorithm,\r\n                  gridSize: statsCallbacks.gridSize,\r\n                  time1: stats.executionTime,\r\n                  pathLength1: stats.pathLength,\r\n                  visitedCount1: stats.visitedCount,\r\n                });\r\n              }\r\n              setTimeout(() => {\r\n                statsCallbacks.scrollToStats();\r\n              }, 500);\r\n            }\r\n          });\r\n        }, 50);\r\n        timeoutIds.current.push(pathDelay);\r\n      });\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      animateVisitedNodes,\r\n      animateShortestPath,\r\n      runAlgorithm,\r\n      runBenchmark,\r\n      BENCHMARK_MIN_DURATION,\r\n    ]\r\n  );\r\n\r\n  /**\r\n   * Removes wall CSS classes from all nodes via DOM\r\n   */\r\n  const clearWallClasses = useCallback((): void => {\r\n    const wallNodes = document.querySelectorAll(\".node-wall\");\r\n    wallNodes.forEach((node) => {\r\n      node.classList.remove(\"node-wall\");\r\n    });\r\n  }, []);\r\n\r\n  /**\r\n   * Removes weight CSS classes from all nodes via DOM\r\n   */\r\n  const clearWeightClasses = useCallback((): void => {\r\n    for (let w = 1; w <= 10; w++) {\r\n      const weightNodes = document.querySelectorAll(`.node-weight-${w}`);\r\n      weightNodes.forEach((node) => {\r\n        node.classList.remove(`node-weight-${w}`);\r\n        // Also clear the weight number display\r\n        const weightSpan = node.querySelector(\".weight-number\");\r\n        if (weightSpan) {\r\n          weightSpan.textContent = \"\";\r\n        }\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Animates maze wall generation\r\n   * Uses setTimeout to sequentially add walls for visual effect\r\n   * Protects Start/Finish nodes from being turned into walls\r\n   */\r\n  const animateMazeWalls = useCallback(\r\n    (wallsInOrder: Node[], speed: number, onComplete: () => void): void => {\r\n      for (let i = 0; i < wallsInOrder.length; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          const node = wallsInOrder[i];\r\n\r\n          // PROTECTION: Skip Start and Finish nodes (never turn them into walls)\r\n          if (node.isStart || node.isFinish) {\r\n            // If this is the last wall, trigger completion\r\n            if (i === wallsInOrder.length - 1) {\r\n              onComplete();\r\n            }\r\n            return;\r\n          }\r\n\r\n          // Direct DOM manipulation for wall animation\r\n          const element = document.getElementById(\r\n            `node-${node.row}-${node.col}`\r\n          );\r\n          if (element) {\r\n            element.classList.add(\"node-wall\");\r\n          }\r\n\r\n          // If this is the last wall, trigger completion\r\n          if (i === wallsInOrder.length - 1) {\r\n            onComplete();\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n\r\n      // Handle empty walls array\r\n      if (wallsInOrder.length === 0) {\r\n        onComplete();\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Animates terrain map generation\r\n   * Uses setTimeout to sequentially apply weights for visual effect\r\n   * Updates DOM classes based on weight values\r\n   */\r\n  const animateTerrainMap = useCallback(\r\n    (\r\n      terrainNodes: TerrainNode[],\r\n      speed: number,\r\n      onComplete: () => void\r\n    ): void => {\r\n      // Batch size for faster animation (terrain has many nodes)\r\n      const batchSize = Math.max(1, Math.floor(50 / Math.max(1, speed)));\r\n\r\n      for (let i = 0; i < terrainNodes.length; i += batchSize) {\r\n        const batchIndex = Math.floor(i / batchSize);\r\n        const timeoutId = setTimeout(() => {\r\n          // Process batch of nodes\r\n          const batch = terrainNodes.slice(\r\n            i,\r\n            Math.min(i + batchSize, terrainNodes.length)\r\n          );\r\n\r\n          for (const terrain of batch) {\r\n            // Direct DOM manipulation for terrain animation\r\n            const element = document.getElementById(\r\n              `node-${terrain.row}-${terrain.col}`\r\n            );\r\n            if (element) {\r\n              // Remove any existing weight classes\r\n              for (let w = 1; w <= 10; w++) {\r\n                element.classList.remove(`node-weight-${w}`);\r\n              }\r\n              element.classList.remove(\"node-wall\");\r\n\r\n              // Add new weight class\r\n              element.classList.add(`node-weight-${terrain.weight}`);\r\n\r\n              // Update the displayed weight number\r\n              const weightSpan = element.querySelector(\".weight-number\");\r\n              if (weightSpan) {\r\n                if (terrain.weight === 10) {\r\n                  weightSpan.textContent = \"\";\r\n                } else if (terrain.weight > 1) {\r\n                  weightSpan.textContent = terrain.weight.toString();\r\n                } else {\r\n                  weightSpan.textContent = \"\";\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // If this is the last batch, trigger completion\r\n          if (i + batchSize >= terrainNodes.length) {\r\n            onComplete();\r\n          }\r\n        }, batchIndex * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n\r\n      // Handle empty terrain array\r\n      if (terrainNodes.length === 0) {\r\n        onComplete();\r\n      }\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Main maze generation function\r\n   *\r\n   * Steps:\r\n   * A. Clear any existing visualization and walls\r\n   * B. Get maze walls from algorithm\r\n   * C. Animate wall building\r\n   * D. Sync React state with final walls\r\n   */\r\n  const generateMaze = useCallback(\r\n    (\r\n      mazeType: MazeType,\r\n      grid: Grid,\r\n      setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number,\r\n      terrainConfig?: { frequency: number; intensity?: number }\r\n    ): void => {\r\n      // Prevent multiple generations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous animations and timeouts\r\n      clearAllTimeouts();\r\n\r\n      // === DOM SAFETY NET ===\r\n      // Explicitly clear ALL visualization classes from DOM before starting\r\n      // This ensures a clean slate even if React state and DOM are out of sync\r\n      clearVisualizationClasses(); // Removes .node-visited and .node-path\r\n      clearWallClasses(); // Removes .node-wall\r\n      clearWeightClasses(); // Removes .node-weight-* classes\r\n\r\n      // Step A: Clear walls AND pathfinding state from React state\r\n      // First reset pathfinding (isVisited, distance, previousNode)\r\n      const resetGrid = resetGridForPathfinding(grid);\r\n      // Then clear walls\r\n      const clearedGrid = clearWalls(resetGrid);\r\n      setGrid(clearedGrid);\r\n\r\n      // Find Start and Finish nodes\r\n      let startNode: Node | null = null;\r\n      let finishNode: Node | null = null;\r\n\r\n      for (const row of clearedGrid) {\r\n        for (const node of row) {\r\n          if (node.isStart) startNode = node;\r\n          if (node.isFinish) finishNode = node;\r\n        }\r\n      }\r\n\r\n      // Safety check\r\n      if (!startNode || !finishNode) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        return;\r\n      }\r\n\r\n      // Step B: Get maze walls based on algorithm type\r\n      let wallsInOrder: Node[] = [];\r\n      let terrainNodesInOrder: TerrainNode[] = [];\r\n      let animationSpeed = speed;\r\n      let isTerrain = false;\r\n\r\n      switch (mazeType) {\r\n        case MazeType.RECURSIVE_DIVISION:\r\n          wallsInOrder = getRecursiveDivisionMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          break;\r\n        case MazeType.RANDOMIZED_DFS:\r\n          wallsInOrder = getRandomizedDFSMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          // DFS generates many walls - use faster animation (5ms min)\r\n          animationSpeed = Math.max(5, speed / 3);\r\n          break;\r\n        case MazeType.PRIMS:\r\n          wallsInOrder = getPrimsMaze(clearedGrid, startNode, finishNode);\r\n          // Prim's generates many walls - use faster animation\r\n          animationSpeed = Math.max(5, speed / 3);\r\n          break;\r\n        case MazeType.SPIRAL:\r\n          wallsInOrder = getSpiralMaze(clearedGrid, startNode, finishNode);\r\n          break;\r\n        case MazeType.CELLULAR_AUTOMATA:\r\n          wallsInOrder = getCellularAutomataMaze(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode\r\n          );\r\n          // Cellular automata generates many walls - use faster animation\r\n          animationSpeed = Math.max(5, speed / 3);\r\n          break;\r\n        case MazeType.TERRAIN_MAP:\r\n          terrainNodesInOrder = generateTerrainMap(\r\n            clearedGrid,\r\n            startNode,\r\n            finishNode,\r\n            terrainConfig\r\n              ? {\r\n                  frequency: terrainConfig.frequency,\r\n                  intensity: terrainConfig.intensity,\r\n                }\r\n              : undefined\r\n          );\r\n          isTerrain = true;\r\n          // Terrain has many nodes - use fast animation\r\n          animationSpeed = Math.max(3, speed / 4);\r\n          break;\r\n        default:\r\n          console.error(\"Unknown maze type:\", mazeType);\r\n          return;\r\n      }\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // Step C: Animate wall building OR terrain generation\r\n      // Use setTimeout to allow React to process the grid state update first\r\n      // This ensures isVisited=false is rendered before animation starts\r\n      setTimeout(() => {\r\n        if (isTerrain) {\r\n          // Terrain Map: Animate weight assignments\r\n          animateTerrainMap(terrainNodesInOrder, animationSpeed, () => {\r\n            // Step D: Sync React state with terrain weights\r\n            setGrid((currentGrid) => {\r\n              const newGrid = currentGrid.map((row) =>\r\n                row.map((node) => ({ ...node }))\r\n              );\r\n\r\n              // Apply all terrain weights\r\n              for (const terrain of terrainNodesInOrder) {\r\n                if (\r\n                  !newGrid[terrain.row][terrain.col].isStart &&\r\n                  !newGrid[terrain.row][terrain.col].isFinish\r\n                ) {\r\n                  newGrid[terrain.row][terrain.col].weight = terrain.weight;\r\n                  newGrid[terrain.row][terrain.col].isWall = false;\r\n                }\r\n              }\r\n\r\n              return newGrid;\r\n            });\r\n\r\n            // Animation complete\r\n            isAnimating.current = false;\r\n            setIsVisualizing(false);\r\n          });\r\n        } else {\r\n          // Wall-based maze: Animate wall building\r\n          animateMazeWalls(wallsInOrder, animationSpeed, () => {\r\n            // Step D: Sync React state with walls\r\n            // This is CRUCIAL - without this, Dijkstra won't see the walls\r\n            setGrid((currentGrid) => {\r\n              const newGrid = currentGrid.map((row) =>\r\n                row.map((node) => ({ ...node }))\r\n              );\r\n\r\n              // Mark all walls in the grid state\r\n              for (const wall of wallsInOrder) {\r\n                if (\r\n                  !newGrid[wall.row][wall.col].isStart &&\r\n                  !newGrid[wall.row][wall.col].isFinish\r\n                ) {\r\n                  newGrid[wall.row][wall.col].isWall = true;\r\n                }\r\n              }\r\n\r\n              return newGrid;\r\n            });\r\n\r\n            // Animation complete\r\n            isAnimating.current = false;\r\n            setIsVisualizing(false);\r\n          });\r\n        }\r\n      }, 50); // Small delay to let React re-render with cleared state\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      clearWallClasses,\r\n      clearWeightClasses,\r\n      animateMazeWalls,\r\n      animateTerrainMap,\r\n    ]\r\n  );\r\n\r\n  /**\r\n   * Race Mode: Run two algorithms simultaneously and animate them together\r\n   *\r\n   * ARCHITECTURE: Web Worker Isolation for Scientific Timing (Both Algorithms)\r\n   * - Phase 1: ASYNC BENCHMARK - Run both algorithms in Web Worker (parallel)\r\n   * - Phase 2: LOCAL EXECUTION - Run once each on main thread for animation data\r\n   * - Phase 3: ANIMATION - DOM manipulation for visual feedback\r\n   * - Phase 4: CLEANUP - Reset animation state\r\n   */\r\n  const visualizeRace = useCallback(\r\n    async (\r\n      algo1: AlgorithmType,\r\n      algo2: AlgorithmType,\r\n      grid: Grid,\r\n      _setGrid: React.Dispatch<React.SetStateAction<Grid>>,\r\n      setIsVisualizing: React.Dispatch<React.SetStateAction<boolean>>,\r\n      speed: number,\r\n      statsCallbacks?: StatsCallbacks\r\n    ): Promise<void> => {\r\n      // Prevent multiple visualizations\r\n      if (isAnimating.current) return;\r\n\r\n      // Clear any previous visualization\r\n      clearAllTimeouts();\r\n      clearVisualizationClasses();\r\n\r\n      // Mark as visualizing\r\n      isAnimating.current = true;\r\n      setIsVisualizing(true);\r\n\r\n      // === PHASE 1: WEB WORKER BENCHMARK (Both Algorithms in Parallel) ===\r\n      let benchmark1Result: { avgTime: number } | null = null;\r\n      let benchmark2Result: { avgTime: number } | null = null;\r\n\r\n      try {\r\n        // Run both benchmarks in parallel for efficiency\r\n        const [b1, b2] = await Promise.all([\r\n          runBenchmark(algo1, grid, BENCHMARK_MIN_DURATION),\r\n          runBenchmark(algo2, grid, BENCHMARK_MIN_DURATION),\r\n        ]);\r\n        benchmark1Result = b1;\r\n        benchmark2Result = b2;\r\n      } catch (error) {\r\n        console.warn(\"Worker benchmark failed, using fallback:\", error);\r\n      }\r\n\r\n      // === PHASE 2: LOCAL EXECUTION (For Animation Data) ===\r\n      const createGridCopy = (): Grid =>\r\n        grid.map((row) =>\r\n          row.map((node) => ({\r\n            ...node,\r\n            isVisited: false,\r\n            distance: Infinity,\r\n            previousNode: null,\r\n          }))\r\n        );\r\n\r\n      const findNodes = (g: Grid): { start: Node; finish: Node } | null => {\r\n        let start: Node | null = null;\r\n        let finish: Node | null = null;\r\n        for (const row of g) {\r\n          for (const node of row) {\r\n            if (node.isStart) start = node;\r\n            if (node.isFinish) finish = node;\r\n          }\r\n        }\r\n        if (!start || !finish) return null;\r\n        return { start, finish };\r\n      };\r\n\r\n      // Run algo1 for animation data\r\n      const grid1 = createGridCopy();\r\n      const nodes1 = findNodes(grid1);\r\n      if (!nodes1) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n        return;\r\n      }\r\n\r\n      const fallback1Start = performance.now();\r\n      const result1 = runAlgorithm(algo1, grid1, nodes1.start, nodes1.finish);\r\n      const fallback1Time = performance.now() - fallback1Start;\r\n\r\n      // Run algo2 for animation data\r\n      const grid2 = createGridCopy();\r\n      const nodes2 = findNodes(grid2);\r\n      if (!nodes2) {\r\n        console.error(\"Start or Finish node not found!\");\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n        return;\r\n      }\r\n\r\n      const fallback2Start = performance.now();\r\n      const result2 = runAlgorithm(algo2, grid2, nodes2.start, nodes2.finish);\r\n      const fallback2Time = performance.now() - fallback2Start;\r\n\r\n      // Use worker times if available\r\n      const executionTime1 = benchmark1Result?.avgTime ?? fallback1Time;\r\n      const executionTime2 = benchmark2Result?.avgTime ?? fallback2Time;\r\n\r\n      const visited1 = result1.visitedNodes;\r\n      const visited2 = result2.visitedNodes;\r\n      const path1 = result1.pathNodes;\r\n      const path2 = result2.pathNodes;\r\n\r\n      // Check if paths were found\r\n      const path1Found = path1.length > 1;\r\n      const path2Found = path2.length > 1;\r\n\r\n      // Capture stats\r\n      const stats1: AlgorithmStats = {\r\n        algorithm: algo1,\r\n        executionTime: executionTime1,\r\n        visitedCount: visited1.length,\r\n        pathLength: calculateWeightedPathLength(path1),\r\n      };\r\n\r\n      const stats2: AlgorithmStats = {\r\n        algorithm: algo2,\r\n        executionTime: executionTime2,\r\n        visitedCount: visited2.length,\r\n        pathLength: calculateWeightedPathLength(path2),\r\n      };\r\n\r\n      // Determine winner\r\n      let winner: \"agent1\" | \"agent2\" | \"tie\" = \"tie\";\r\n      if (path1Found && path2Found) {\r\n        // Winner is determined by weighted path length (lower is better)\r\n        const weightedLength1 = calculateWeightedPathLength(path1);\r\n        const weightedLength2 = calculateWeightedPathLength(path2);\r\n        if (weightedLength1 < weightedLength2) {\r\n          winner = \"agent1\";\r\n        } else if (weightedLength2 < weightedLength1) {\r\n          winner = \"agent2\";\r\n        } else if (stats1.executionTime < stats2.executionTime) {\r\n          winner = \"agent1\";\r\n        } else if (stats2.executionTime < stats1.executionTime) {\r\n          winner = \"agent2\";\r\n        }\r\n      } else if (path1Found) {\r\n        winner = \"agent1\";\r\n      } else if (path2Found) {\r\n        winner = \"agent2\";\r\n      }\r\n\r\n      const raceStats: RaceStats = {\r\n        agent1: stats1,\r\n        agent2: stats2,\r\n        winner,\r\n      };\r\n\r\n      // Track which nodes have been visited by which agent\r\n      const visitedByAgent1 = new Set<string>();\r\n      const visitedByAgent2 = new Set<string>();\r\n\r\n      // === PHASE 2: PARALLEL ANIMATION ===\r\n      const maxVisitedLen = Math.max(visited1.length, visited2.length);\r\n\r\n      for (let i = 0; i < maxVisitedLen; i++) {\r\n        const timeoutId = setTimeout(() => {\r\n          // Agent 1 animation\r\n          if (i < visited1.length) {\r\n            const node1 = visited1[i];\r\n            if (!node1.isStart && !node1.isFinish) {\r\n              const key1 = `${node1.row}-${node1.col}`;\r\n              const element1 = document.getElementById(\r\n                `node-${node1.row}-${node1.col}`\r\n              );\r\n              if (element1) {\r\n                visitedByAgent1.add(key1);\r\n                // Check if Agent 2 already visited this node\r\n                if (visitedByAgent2.has(key1)) {\r\n                  element1.classList.remove(\"node-visited-second\");\r\n                  element1.classList.add(\"node-visited-overlap\");\r\n                } else {\r\n                  element1.classList.add(\"node-visited\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Agent 2 animation\r\n          if (i < visited2.length) {\r\n            const node2 = visited2[i];\r\n            if (!node2.isStart && !node2.isFinish) {\r\n              const key2 = `${node2.row}-${node2.col}`;\r\n              const element2 = document.getElementById(\r\n                `node-${node2.row}-${node2.col}`\r\n              );\r\n              if (element2) {\r\n                visitedByAgent2.add(key2);\r\n                // Check if Agent 1 already visited this node\r\n                if (visitedByAgent1.has(key2)) {\r\n                  element2.classList.remove(\"node-visited\");\r\n                  element2.classList.add(\"node-visited-overlap\");\r\n                } else {\r\n                  element2.classList.add(\"node-visited-second\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // After last visited node, animate paths\r\n          if (i === maxVisitedLen - 1) {\r\n            const pathDelay = setTimeout(() => {\r\n              // Create a Set for path1 nodes for O(1) lookup (to detect overlaps)\r\n              const path1Keys = new Set<string>();\r\n              for (const node of path1) {\r\n                path1Keys.add(`${node.row}-${node.col}`);\r\n              }\r\n\r\n              // Create a Set for path2 nodes for O(1) lookup\r\n              const path2Keys = new Set<string>();\r\n              for (const node of path2) {\r\n                path2Keys.add(`${node.row}-${node.col}`);\r\n              }\r\n\r\n              // SIMPLIFIED: Path animation uses simple CSS classes\r\n              // Complex SVG overlay will be added in a future component\r\n              const maxPathLen = Math.max(path1.length, path2.length);\r\n\r\n              for (let j = 0; j < maxPathLen; j++) {\r\n                const pathTimeoutId = setTimeout(() => {\r\n                  // Path 1 animation (Agent 1 - Yellow)\r\n                  if (j < path1.length) {\r\n                    const pathNode1 = path1[j];\r\n                    if (!pathNode1.isStart && !pathNode1.isFinish) {\r\n                      const key1 = `${pathNode1.row}-${pathNode1.col}`;\r\n                      const element = document.getElementById(\r\n                        `node-${pathNode1.row}-${pathNode1.col}`\r\n                      );\r\n                      if (element) {\r\n                        element.classList.remove(\r\n                          \"node-visited\",\r\n                          \"node-visited-second\",\r\n                          \"node-visited-overlap\"\r\n                        );\r\n                        // Check if this node is also in path2 (overlap)\r\n                        if (path2Keys.has(key1)) {\r\n                          // Simple overlap class (lime green for now)\r\n                          element.classList.add(\"node-path-overlap\");\r\n                        } else {\r\n                          element.classList.add(\"node-path\");\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  // Path 2 animation (Agent 2 - Cyan)\r\n                  if (j < path2.length) {\r\n                    const pathNode2 = path2[j];\r\n                    if (!pathNode2.isStart && !pathNode2.isFinish) {\r\n                      const key2 = `${pathNode2.row}-${pathNode2.col}`;\r\n                      const element = document.getElementById(\r\n                        `node-${pathNode2.row}-${pathNode2.col}`\r\n                      );\r\n                      if (element) {\r\n                        element.classList.remove(\r\n                          \"node-visited\",\r\n                          \"node-visited-second\",\r\n                          \"node-visited-overlap\",\r\n                          \"node-path\"\r\n                        );\r\n                        // Check if this node is also in path1 (overlap)\r\n                        if (path1Keys.has(key2)) {\r\n                          // Simple overlap class (lime green for now)\r\n                          element.classList.add(\"node-path-overlap\");\r\n                        } else {\r\n                          element.classList.add(\"node-path-second\");\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  // After both paths complete\r\n                  if (j === maxPathLen - 1) {\r\n                    isAnimating.current = false;\r\n                    setIsVisualizing(false);\r\n\r\n                    // Update stats and scroll to statistics section\r\n                    if (statsCallbacks) {\r\n                      statsCallbacks.setVisualizationStats(raceStats);\r\n                      // Add to run history\r\n                      if (\r\n                        statsCallbacks.addRunRecord &&\r\n                        statsCallbacks.gridSize\r\n                      ) {\r\n                        const winnerName =\r\n                          raceStats.winner === \"agent1\"\r\n                            ? raceStats.agent1.algorithm\r\n                            : raceStats.winner === \"agent2\"\r\n                            ? raceStats.agent2.algorithm\r\n                            : raceStats.winner === \"tie\"\r\n                            ? \"Tie\"\r\n                            : \"Both Failed\";\r\n                        statsCallbacks.addRunRecord({\r\n                          mode: \"Race\",\r\n                          algorithm1: raceStats.agent1.algorithm,\r\n                          algorithm2: raceStats.agent2.algorithm,\r\n                          gridSize: statsCallbacks.gridSize,\r\n                          time1: raceStats.agent1.executionTime,\r\n                          pathLength1: raceStats.agent1.pathLength,\r\n                          visitedCount1: raceStats.agent1.visitedCount,\r\n                          time2: raceStats.agent2.executionTime,\r\n                          pathLength2: raceStats.agent2.pathLength,\r\n                          visitedCount2: raceStats.agent2.visitedCount,\r\n                          winner: winnerName,\r\n                        });\r\n                      }\r\n                      setTimeout(() => {\r\n                        statsCallbacks.scrollToStats();\r\n                      }, 500);\r\n                    }\r\n                  }\r\n                }, j * (speed * 3));\r\n\r\n                timeoutIds.current.push(pathTimeoutId);\r\n              }\r\n\r\n              // Handle case where both paths are empty\r\n              if (maxPathLen === 0) {\r\n                isAnimating.current = false;\r\n                setIsVisualizing(false);\r\n\r\n                // Update stats and scroll even if no paths found\r\n                if (statsCallbacks) {\r\n                  statsCallbacks.setVisualizationStats(raceStats);\r\n                  // Add to run history\r\n                  if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n                    const winnerName =\r\n                      raceStats.winner === \"agent1\"\r\n                        ? raceStats.agent1.algorithm\r\n                        : raceStats.winner === \"agent2\"\r\n                        ? raceStats.agent2.algorithm\r\n                        : raceStats.winner === \"tie\"\r\n                        ? \"Tie\"\r\n                        : \"Both Failed\";\r\n                    statsCallbacks.addRunRecord({\r\n                      mode: \"Race\",\r\n                      algorithm1: raceStats.agent1.algorithm,\r\n                      algorithm2: raceStats.agent2.algorithm,\r\n                      gridSize: statsCallbacks.gridSize,\r\n                      time1: raceStats.agent1.executionTime,\r\n                      pathLength1: raceStats.agent1.pathLength,\r\n                      visitedCount1: raceStats.agent1.visitedCount,\r\n                      time2: raceStats.agent2.executionTime,\r\n                      pathLength2: raceStats.agent2.pathLength,\r\n                      visitedCount2: raceStats.agent2.visitedCount,\r\n                      winner: winnerName,\r\n                    });\r\n                  }\r\n                  // Show toast if neither algorithm found a path\r\n                  if (!path1Found && !path2Found && statsCallbacks.showToast) {\r\n                    statsCallbacks.showToast(\r\n                      \"Target is unreachable! Neither algorithm found a path.\"\r\n                    );\r\n                  }\r\n                  setTimeout(() => {\r\n                    statsCallbacks.scrollToStats();\r\n                  }, 500);\r\n                }\r\n              }\r\n            }, 50);\r\n\r\n            timeoutIds.current.push(pathDelay);\r\n          }\r\n        }, i * speed);\r\n\r\n        timeoutIds.current.push(timeoutId);\r\n      }\r\n\r\n      // Handle case where both visited arrays are empty\r\n      if (maxVisitedLen === 0) {\r\n        isAnimating.current = false;\r\n        setIsVisualizing(false);\r\n\r\n        // Update stats and scroll even if nothing was visited\r\n        if (statsCallbacks) {\r\n          statsCallbacks.setVisualizationStats(raceStats);\r\n          // Add to run history\r\n          if (statsCallbacks.addRunRecord && statsCallbacks.gridSize) {\r\n            const winnerName =\r\n              raceStats.winner === \"agent1\"\r\n                ? raceStats.agent1.algorithm\r\n                : raceStats.winner === \"agent2\"\r\n                ? raceStats.agent2.algorithm\r\n                : raceStats.winner === \"tie\"\r\n                ? \"Tie\"\r\n                : \"Both Failed\";\r\n            statsCallbacks.addRunRecord({\r\n              mode: \"Race\",\r\n              algorithm1: raceStats.agent1.algorithm,\r\n              algorithm2: raceStats.agent2.algorithm,\r\n              gridSize: statsCallbacks.gridSize,\r\n              time1: raceStats.agent1.executionTime,\r\n              pathLength1: raceStats.agent1.pathLength,\r\n              visitedCount1: raceStats.agent1.visitedCount,\r\n              time2: raceStats.agent2.executionTime,\r\n              pathLength2: raceStats.agent2.pathLength,\r\n              visitedCount2: raceStats.agent2.visitedCount,\r\n              winner: winnerName,\r\n            });\r\n          }\r\n          setTimeout(() => {\r\n            statsCallbacks.scrollToStats();\r\n          }, 500);\r\n        }\r\n      }\r\n    },\r\n    [\r\n      clearAllTimeouts,\r\n      clearVisualizationClasses,\r\n      runAlgorithm,\r\n      runBenchmark,\r\n      BENCHMARK_MIN_DURATION,\r\n    ]\r\n  );\r\n\r\n  return {\r\n    visualizePathfinding,\r\n    visualizeRace,\r\n    generateMaze,\r\n    clearVisualization,\r\n    isAnimating,\r\n  };\r\n};\r\n\r\nexport default useVisualization;\r\n","import React, {\r\n  useRef,\r\n  useCallback,\r\n  useState,\r\n  lazy,\r\n  Suspense,\r\n  useEffect,\r\n} from \"react\";\r\nimport { GridProvider, useGridContext } from \"./context/GridContext\";\r\nimport Board from \"./components/Board\";\r\nimport { ControlPanel } from \"./components/Controls\";\r\nimport { Legend } from \"./components/Legend\";\r\nimport Toast from \"./components/UI/Toast\";\r\nimport { useVisualization } from \"./hooks/useVisualization\";\r\nimport { MazeType } from \"./types\";\r\nimport styles from \"./App.module.css\";\r\n\r\n// Lazy load the Statistics and History sections to reduce initial bundle size\r\n// These components are below the fold and not needed for initial render\r\nconst StatisticsSection = lazy(\r\n  () => import(\"./components/Statistics/StatisticsSection\")\r\n);\r\nconst HistorySection = lazy(\r\n  () => import(\"./components/History/HistorySection\")\r\n);\r\n\r\n/**\r\n * MainContent Component - Two-Page Scroll Layout\r\n * Section 1: Visualizer (Board + Controls)\r\n * Section 2: Statistics Dashboard\r\n */\r\nconst MainContent: React.FC = () => {\r\n  const {\r\n    grid,\r\n    setGrid,\r\n    setIsVisualizing,\r\n    animationSpeed,\r\n    selectedAlgorithm,\r\n    secondAlgorithm,\r\n    isRaceMode,\r\n    clearAllWalls,\r\n    visualizationStats,\r\n    setVisualizationStats,\r\n    showToast,\r\n    selectedMaze,\r\n    runHistory,\r\n    clearRunHistory,\r\n    deleteRunRecord,\r\n    addRunRecord,\r\n    rowCount,\r\n    colCount,\r\n  } = useGridContext();\r\n\r\n  const {\r\n    visualizePathfinding,\r\n    visualizeRace,\r\n    generateMaze,\r\n    clearVisualization,\r\n  } = useVisualization();\r\n\r\n  // Ref for the stats section to enable programmatic scrolling\r\n  const statsSectionRef = useRef<HTMLDivElement>(null);\r\n\r\n  // Mobile sidebar state\r\n  const [isSidebarOpen, setIsSidebarOpen] = useState(false);\r\n\r\n  // Track if initial maze has been generated\r\n  const [hasGeneratedInitialMaze, setHasGeneratedInitialMaze] = useState(false);\r\n\r\n  // Auto-generate maze on mount for better first paint experience\r\n  useEffect(() => {\r\n    if (hasGeneratedInitialMaze) return;\r\n\r\n    // Small delay to ensure DOM is fully ready and grid is mounted\r\n    const timer = setTimeout(() => {\r\n      generateMaze(\r\n        selectedMaze,\r\n        grid,\r\n        setGrid,\r\n        setIsVisualizing,\r\n        Math.max(15, animationSpeed / 2)\r\n      );\r\n      setHasGeneratedInitialMaze(true);\r\n    }, 300);\r\n\r\n    return () => clearTimeout(timer);\r\n  }, [hasGeneratedInitialMaze]); // Only depend on the flag to run once\r\n\r\n  // Toggle mobile sidebar\r\n  const toggleSidebar = useCallback(() => {\r\n    setIsSidebarOpen((prev) => !prev);\r\n  }, []);\r\n\r\n  // Close sidebar (for overlay click)\r\n  const closeSidebar = useCallback(() => {\r\n    setIsSidebarOpen(false);\r\n  }, []);\r\n\r\n  // Scroll to stats section\r\n  const scrollToStats = useCallback(() => {\r\n    statsSectionRef.current?.scrollIntoView({ behavior: \"smooth\" });\r\n  }, []);\r\n\r\n  // Stats callbacks for visualization hooks\r\n  const statsCallbacks = {\r\n    setVisualizationStats,\r\n    scrollToStats,\r\n    showToast,\r\n    addRunRecord,\r\n    gridSize: `${rowCount}x${colCount}`,\r\n  };\r\n\r\n  // Handler for visualize button (single algorithm)\r\n  const handleVisualize = (): void => {\r\n    visualizePathfinding(\r\n      selectedAlgorithm,\r\n      grid,\r\n      setGrid,\r\n      setIsVisualizing,\r\n      animationSpeed,\r\n      statsCallbacks\r\n    );\r\n  };\r\n\r\n  // Handler for race mode visualization (two algorithms)\r\n  const handleVisualizeRace = (): void => {\r\n    if (secondAlgorithm) {\r\n      visualizeRace(\r\n        selectedAlgorithm,\r\n        secondAlgorithm,\r\n        grid,\r\n        setGrid,\r\n        setIsVisualizing,\r\n        animationSpeed,\r\n        statsCallbacks\r\n      );\r\n    }\r\n  };\r\n\r\n  // Handler for clear path button\r\n  const handleClearPath = (): void => {\r\n    clearVisualization(grid, setGrid);\r\n  };\r\n\r\n  // Handler for generate maze button\r\n  const handleGenerateMaze = (\r\n    mazeType: MazeType,\r\n    terrainConfig?: { frequency: number; intensity?: number }\r\n  ): void => {\r\n    handleClearPath();\r\n    clearAllWalls();\r\n\r\n    requestAnimationFrame(() => {\r\n      setTimeout(() => {\r\n        generateMaze(\r\n          mazeType,\r\n          grid,\r\n          setGrid,\r\n          setIsVisualizing,\r\n          Math.max(15, animationSpeed / 2),\r\n          terrainConfig\r\n        );\r\n      }, 50);\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div className={styles.snapContainer}>\r\n      {/* Section 1: Visualizer */}\r\n      <div className={`${styles.snapSection} ${styles.visualizerSection}`}>\r\n        {/* Mobile Menu Toggle Button */}\r\n        <button\r\n          className={styles.mobileMenuToggle}\r\n          onClick={toggleSidebar}\r\n          aria-label={isSidebarOpen ? \"Close menu\" : \"Open menu\"}\r\n          aria-expanded={isSidebarOpen}\r\n        >\r\n          <span className={styles.hamburgerIcon}>\r\n            {isSidebarOpen ? \"\" : \"\"}\r\n          </span>\r\n        </button>\r\n\r\n        {/* Mobile Overlay */}\r\n        {isSidebarOpen && (\r\n          <div\r\n            className={styles.sidebarOverlay}\r\n            onClick={closeSidebar}\r\n            aria-hidden=\"true\"\r\n          />\r\n        )}\r\n\r\n        {/* Control Panel Sidebar - Fixed width, full height */}\r\n        <aside\r\n          className={`${styles.controlPanelSidebar} ${\r\n            isSidebarOpen ? styles.sidebarOpen : \"\"\r\n          }`}\r\n        >\r\n          <ControlPanel\r\n            onVisualize={handleVisualize}\r\n            onClearPath={handleClearPath}\r\n            onGenerateMaze={handleGenerateMaze}\r\n            onVisualizeRace={handleVisualizeRace}\r\n            onMobileAction={closeSidebar}\r\n          />\r\n        </aside>\r\n\r\n        {/* Game Area - Takes remaining space */}\r\n        <div className={styles.gameArea}>\r\n          {/* Header - Fixed height */}\r\n          <header className={styles.header}>\r\n            <h1 className={styles.title}>Maze & Pathfinding Visualizer</h1>\r\n            <p className={styles.subtitle}>\r\n              Visualize pathfinding algorithms on an interactive grid\r\n            </p>\r\n          </header>\r\n\r\n          {/* Board Container - Takes all remaining vertical space */}\r\n          <div className={styles.boardContainer}>\r\n            <Board />\r\n          </div>\r\n\r\n          {/* Legend - Fixed height */}\r\n          <div className={styles.legendArea}>\r\n            <Legend orientation=\"horizontal\" compact />\r\n          </div>\r\n\r\n          {/* Scroll Indicator - Fixed height */}\r\n          <footer className={styles.footer}>\r\n            <div className={styles.scrollIndicator} onClick={scrollToStats}>\r\n              <span>View Statistics</span>\r\n              <span></span>\r\n            </div>\r\n          </footer>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Section 2: Statistics */}\r\n      <div className={styles.snapSection} ref={statsSectionRef}>\r\n        <Suspense\r\n          fallback={\r\n            <div className={styles.statsLoading}>Loading Statistics...</div>\r\n          }\r\n        >\r\n          <StatisticsSection\r\n            stats={visualizationStats}\r\n            isRaceMode={isRaceMode}\r\n          />\r\n        </Suspense>\r\n      </div>\r\n\r\n      {/* Section 3: Run History */}\r\n      <div className={styles.snapSection}>\r\n        <Suspense\r\n          fallback={\r\n            <div className={styles.statsLoading}>Loading History...</div>\r\n          }\r\n        >\r\n          <HistorySection\r\n            history={runHistory}\r\n            onClearHistory={clearRunHistory}\r\n            onDeleteRecord={deleteRunRecord}\r\n          />\r\n        </Suspense>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n/**\r\n * Main Application Component\r\n * Wraps the entire app with GridProvider for global state management.\r\n */\r\nconst App: React.FC = () => {\r\n  return (\r\n    <GridProvider>\r\n      <MainContent />\r\n      <Toast />\r\n    </GridProvider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom/client\";\r\nimport App from \"./App\";\r\nimport \"./styles/variables.css\";\r\n\r\n/**\r\n * Application Entry Point\r\n *\r\n * Renders the root App component into the DOM\r\n */\r\nReactDOM.createRoot(document.getElementById(\"root\")!).render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>\r\n);\r\n"],"file":"assets/index-BasIM3y1.js"}