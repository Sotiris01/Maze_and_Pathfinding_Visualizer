(function(){"use strict";var C=(s=>(s.DIJKSTRA="dijkstra",s.ASTAR="astar",s.BFS="bfs",s.DFS="dfs",s.GREEDY_BEST_FIRST="greedyBestFirst",s.BIDIRECTIONAL_BFS="bidirectionalBFS",s.BIDIRECTIONAL_ASTAR="bidirectionalAStar",s.JUMP_POINT_SEARCH="jumpPointSearch",s))(C||{});function A(s,t,e){const n=[];t.distance=0;const o=L(s);for(;o.length>0;){J(o);const r=o.shift();if(!r.isWall){if(r.distance===1/0||(r.isVisited=!0,n.push(r),r===e))return n;N(r,s)}}return n}function L(s){const t=[];for(const e of s)for(const n of e)t.push(n);return t}function J(s){s.sort((t,e)=>t.distance-e.distance)}function N(s,t){const e=q(s,t);for(const n of e)n.distance=s.distance+1,n.previousNode=s}function q(s,t){const e=[],{row:n,col:o}=s,r=t.length,u=t[0].length;return n>0&&e.push(t[n-1][o]),n<r-1&&e.push(t[n+1][o]),o>0&&e.push(t[n][o-1]),o<u-1&&e.push(t[n][o+1]),e.filter(c=>!c.isVisited)}function _(s,t){return Math.abs(s.row-t.row)+Math.abs(s.col-t.col)}function x(s,t,e){const n=[],o=new Map,r=new Map,u=new Map,c=w=>`${w.row}-${w.col}`;for(const w of s)for(const b of w){const I=c(b);o.set(I,1/0),r.set(I,1/0)}const m=c(t);o.set(m,0),r.set(m,_(t,e));const h=[t];for(u.set(m,!0);h.length>0;){h.sort((v,k)=>{const f=r.get(c(v))??1/0,g=r.get(c(k))??1/0;return f-g});const w=h.shift(),b=c(w);if(u.set(b,!1),w.isWall||w.isVisited)continue;const I=o.get(b)??1/0;if(I===1/0||(w.isVisited=!0,n.push(w),w===e))return n;const M=H(w,s);for(const v of M){if(v.isWall||v.isVisited)continue;const k=c(v),f=I+1,g=o.get(k)??1/0;f<g&&(v.previousNode=w,o.set(k,f),r.set(k,f+_(v,e)),u.get(k)||(h.push(v),u.set(k,!0)))}}return n}function H(s,t){const e=[],{row:n,col:o}=s,r=t.length,u=t[0].length;return n>0&&e.push(t[n-1][o]),n<r-1&&e.push(t[n+1][o]),o>0&&e.push(t[n][o-1]),o<u-1&&e.push(t[n][o+1]),e}function Q(s,t,e){const n=[],o=[];for(t.isVisited=!0,t.distance=0,o.push(t),n.push(t);o.length>0;){const r=o.shift();if(r.isWall)continue;if(r===e)return n;const u=Y(r,s);for(const c of u)if(!c.isWall&&(c.isVisited=!0,c.previousNode=r,c.distance=r.distance+1,o.push(c),n.push(c),c===e))return n}return n}function Y(s,t){const e=[],{row:n,col:o}=s,r=t.length,u=t[0].length;return n>0&&e.push(t[n-1][o]),n<r-1&&e.push(t[n+1][o]),o>0&&e.push(t[n][o-1]),o<u-1&&e.push(t[n][o+1]),e.filter(c=>!c.isVisited)}function z(s,t,e){const n=[],o=[];for(o.push(t);o.length>0;){const r=o.pop();if(r.isWall||r.isVisited)continue;if(r.isVisited=!0,n.push(r),r===e)return n;const u=X(r,s);for(const c of u)c.isWall||c.isVisited||(c.previousNode=r,o.push(c))}return n}function X(s,t){const e=[],{row:n,col:o}=s,r=t.length,u=t[0].length;return o>0&&e.push(t[n][o-1]),n<r-1&&e.push(t[n+1][o]),o<u-1&&e.push(t[n][o+1]),n>0&&e.push(t[n-1][o]),e.filter(c=>!c.isVisited)}function D(s,t){return Math.abs(s.row-t.row)+Math.abs(s.col-t.col)}function Z(s,t,e){const n=[],o=new Map,r=new Map,u=h=>`${h.row}-${h.col}`;for(const h of s)for(const w of h){const b=u(w);o.set(b,1/0)}const c=u(t);o.set(c,D(t,e));const m=[t];for(r.set(c,!0);m.length>0;){m.sort((I,M)=>{const v=o.get(u(I))??1/0,k=o.get(u(M))??1/0;return v-k});const h=m.shift(),w=u(h);if(r.set(w,!1),h.isWall||h.isVisited)continue;if(h.isVisited=!0,n.push(h),h===e)return n;const b=tt(h,s);for(const I of b){if(I.isWall||I.isVisited)continue;const M=u(I);r.get(M)||(I.previousNode=h,o.set(M,D(I,e)),m.push(I),r.set(M,!0))}}return n}function tt(s,t){const e=[],{row:n,col:o}=s,r=t.length,u=t[0].length;return n>0&&e.push(t[n-1][o]),n<r-1&&e.push(t[n+1][o]),o>0&&e.push(t[n][o-1]),o<u-1&&e.push(t[n][o+1]),e}let $=[];function nt(s,t,e){const n=[],o=s.length,r=s[0].length;$=[];const u=new Map,c=new Map,m=new Set,h=new Set,w=p=>`${p.row}-${p.col}`,b=p=>{const[l,i]=p.split("-").map(Number);return s[l][i]},I=[t],M=[e],v=w(t);m.add(v),u.set(v,null),t.isVisited=!0,n.push(t);const k=w(e);h.add(k),c.set(k,null);let f=null;const g=p=>{const l=[],{row:i,col:a}=p;return i>0&&l.push(s[i-1][a]),i<o-1&&l.push(s[i+1][a]),a>0&&l.push(s[i][a-1]),a<r-1&&l.push(s[i][a+1]),l.filter(d=>!d.isWall)};for(;I.length>0&&M.length>0;){if(I.length>0){const p=I.shift();for(const l of g(p)){const i=w(l);if(!m.has(i)){if(m.add(i),u.set(i,p),l.isVisited=!0,n.push(l),h.has(i)){f=i;break}I.push(l)}}if(f)break}if(M.length>0&&!f){const p=M.shift();p===e&&(e.isVisited=!0,n.push(e));for(const l of g(p)){const i=w(l);if(!h.has(i)){if(h.add(i),c.set(i,p),l.isVisited=!0,n.push(l),m.has(i)){f=i;break}M.push(l)}}if(f)break}}if(f){const p=[];let l=f;for(;l!==null;){p.unshift(b(l));const d=u.get(l);l=d?w(d):null}const i=[],a=c.get(f);for(l=a?w(a):null;l!==null;){i.push(b(l));const d=c.get(l);l=d?w(d):null}$=[...p,...i];for(let d=1;d<$.length;d++)$[d].previousNode=$[d-1];e.isVisited=!0}return n}let P=[];function G(s,t){return Math.abs(s.row-t.row)+Math.abs(s.col-t.col)}function et(s,t,e){const n=[],o=s.length,r=s[0].length;P=[];const u=K=>`${K.row}-${K.col}`,c=K=>{const[y,F]=K.split("-").map(Number);return s[y][F]},m=new Map,h=new Map,w=new Map,b=new Set,I=new Map,M=[],v=new Map,k=new Map,f=new Map,g=new Set,p=new Map,l=[];for(const K of s)for(const y of K){const F=u(y);m.set(F,1/0),h.set(F,1/0),v.set(F,1/0),k.set(F,1/0)}const i=u(t);m.set(i,0),h.set(i,G(t,e)),w.set(i,null),M.push(t),I.set(i,!0),b.add(i),t.isVisited=!0,n.push(t);const a=u(e);v.set(a,0),k.set(a,G(e,t)),f.set(a,null),l.push(e),p.set(a,!0),g.add(a);let d=null,R=1/0;const O=K=>{const y=[],{row:F,col:S}=K;return F>0&&y.push(s[F-1][S]),F<o-1&&y.push(s[F+1][S]),S>0&&y.push(s[F][S-1]),S<r-1&&y.push(s[F][S+1]),y.filter(V=>!V.isWall)},T=(K,y)=>(K.sort((F,S)=>{const V=y.get(u(F))??1/0,W=y.get(u(S))??1/0;return V-W}),K.shift());for(;M.length>0&&l.length>0;){if(M.length>0){const K=T(M,h);if(!K)break;const y=u(K);if(I.set(y,!1),K.isWall)continue;if(g.has(y)){const F=(m.get(y)??1/0)+(v.get(y)??1/0);F<R&&(R=F,d=y)}for(const F of O(K)){const S=u(F);if(b.has(S)&&!I.get(S))continue;const V=(m.get(y)??1/0)+1,W=m.get(S)??1/0;if(V<W&&(w.set(S,K),m.set(S,V),h.set(S,V+G(F,e)),I.get(S)||(M.push(F),I.set(S,!0)),!b.has(S)&&(b.add(S),F.isVisited=!0,n.push(F),g.has(S)))){const E=V+(v.get(S)??1/0);E<R&&(R=E,d=S)}}}if(l.length>0){const K=T(l,k);if(!K)break;const y=u(K);if(p.set(y,!1),K.isWall)continue;if(K===e&&!n.includes(e)&&(e.isVisited=!0,n.push(e)),b.has(y)){const F=(m.get(y)??1/0)+(v.get(y)??1/0);F<R&&(R=F,d=y)}for(const F of O(K)){const S=u(F);if(g.has(S)&&!p.get(S))continue;const V=(v.get(y)??1/0)+1,W=v.get(S)??1/0;if(V<W&&(f.set(S,K),v.set(S,V),k.set(S,V+G(F,t)),p.get(S)||(l.push(F),p.set(S,!0)),!g.has(S)&&(g.add(S),F.isVisited=!0,n.push(F),b.has(S)))){const E=(m.get(S)??1/0)+V;E<R&&(R=E,d=S)}}}if(d!==null&&M.length>0&&l.length>0){const K=h.get(u(M[0]))??1/0,y=k.get(u(l[0]))??1/0;if(K+y>=R)break}}if(d!==null){const K=[];let y=d;for(;y!==null;){K.unshift(c(y));const V=w.get(y);y=V?u(V):null}const F=[],S=f.get(d);for(y=S?u(S):null;y!==null;){F.push(c(y));const V=f.get(y);y=V?u(V):null}P=[...K,...F];for(let V=1;V<P.length;V++)P[V].previousNode=P[V-1];e.isVisited=!0}return n}function B(s,t){return Math.abs(s.row-t.row)+Math.abs(s.col-t.col)}const st=[[-1,0],[1,0],[0,-1],[0,1]];function ot(s,t,e){const n=[],o=s.length,r=s[0].length,u=(f,g)=>`${f}-${g}`,c=(f,g)=>f<0||f>=o||g<0||g>=r?!1:!s[f][g].isWall,m=new Map,h=new Map,w=new Map,b=new Map;for(const f of s)for(const g of f){const p=u(g.row,g.col);m.set(p,1/0),h.set(p,1/0)}const I=u(t.row,t.col);m.set(I,0),h.set(I,B(t,e)),w.set(I,null);const M=[];M.push({row:t.row,col:t.col,dirRow:0,dirCol:0}),b.set(I,!0);const v=(f,g,p,l)=>{const i=f+p,a=g+l;return c(i,a)?i===e.row&&a===e.col?{row:i,col:a}:p===0&&(!c(i-1,a-l)&&c(i-1,a)||!c(i+1,a-l)&&c(i+1,a))?{row:i,col:a}:l===0&&(!c(i-p,a-1)&&c(i,a-1)||!c(i-p,a+1)&&c(i,a+1))?{row:i,col:a}:v(i,a,p,l):null},k=(f,g,p,l)=>{const i=[];let a;p===0&&l===0?a=st:p===0?(a=[[0,l]],!c(f-1,g-l)&&c(f-1,g)&&a.push([-1,0]),!c(f+1,g-l)&&c(f+1,g)&&a.push([1,0])):(a=[[p,0]],!c(f-p,g-1)&&c(f,g-1)&&a.push([0,-1]),!c(f-p,g+1)&&c(f,g+1)&&a.push([0,1]));for(const[d,R]of a){const O=v(f,g,d,R);O&&i.push(O)}return i};for(;M.length>0;){M.sort((i,a)=>{const d=h.get(u(i.row,i.col))??1/0,R=h.get(u(a.row,a.col))??1/0;return d-R});const f=M.shift(),g=u(f.row,f.col),p=s[f.row][f.col];if(b.set(g,!1),p.isVisited)continue;if(p.isVisited=!0,n.push(p),f.row===e.row&&f.col===e.col)return it(s,w,t,e),n;const l=k(f.row,f.col,f.dirRow,f.dirCol);for(const i of l){const a=u(i.row,i.col),d=s[i.row][i.col];if(d.isVisited)continue;const R=(m.get(g)??1/0)+B(p,d);if(R<(m.get(a)??1/0)){w.set(a,g),m.set(a,R),h.set(a,R+B(d,e));const O=i.row===f.row?0:i.row>f.row?1:-1,T=i.col===f.col?0:i.col>f.col?1:-1;b.get(a)||(M.push({row:i.row,col:i.col,dirRow:O,dirCol:T}),b.set(a,!0))}}}return n}function it(s,t,e,n){const o=[];let r=`${n.row}-${n.col}`;const u=[];for(;r!==null;){const[c,m]=r.split("-").map(Number);u.unshift(s[c][m]),r=t.get(r)??null}for(let c=0;c<u.length-1;c++){const m=u[c],h=u[c+1];let w=m.row,b=m.col;for(;w!==h.row||b!==h.col;){const I=s[w][b];o.length>0&&(I.previousNode=o[o.length-1]),o.push(I),w<h.row?w++:w>h.row?w--:b<h.col?b++:b>h.col&&b--}}u.length>0&&(n.previousNode=o.length>0?o[o.length-1]:null,o.push(n))}function ct(s){return s.map(t=>t.map(e=>({row:e.row,col:e.col,isStart:e.isStart,isFinish:e.isFinish,isWall:e.isWall,isVisited:!1,distance:1/0,previousNode:null})))}function j(s){const t=s.map(o=>o.map(r=>({...r,isVisited:!1,distance:1/0,previousNode:null})));let e=null,n=null;for(const o of t)for(const r of o)r.isStart&&(e=r),r.isFinish&&(n=r);if(!e||!n)throw new Error("Start or Finish node not found in grid");return{clonedGrid:t,start:e,finish:n}}function U(s,t,e,n){switch(s){case C.DIJKSTRA:A(t,e,n);break;case C.ASTAR:x(t,e,n);break;case C.BFS:Q(t,e,n);break;case C.DFS:z(t,e,n);break;case C.GREEDY_BEST_FIRST:Z(t,e,n);break;case C.BIDIRECTIONAL_BFS:nt(t,e,n);break;case C.BIDIRECTIONAL_ASTAR:et(t,e,n);break;case C.JUMP_POINT_SEARCH:ot(t,e,n);break;default:A(t,e,n)}}self.onmessage=s=>{var c,m,h,w;const{requestId:t,algorithmName:e,gridData:n,startPos:o,finishPos:r,minDuration:u}=s.data;try{const b=ct(n);if(!((m=(c=b[o.row])==null?void 0:c[o.col])!=null&&m.isStart)||!((w=(h=b[r.row])==null?void 0:h[r.col])!=null&&w.isFinish))throw new Error("Invalid start/finish positions");for(let l=0;l<3;l++){const{clonedGrid:i,start:a,finish:d}=j(b);U(e,i,a,d)}let I=0;const M=performance.now();let v=0;for(;v<u;){const{clonedGrid:l,start:i,finish:a}=j(b);U(e,l,i,a),I++,v=performance.now()-M}const k=v,f=k/I,g=1e3/f,p={avgTime:f,iterations:I,opsPerSec:g,totalTime:k};self.postMessage({success:!0,data:p,requestId:t})}catch(b){self.postMessage({success:!1,error:b instanceof Error?b.message:"Unknown error",requestId:t})}}})();
//# sourceMappingURL=benchmark.worker-CwKMJ_BO.js.map
