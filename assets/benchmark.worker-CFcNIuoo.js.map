{"version":3,"file":"benchmark.worker-CFcNIuoo.js","sources":["../src/types/index.ts","../src/algorithms/pathfinding/dijkstra.ts","../src/algorithms/pathfinding/astar.ts","../src/algorithms/pathfinding/bfs.ts","../src/algorithms/pathfinding/dfs.ts","../src/algorithms/pathfinding/greedyBestFirst.ts","../src/algorithms/pathfinding/bidirectionalBFS.ts","../src/algorithms/pathfinding/bidirectionalAStar.ts","../src/algorithms/pathfinding/jumpPointSearch.ts","../src/workers/benchmark.worker.ts"],"sourcesContent":["/**\r\n * Node Interface - Core data model for each cell in the grid\r\n * As specified in Section 3.1 of the project requirements\r\n */\r\nexport interface Node {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n  isVisited: boolean;\r\n  distance: number; // For Dijkstra/A* - initialized to Infinity\r\n  previousNode: Node | null; // For backtracking the shortest path\r\n  weight: number; // Terrain weight: 1 = normal, higher = heavier terrain (e.g., 5, 10)\r\n}\r\n\r\n/**\r\n * Draw Mode - Determines what the user is painting on the grid\r\n */\r\nexport type DrawMode = \"WALL\" | \"WEIGHT\";\r\n\r\n/**\r\n * Grid Type - 2D array of Nodes\r\n */\r\nexport type Grid = Node[][];\r\n\r\n/**\r\n * Algorithm Types\r\n */\r\nexport enum AlgorithmType {\r\n  DIJKSTRA = \"dijkstra\",\r\n  ASTAR = \"astar\",\r\n  BFS = \"bfs\",\r\n  DFS = \"dfs\",\r\n  GREEDY_BEST_FIRST = \"greedyBestFirst\",\r\n  BIDIRECTIONAL_BFS = \"bidirectionalBFS\",\r\n  BIDIRECTIONAL_ASTAR = \"bidirectionalAStar\",\r\n  JUMP_POINT_SEARCH = \"jumpPointSearch\",\r\n}\r\n\r\n/**\r\n * Maze Generation Types\r\n */\r\nexport enum MazeType {\r\n  RECURSIVE_DIVISION = \"recursiveDivision\",\r\n  RANDOMIZED_DFS = \"randomizedDFS\",\r\n  PRIMS = \"prims\",\r\n  SPIRAL = \"spiral\",\r\n  CELLULAR_AUTOMATA = \"cellularAutomata\",\r\n  TERRAIN_MAP = \"terrainMap\",\r\n}\r\n\r\n/**\r\n * Terrain Generation Configuration\r\n * Used with TERRAIN_MAP maze type to control terrain smoothness\r\n */\r\nexport interface TerrainConfig {\r\n  /** Base frequency - lower = smoother terrain (default: 0.12) */\r\n  frequency: number;\r\n}\r\n\r\n/**\r\n * Node State for styling purposes\r\n */\r\nexport enum NodeState {\r\n  UNVISITED = \"unvisited\",\r\n  VISITED = \"visited\",\r\n  WALL = \"wall\",\r\n  START = \"start\",\r\n  FINISH = \"finish\",\r\n  PATH = \"path\",\r\n  WEIGHT_LIGHT = \"weight-light\",\r\n  WEIGHT_HEAVY = \"weight-heavy\",\r\n}\r\n\r\n/**\r\n * Algorithm Result - returned after algorithm execution\r\n */\r\nexport interface AlgorithmResult {\r\n  visitedNodesInOrder: Node[];\r\n  shortestPath: Node[];\r\n  executionTimeMs: number;\r\n  visitedCount: number;\r\n  pathLength: number;\r\n}\r\n\r\n/**\r\n * Run Record - stored in localStorage for history tracking\r\n */\r\nexport interface RunRecord {\r\n  id: string; // UUID\r\n  timestamp: number; // Unix timestamp for sorting\r\n  date: string; // ISO format for display\r\n  mode: \"Single\" | \"Race\";\r\n  algorithm1: string; // Display name of algorithm 1\r\n  algorithm2?: string; // Display name of algorithm 2 (Race mode only)\r\n  gridSize: string; // e.g., \"20x30\"\r\n  // Algorithm 1 stats\r\n  time1: number; // Execution time in ms\r\n  pathLength1: number;\r\n  visitedCount1: number;\r\n  // Algorithm 2 stats (Race mode only)\r\n  time2?: number;\r\n  pathLength2?: number;\r\n  visitedCount2?: number;\r\n  // Race mode result\r\n  winner?: string; // \"Algorithm 1 Name\" | \"Algorithm 2 Name\" | \"Tie\" | \"Both Failed\"\r\n}\r\n\r\n/**\r\n * Grid Configuration Constants\r\n */\r\nexport const GRID_ROWS = 20;\r\nexport const GRID_COLS = 30;\r\n// Default Start: Top-left corner (1,1) for nice padding from edge\r\nexport const DEFAULT_START_ROW = 1;\r\nexport const DEFAULT_START_COL = 1;\r\n// Default Finish: Center of the grid (calculated dynamically)\r\nexport const DEFAULT_FINISH_ROW = Math.floor(GRID_ROWS / 2);\r\nexport const DEFAULT_FINISH_COL = Math.floor(GRID_COLS / 2);\r\n","/**\r\n * Dijkstra's Algorithm Implementation\r\n * Phase B: Basic Pathfinding\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n * - decreaseKey: O(log n)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  private getKey(node: Node): string {\r\n    return `${node.row}-${node.col}`;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Update existing node (decrease key)\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (this.heap[idx].distance >= this.heap[parentIdx].distance) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.heap[leftIdx].distance < this.heap[smallest].distance\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.heap[rightIdx].distance < this.heap[smallest].distance\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Dijkstra's Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Performs Dijkstra's algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize start node distance to 0 (all others are Infinity)\r\n * 2. Insert start node into min-heap priority queue\r\n * 3. Loop while heap is not empty:\r\n *    - Extract node with minimum distance\r\n *    - If already visited → skip\r\n *    - If wall → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - If finish → done\r\n *    - Relax all unvisited neighbors (update distances if shorter)\r\n */\r\nexport function dijkstra(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const visited = new Set<string>();\r\n\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize start node distance\r\n  startNode.distance = 0;\r\n\r\n  // Min-heap priority queue\r\n  const minHeap = new MinHeap();\r\n  minHeap.insert(startNode);\r\n\r\n  while (!minHeap.isEmpty()) {\r\n    // Extract node with minimum distance\r\n    const closestNode = minHeap.extractMin()!;\r\n    const closestKey = getKey(closestNode);\r\n\r\n    // Skip if already visited\r\n    if (visited.has(closestKey)) {\r\n      continue;\r\n    }\r\n\r\n    // Skip walls - they are not traversable\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If closest node has Infinity distance, we're trapped\r\n    if (closestNode.distance === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    visited.add(closestKey);\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Relax all unvisited neighbors\r\n    const neighbors = getUnvisitedNeighbors(closestNode, grid, visited);\r\n    for (const neighbor of neighbors) {\r\n      // Use neighbor's weight as the traversal cost (1 = normal, higher = heavier terrain)\r\n      const newDistance = closestNode.distance + neighbor.weight;\r\n\r\n      // Standard Dijkstra relaxation: only update if shorter\r\n      if (newDistance < neighbor.distance) {\r\n        neighbor.distance = newDistance;\r\n        neighbor.previousNode = closestNode;\r\n        minHeap.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by dijkstra)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(\r\n  node: Node,\r\n  grid: Grid,\r\n  visited: Set<string>\r\n): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited, non-wall neighbors\r\n  return neighbors.filter((neighbor) => {\r\n    const key = `${neighbor.row}-${neighbor.col}`;\r\n    return !visited.has(key) && !neighbor.isWall;\r\n  });\r\n}\r\n","/**\r\n * A* (A-Star) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * A* is an informed search algorithm that uses a heuristic to guide\r\n * its search towards the goal, making it more efficient than Dijkstra\r\n * for pathfinding problems.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n *\r\n * Uses a binary min-heap priority queue for O(n log n) performance.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n * - decreaseKey (via re-insert): O(log n)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private getKey: (node: Node) => string;\r\n  private getPriority: (node: Node) => number;\r\n  private positionMap: Map<string, number> = new Map(); // Track node positions for O(1) contains check\r\n\r\n  constructor(\r\n    getKey: (node: Node) => string,\r\n    getPriority: (node: Node) => number\r\n  ) {\r\n    this.getKey = getKey;\r\n    this.getPriority = getPriority;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  contains(node: Node): boolean {\r\n    return this.positionMap.has(this.getKey(node));\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Node already exists - update its position (decrease key operation)\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      // New node\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | null {\r\n    if (this.heap.length === 0) return null;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (\r\n        this.getPriority(this.heap[idx]) >=\r\n        this.getPriority(this.heap[parentIdx])\r\n      ) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.getPriority(this.heap[leftIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.getPriority(this.heap[rightIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// A* Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement (up, down, left, right), the Manhattan distance\r\n * provides an admissible heuristic (never overestimates the actual cost).\r\n *\r\n * @param nodeA - First node\r\n * @param nodeB - Second node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize gScore (distance from start) and fScore (gScore + heuristic)\r\n * 2. Add startNode to Open Set (min-heap priority queue)\r\n * 3. Loop while Open Set is not empty:\r\n *    - Extract node with lowest fScore (O(log n))\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each neighbor:\r\n *      - Calculate tentative gScore\r\n *      - If tentative < neighbor's gScore:\r\n *        - Update neighbor's previousNode, gScore, fScore\r\n *        - Insert/update in Open Set (O(log n))\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n */\r\nexport function astar(grid: Grid, startNode: Node, finishNode: Node): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Use Maps to track scores (avoid mutating Node objects in React state)\r\n  // Key: \"row-col\", Value: score\r\n  const gScore = new Map<string, number>();\r\n  const fScore = new Map<string, number>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScore.set(key, Infinity);\r\n      fScore.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScore.set(startKey, 0);\r\n  fScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n\r\n  // Open Set - min-heap priority queue sorted by fScore\r\n  const openSet = new MinHeap(\r\n    getKey,\r\n    (node: Node) => fScore.get(getKey(node)) ?? Infinity\r\n  );\r\n  openSet.insert(startNode);\r\n\r\n  while (!openSet.isEmpty()) {\r\n    // Extract node with lowest fScore - O(log n)\r\n    const current = openSet.extractMin()!;\r\n    const currentKey = getKey(current);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (current.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Check if we're trapped (no path exists)\r\n    const currentGScore = gScore.get(currentKey) ?? Infinity;\r\n    if (currentGScore === Infinity) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Calculate tentative gScore using neighbor's weight as traversal cost\r\n      // (1 = normal terrain, higher = heavier terrain like mud/hills)\r\n      const tentativeGScore = currentGScore + neighbor.weight;\r\n\r\n      // If this path is better than any previous one\r\n      const neighborGScore = gScore.get(neighborKey) ?? Infinity;\r\n      if (tentativeGScore < neighborGScore) {\r\n        // Update the path - this is the best path to this neighbor so far\r\n        neighbor.previousNode = current;\r\n        gScore.set(neighborKey, tentativeGScore);\r\n        fScore.set(\r\n          neighborKey,\r\n          tentativeGScore + manhattanDistance(neighbor, finishNode)\r\n        );\r\n\r\n        // Insert or update in open set - O(log n)\r\n        openSet.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Reuses the same logic as Dijkstra since both use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by astar)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nexport default astar;\r\n","/**\r\n * Breadth-First Search (BFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * BFS explores nodes layer by layer, guaranteeing the shortest path\r\n * in an unweighted graph (all edges have equal cost).\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n *\r\n * Uses an O(1) dequeue implementation for optimal performance.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// O(1) Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Simple queue with O(1) enqueue and dequeue operations.\r\n * Uses a head pointer instead of Array.shift() which is O(n).\r\n */\r\nclass Queue<T> {\r\n  private items: T[] = [];\r\n  private head: number = 0;\r\n\r\n  enqueue(item: T): void {\r\n    this.items.push(item);\r\n  }\r\n\r\n  dequeue(): T | undefined {\r\n    if (this.isEmpty()) return undefined;\r\n    const item = this.items[this.head];\r\n    this.head++;\r\n    // Periodically compact the array to prevent memory bloat\r\n    if (this.head > 1000 && this.head > this.items.length / 2) {\r\n      this.items = this.items.slice(this.head);\r\n      this.head = 0;\r\n    }\r\n    return item;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.head >= this.items.length;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.items.length - this.head;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// BFS Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Performs Breadth-First Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize a queue with the start node\r\n * 2. Mark start node as visited\r\n * 3. While queue is not empty:\r\n *    - Dequeue the first node (FIFO) - O(1)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall → skip\r\n *    - Get all unvisited neighbors (up, down, left, right)\r\n *    - For each neighbor:\r\n *      - Mark as visited\r\n *      - Set previousNode pointer\r\n *      - Enqueue the neighbor\r\n *      - Add to visitedNodesInOrder\r\n * 4. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Time Complexity: O(V + E) where V = vertices, E = edges\r\n * Space Complexity: O(V)\r\n */\r\nexport function bfs(grid: Grid, startNode: Node, finishNode: Node): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Queue for BFS - FIFO with O(1) operations\r\n  const queue = new Queue<Node>();\r\n\r\n  // Initialize: mark start as visited and enqueue\r\n  startNode.isVisited = true;\r\n  startNode.distance = 0;\r\n  queue.enqueue(startNode);\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  while (!queue.isEmpty()) {\r\n    // Dequeue the first node (FIFO) - O(1)\r\n    const currentNode = queue.dequeue()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Mark as visited\r\n      neighbor.isVisited = true;\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Set distance (optional for BFS, but useful for consistency)\r\n      neighbor.distance = currentNode.distance + 1;\r\n\r\n      // Enqueue the neighbor - O(1)\r\n      queue.enqueue(neighbor);\r\n\r\n      // Record visit order for animation\r\n      visitedNodesInOrder.push(neighbor);\r\n\r\n      // Early exit: if we just added the finish node, we can return\r\n      if (neighbor === finishNode) {\r\n        return visitedNodesInOrder;\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the shortest path.\r\n * (Identical to Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by bfs)\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default bfs;\r\n","/**\r\n * Depth-First Search (DFS) Algorithm Implementation\r\n * Phase D: Advanced Features\r\n *\r\n * DFS explores as far as possible along each branch before backtracking.\r\n * Unlike BFS, DFS does NOT guarantee the shortest path.\r\n *\r\n * This is a pure TypeScript implementation with no DOM/React dependencies.\r\n * Returns the order of visited nodes for animation purposes.\r\n */\r\n\r\nimport { Grid, Node } from '../../types';\r\n\r\n/**\r\n * Performs Depth-First Search to find a path (not necessarily shortest).\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps (Iterative):\r\n * 1. Initialize a stack with the start node\r\n * 2. While stack is not empty:\r\n *    - Pop the last node (LIFO)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If already visited → skip\r\n *    - Mark as visited and add to visitedNodesInOrder\r\n *    - Get all unvisited neighbors\r\n *    - For each neighbor:\r\n *      - Set previousNode pointer\r\n *      - Push to stack\r\n * 3. Return visitedNodesInOrder (may be incomplete if no path exists)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path (explores depth-first)\r\n * - Uses a Stack (LIFO) data structure\r\n * - Memory efficient for deep paths\r\n * - Creates a \"snake-like\" movement pattern\r\n * - Time Complexity: O(V + E) where V = vertices, E = edges\r\n */\r\nexport function dfs(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n\r\n  // Stack for DFS - LIFO (Last In, First Out)\r\n  const stack: Node[] = [];\r\n\r\n  // Initialize: push start node onto stack\r\n  stack.push(startNode);\r\n\r\n  while (stack.length > 0) {\r\n    // Pop the last node (LIFO)\r\n    const currentNode = stack.pop()!;\r\n\r\n    // Skip walls - they are not traversable\r\n    if (currentNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (currentNode.isVisited) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n\r\n    // Record visit order for animation\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get all unvisited neighbors\r\n    // Order: Up, Right, Down, Left\r\n    // Since stack is LIFO, we push in reverse order so Up is explored first\r\n    const neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      // Skip walls\r\n      if (neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      // Skip already visited\r\n      if (neighbor.isVisited) {\r\n        continue;\r\n      }\r\n\r\n      // Set previousNode for path reconstruction\r\n      neighbor.previousNode = currentNode;\r\n\r\n      // Push to stack\r\n      stack.push(neighbor);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n * (Identical to BFS/Dijkstra/A* since all use previousNode pointers)\r\n *\r\n * @param finishNode - The destination node (must have been reached by dfs)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: Returns nodes in order from START to FINISH (reversed during construction)\r\n * Warning: For DFS, this path is NOT necessarily the shortest!\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all unvisited, non-wall neighbors of a node.\r\n * Neighbors are the 4 adjacent cells (up, down, left, right).\r\n *\r\n * Order: Up, Right, Down, Left (reversed for stack to create consistent movement)\r\n * Since stack is LIFO, the last pushed neighbor is explored first.\r\n * We push Left, Down, Right, Up so that Up is explored first.\r\n */\r\nfunction getUnvisitedNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Push in reverse order for LIFO stack: Left, Down, Right, Up\r\n  // This makes DFS explore in order: Up, Right, Down, Left\r\n\r\n  // Left (pushed first, explored last)\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n  // Up (pushed last, explored first)\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n\r\n  // Filter to only unvisited neighbors\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nexport default dfs;\r\n","/**\r\n * Greedy Best-First Search Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Greedy Best-First Search is an informed search algorithm that selects\r\n * nodes based solely on their heuristic value (estimated distance to goal).\r\n *\r\n * Key Difference from A*:\r\n * - A* uses: fScore = gScore + hScore (actual distance + estimated remaining)\r\n * - Greedy uses: fScore = hScore only (ignores actual distance traveled)\r\n *\r\n * This makes Greedy faster but does NOT guarantee the shortest path.\r\n * It's useful when you want to find \"a\" path quickly, not necessarily the best one.\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n *\r\n * Note: Since this algorithm uses heuristics (needs to know target location),\r\n * it should be DISABLED in Hidden Target Mode.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private getKey: (node: Node) => string;\r\n  private getPriority: (node: Node) => number;\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  constructor(\r\n    getKey: (node: Node) => string,\r\n    getPriority: (node: Node) => number\r\n  ) {\r\n    this.getKey = getKey;\r\n    this.getPriority = getPriority;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Update existing node's position\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (\r\n        this.getPriority(this.heap[idx]) >=\r\n        this.getPriority(this.heap[parentIdx])\r\n      ) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.getPriority(this.heap[leftIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.getPriority(this.heap[rightIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Greedy Best-First Search Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides\r\n * the estimated distance to the goal.\r\n *\r\n * @param nodeA - Current node\r\n * @param nodeB - Target node (typically the finish node)\r\n * @returns The Manhattan distance between the two nodes\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Greedy Best-First Search to find a path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm Steps:\r\n * 1. Initialize priority = heuristic (distance to goal only)\r\n * 2. Add startNode to min-heap priority queue\r\n * 3. Loop while heap is not empty:\r\n *    - Extract node with lowest heuristic (closest to goal)\r\n *    - If node is finish → return visitedNodesInOrder\r\n *    - If node is wall or visited → skip\r\n *    - Mark as visited, add to visitedNodesInOrder\r\n *    - For each unvisited neighbor:\r\n *      - Set previousNode for path reconstruction\r\n *      - Calculate priority = heuristic only (no gScore!)\r\n *      - Add to heap\r\n * 4. Return visitedNodesInOrder (empty or partial if no path)\r\n *\r\n * Key Characteristics:\r\n * - Does NOT guarantee shortest path\r\n * - Very fast for simple mazes (beelines toward goal)\r\n * - Can get \"stuck\" in dead ends with complex mazes\r\n * - Explores far fewer nodes than BFS/Dijkstra in best case\r\n */\r\nexport function greedyBestFirst(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const visited = new Set<string>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n\r\n  // Store heuristic values for heap priority\r\n  const hScore = new Map<string, number>();\r\n\r\n  // Min-heap priority queue using heuristic only\r\n  const openSet = new MinHeap(\r\n    getKey,\r\n    (node: Node) => hScore.get(getKey(node)) ?? Infinity\r\n  );\r\n\r\n  // Initialize start node with heuristic only (no gScore)\r\n  const startKey = getKey(startNode);\r\n  hScore.set(startKey, manhattanDistance(startNode, finishNode));\r\n  openSet.insert(startNode);\r\n\r\n  while (!openSet.isEmpty()) {\r\n    const current = openSet.extractMin()!;\r\n    const currentKey = getKey(current);\r\n\r\n    // Skip walls - they are not traversable\r\n    if (current.isWall) {\r\n      continue;\r\n    }\r\n\r\n    // Skip already visited nodes\r\n    if (visited.has(currentKey)) {\r\n      continue;\r\n    }\r\n\r\n    // Mark as visited and record visit order\r\n    visited.add(currentKey);\r\n    current.isVisited = true;\r\n    visitedNodesInOrder.push(current);\r\n\r\n    // If we reached the finish, we're done!\r\n    if (current === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Explore neighbors\r\n    const neighbors = getNeighbors(current, grid);\r\n\r\n    for (const neighbor of neighbors) {\r\n      const neighborKey = getKey(neighbor);\r\n\r\n      // Skip walls and already visited nodes\r\n      if (neighbor.isWall || visited.has(neighborKey)) {\r\n        continue;\r\n      }\r\n\r\n      // Set the path pointer for backtracking\r\n      neighbor.previousNode = current;\r\n\r\n      // GREEDY: priority = heuristic ONLY (no gScore!)\r\n      // This is the key difference from A*\r\n      hScore.set(neighborKey, manhattanDistance(neighbor, finishNode));\r\n\r\n      // Add to open set\r\n      openSet.insert(neighbor);\r\n    }\r\n  }\r\n\r\n  // No path found - return visited nodes anyway for visualization\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Backtracks from finishNode to find the path.\r\n *\r\n * @param finishNode - The destination node (must have been reached by greedyBestFirst)\r\n * @returns Array of nodes representing the path from start to finish\r\n *\r\n * Note: This path is NOT guaranteed to be the shortest!\r\n * Returns nodes in order from START to FINISH (reversed during construction)\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Follow previousNode pointers back to start\r\n  while (currentNode !== null) {\r\n    // Add to beginning to build path from start → finish\r\n    nodesInPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInPathOrder;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions (not exported - internal use only)\r\n// ============================================================================\r\n\r\n/**\r\n * Gets all neighbors of a node (4-directional: up, down, left, right).\r\n * Does NOT filter by visited status - that's handled in the main loop.\r\n */\r\nfunction getNeighbors(node: Node, grid: Grid): Node[] {\r\n  const neighbors: Node[] = [];\r\n  const { row, col } = node;\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Up\r\n  if (row > 0) {\r\n    neighbors.push(grid[row - 1][col]);\r\n  }\r\n  // Down\r\n  if (row < numRows - 1) {\r\n    neighbors.push(grid[row + 1][col]);\r\n  }\r\n  // Left\r\n  if (col > 0) {\r\n    neighbors.push(grid[row][col - 1]);\r\n  }\r\n  // Right\r\n  if (col < numCols - 1) {\r\n    neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n","/**\r\n * Bidirectional BFS (Breadth-First Search) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional BFS searches from both the start and finish nodes simultaneously,\r\n * meeting somewhere in the middle. This can be significantly faster than\r\n * unidirectional BFS as it explores roughly half the search space.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path in unweighted graphs\r\n * - Explores from both ends simultaneously\r\n * - Meeting point detection when frontiers intersect\r\n * - Uses O(1) queue operations for optimal performance\r\n *\r\n * Time Complexity: O(V + E) with efficient queue\r\n * Space Complexity: O(V)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// O(1) Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Efficient FIFO Queue with O(1) enqueue and dequeue operations.\r\n * Uses a head pointer instead of Array.shift() to avoid O(n) operations.\r\n */\r\nclass Queue<T> {\r\n  private items: T[] = [];\r\n  private head: number = 0;\r\n\r\n  enqueue(item: T): void {\r\n    this.items.push(item);\r\n  }\r\n\r\n  dequeue(): T | undefined {\r\n    if (this.head >= this.items.length) return undefined;\r\n    const item = this.items[this.head];\r\n    this.head++;\r\n    // Compact when more than half the array is dead space\r\n    if (this.head > this.items.length / 2 && this.head > 100) {\r\n      this.items = this.items.slice(this.head);\r\n      this.head = 0;\r\n    }\r\n    return item;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.items.length - this.head;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.head >= this.items.length;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Bidirectional BFS Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Performs Bidirectional BFS to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited (alternating from both sides)\r\n */\r\nexport function bidirectionalBFS(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Parent maps for path reconstruction\r\n  const parentFromStart = new Map<string, Node | null>();\r\n  const parentFromFinish = new Map<string, Node | null>();\r\n\r\n  // Visited sets for each direction\r\n  const visitedFromStart = new Set<string>();\r\n  const visitedFromFinish = new Set<string>();\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // Initialize O(1) queues\r\n  const startQueue = new Queue<Node>();\r\n  const finishQueue = new Queue<Node>();\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  visitedFromStart.add(startKey);\r\n  parentFromStart.set(startKey, null);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n  startQueue.enqueue(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  visitedFromFinish.add(finishKey);\r\n  parentFromFinish.set(finishKey, null);\r\n  finishQueue.enqueue(finishNode);\r\n\r\n  // Track meeting point\r\n  let meetingKey: string | null = null;\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  // Main loop - alternate between expanding from start and finish\r\n  while (!startQueue.isEmpty() && !finishQueue.isEmpty()) {\r\n    // Expand from start side\r\n    if (!startQueue.isEmpty()) {\r\n      const currentNode = startQueue.dequeue()!;\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from start\r\n        if (visitedFromStart.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from start\r\n        visitedFromStart.add(neighborKey);\r\n        parentFromStart.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from finish - INTERSECTION!\r\n        if (visitedFromFinish.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        startQueue.enqueue(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n\r\n    // Expand from finish side\r\n    if (!finishQueue.isEmpty() && !meetingKey) {\r\n      const currentNode = finishQueue.dequeue()!;\r\n\r\n      // Add finish node to visited order on first expansion\r\n      if (currentNode === finishNode) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      for (const neighbor of getNeighbors(currentNode)) {\r\n        const neighborKey = getKey(neighbor);\r\n\r\n        // Skip if already visited from finish\r\n        if (visitedFromFinish.has(neighborKey)) continue;\r\n\r\n        // Mark as visited from finish\r\n        visitedFromFinish.add(neighborKey);\r\n        parentFromFinish.set(neighborKey, currentNode);\r\n        neighbor.isVisited = true;\r\n        visitedNodesInOrder.push(neighbor);\r\n\r\n        // Check if this node was visited from start - INTERSECTION!\r\n        if (visitedFromStart.has(neighborKey)) {\r\n          meetingKey = neighborKey;\r\n          break;\r\n        }\r\n\r\n        finishQueue.enqueue(neighbor);\r\n      }\r\n\r\n      if (meetingKey) break;\r\n    }\r\n  }\r\n\r\n  // Reconstruct path if meeting point found\r\n  if (meetingKey) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine and set up previousNode chain\r\n    const fullPath = [...pathFromStart, ...pathToFinish];\r\n    for (let i = 1; i < fullPath.length; i++) {\r\n      fullPath[i].previousNode = fullPath[i - 1];\r\n    }\r\n\r\n    // Mark finish as having a valid path\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalBFS.\r\n * Uses the previousNode chain set up during path reconstruction.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Bidirectional A* (A-Star) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Bidirectional A* combines the efficiency of A* heuristic search with\r\n * bidirectional search strategy. It searches from both start and finish\r\n * nodes simultaneously, using heuristics from both ends.\r\n *\r\n * Key Characteristics:\r\n * - Uses min-heap priority queues for O(log n) operations\r\n * - Two heuristics: startOpenSet → finishNode, finishOpenSet → startNode\r\n * - Meeting point detection when frontiers intersect\r\n * - Guarantees shortest path with consistent heuristics\r\n * - Correct early termination: μ ≤ min(topFStart, topFFinish)\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n * - insert: O(log n)\r\n * - extractMin: O(log n)\r\n * - peekMin: O(1)\r\n */\r\nclass MinHeap {\r\n  private heap: Node[] = [];\r\n  private getKey: (node: Node) => string;\r\n  private getPriority: (node: Node) => number;\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  constructor(\r\n    getKey: (node: Node) => string,\r\n    getPriority: (node: Node) => number\r\n  ) {\r\n    this.getKey = getKey;\r\n    this.getPriority = getPriority;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  peekMin(): Node | undefined {\r\n    return this.heap[0];\r\n  }\r\n\r\n  insert(node: Node): void {\r\n    const key = this.getKey(node);\r\n    if (this.positionMap.has(key)) {\r\n      // Update existing node's position (decrease key)\r\n      const idx = this.positionMap.get(key)!;\r\n      this.heap[idx] = node;\r\n      this.bubbleUp(idx);\r\n      this.bubbleDown(idx);\r\n    } else {\r\n      this.heap.push(node);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): Node | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const node = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(node));\r\n      return node;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (\r\n        this.getPriority(this.heap[idx]) >=\r\n        this.getPriority(this.heap[parentIdx])\r\n      ) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.getPriority(this.heap[leftIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.getPriority(this.heap[rightIdx]) <\r\n          this.getPriority(this.heap[smallest])\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Bidirectional A* Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n *\r\n * For 4-directional movement, Manhattan distance provides an\r\n * admissible and consistent heuristic.\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Performs Bidirectional A* algorithm to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n *\r\n * Algorithm:\r\n * 1. Initialize two min-heaps - one from start, one from finish\r\n * 2. Alternate expansions, tracking best meeting point\r\n * 3. Terminate when: μ ≤ min(topFStart, topFFinish)\r\n *    where μ = best path cost found so far\r\n * 4. Reconstruct path through meeting point\r\n */\r\nexport function bidirectionalAStar(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Helper to get node key\r\n  const getKey = (node: Node): string => `${node.row}-${node.col}`;\r\n  const getNodeFromKey = (key: string): Node => {\r\n    const [row, col] = key.split(\"-\").map(Number);\r\n    return grid[row][col];\r\n  };\r\n\r\n  // === START SIDE DATA STRUCTURES ===\r\n  const gScoreStart = new Map<string, number>();\r\n  const fScoreStart = new Map<string, number>();\r\n  const parentFromStart = new Map<string, Node | null>();\r\n  const visitedFromStart = new Set<string>();\r\n\r\n  // === FINISH SIDE DATA STRUCTURES ===\r\n  const gScoreFinish = new Map<string, number>();\r\n  const fScoreFinish = new Map<string, number>();\r\n  const parentFromFinish = new Map<string, Node | null>();\r\n  const visitedFromFinish = new Set<string>();\r\n\r\n  // Initialize all nodes with Infinity scores\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      const key = getKey(node);\r\n      gScoreStart.set(key, Infinity);\r\n      fScoreStart.set(key, Infinity);\r\n      gScoreFinish.set(key, Infinity);\r\n      fScoreFinish.set(key, Infinity);\r\n    }\r\n  }\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode);\r\n  gScoreStart.set(startKey, 0);\r\n  fScoreStart.set(startKey, manhattanDistance(startNode, finishNode));\r\n  parentFromStart.set(startKey, null);\r\n  visitedFromStart.add(startKey);\r\n  startNode.isVisited = true;\r\n  visitedNodesInOrder.push(startNode);\r\n\r\n  // Initialize finish node\r\n  const finishKey = getKey(finishNode);\r\n  gScoreFinish.set(finishKey, 0);\r\n  fScoreFinish.set(finishKey, manhattanDistance(finishNode, startNode));\r\n  parentFromFinish.set(finishKey, null);\r\n  visitedFromFinish.add(finishKey);\r\n\r\n  // Min-heap priority queues\r\n  const openSetStart = new MinHeap(\r\n    getKey,\r\n    (node: Node) => fScoreStart.get(getKey(node)) ?? Infinity\r\n  );\r\n  const openSetFinish = new MinHeap(\r\n    getKey,\r\n    (node: Node) => fScoreFinish.get(getKey(node)) ?? Infinity\r\n  );\r\n\r\n  openSetStart.insert(startNode);\r\n  openSetFinish.insert(finishNode);\r\n\r\n  // Track best meeting point\r\n  let meetingKey: string | null = null;\r\n  let bestPathCost = Infinity; // μ in the literature\r\n\r\n  /**\r\n   * Gets all non-wall neighbors of a node\r\n   */\r\n  const getNeighbors = (node: Node): Node[] => {\r\n    const neighbors: Node[] = [];\r\n    const { row, col } = node;\r\n\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < numRows - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < numCols - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter((n) => !n.isWall);\r\n  };\r\n\r\n  // Main loop - expand from the side with smaller minimum f-score\r\n  // This optimization reduces unnecessary exploration while maintaining correctness\r\n  while (!openSetStart.isEmpty() && !openSetFinish.isEmpty()) {\r\n    // === TERMINATION CHECK ===\r\n    // Standard bidirectional A* termination:\r\n    // Stop when μ ≤ min(top fScore from both sides)\r\n    const topFStart =\r\n      fScoreStart.get(getKey(openSetStart.peekMin()!)) ?? Infinity;\r\n    const topFFinish =\r\n      fScoreFinish.get(getKey(openSetFinish.peekMin()!)) ?? Infinity;\r\n\r\n    if (bestPathCost <= Math.min(topFStart, topFFinish)) {\r\n      break;\r\n    }\r\n\r\n    // === CHOOSE WHICH SIDE TO EXPAND ===\r\n    // Always expand from the side with smaller minimum f-score\r\n    // This balances the search and reduces total nodes explored\r\n    const expandFromStart = topFStart <= topFFinish;\r\n\r\n    if (expandFromStart) {\r\n      // === EXPAND FROM START SIDE ===\r\n      const current = openSetStart.extractMin()!;\r\n      const currentKey = getKey(current);\r\n\r\n      if (current.isWall) continue;\r\n\r\n      // Check for intersection with finish side\r\n      if (visitedFromFinish.has(currentKey)) {\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n        // Use neighbor's weight as traversal cost (1 = normal, higher = heavier terrain)\r\n        const tentativeGScore =\r\n          (gScoreStart.get(currentKey) ?? Infinity) + neighbor.weight;\r\n        const neighborGScore = gScoreStart.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          parentFromStart.set(neighborKey, current);\r\n          gScoreStart.set(neighborKey, tentativeGScore);\r\n          fScoreStart.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, finishNode)\r\n          );\r\n\r\n          openSetStart.insert(neighbor);\r\n\r\n          if (!visitedFromStart.has(neighborKey)) {\r\n            visitedFromStart.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check for better meeting point\r\n            if (visitedFromFinish.has(neighborKey)) {\r\n              const pathCost =\r\n                tentativeGScore + (gScoreFinish.get(neighborKey) ?? Infinity);\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // === EXPAND FROM FINISH SIDE ===\r\n      const current = openSetFinish.extractMin()!;\r\n      const currentKey = getKey(current);\r\n\r\n      if (current.isWall) continue;\r\n\r\n      // Add finish node to visited on first expansion\r\n      if (current === finishNode && !visitedNodesInOrder.includes(finishNode)) {\r\n        finishNode.isVisited = true;\r\n        visitedNodesInOrder.push(finishNode);\r\n      }\r\n\r\n      // Check for intersection with start side\r\n      if (visitedFromStart.has(currentKey)) {\r\n        const pathCost =\r\n          (gScoreStart.get(currentKey) ?? Infinity) +\r\n          (gScoreFinish.get(currentKey) ?? Infinity);\r\n        if (pathCost < bestPathCost) {\r\n          bestPathCost = pathCost;\r\n          meetingKey = currentKey;\r\n        }\r\n      }\r\n\r\n      // Process neighbors\r\n      for (const neighbor of getNeighbors(current)) {\r\n        const neighborKey = getKey(neighbor);\r\n        // Use neighbor's weight as traversal cost (1 = normal, higher = heavier terrain)\r\n        const tentativeGScore =\r\n          (gScoreFinish.get(currentKey) ?? Infinity) + neighbor.weight;\r\n        const neighborGScore = gScoreFinish.get(neighborKey) ?? Infinity;\r\n\r\n        if (tentativeGScore < neighborGScore) {\r\n          parentFromFinish.set(neighborKey, current);\r\n          gScoreFinish.set(neighborKey, tentativeGScore);\r\n          fScoreFinish.set(\r\n            neighborKey,\r\n            tentativeGScore + manhattanDistance(neighbor, startNode)\r\n          );\r\n\r\n          openSetFinish.insert(neighbor);\r\n\r\n          if (!visitedFromFinish.has(neighborKey)) {\r\n            visitedFromFinish.add(neighborKey);\r\n            neighbor.isVisited = true;\r\n            visitedNodesInOrder.push(neighbor);\r\n\r\n            // Check for better meeting point\r\n            if (visitedFromStart.has(neighborKey)) {\r\n              const pathCost =\r\n                (gScoreStart.get(neighborKey) ?? Infinity) + tentativeGScore;\r\n              if (pathCost < bestPathCost) {\r\n                bestPathCost = pathCost;\r\n                meetingKey = neighborKey;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reconstruct path through meeting point\r\n  if (meetingKey !== null) {\r\n    // Part 1: Path from start to meeting point\r\n    const pathFromStart: Node[] = [];\r\n    let currentKey: string | null = meetingKey;\r\n    while (currentKey !== null) {\r\n      pathFromStart.unshift(getNodeFromKey(currentKey));\r\n      const parent = parentFromStart.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Part 2: Path from meeting point to finish (excluding meeting point)\r\n    const pathToFinish: Node[] = [];\r\n    const meetingParentFromFinish = parentFromFinish.get(meetingKey);\r\n    currentKey = meetingParentFromFinish\r\n      ? getKey(meetingParentFromFinish)\r\n      : null;\r\n    while (currentKey !== null) {\r\n      pathToFinish.push(getNodeFromKey(currentKey));\r\n      const parent = parentFromFinish.get(currentKey);\r\n      currentKey = parent ? getKey(parent) : null;\r\n    }\r\n\r\n    // Combine and set up previousNode chain\r\n    const fullPath = [...pathFromStart, ...pathToFinish];\r\n    for (let i = 1; i < fullPath.length; i++) {\r\n      fullPath[i].previousNode = fullPath[i - 1];\r\n    }\r\n\r\n    finishNode.isVisited = true;\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by bidirectionalAStar.\r\n * Uses the previousNode chain set up during path reconstruction.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Jump Point Search (JPS) Algorithm Implementation\r\n * Phase F: Extensions & History\r\n *\r\n * Jump Point Search is an optimization over A* for uniform-cost grids.\r\n * It dramatically reduces the number of nodes that need to be examined\r\n * by \"jumping\" over intermediate nodes in straight lines and only\r\n * considering nodes that are \"forced neighbors\" or corner points.\r\n *\r\n * Key Characteristics:\r\n * - Guarantees shortest path (same as A*)\r\n * - Only works on uniform-cost grids (all edge weights equal)\r\n * - Exploits grid structure to skip intermediate nodes\r\n * - Typically 10-100x faster than A* in open spaces\r\n * - Falls back to A*-like behavior in dense obstacle environments\r\n *\r\n * Time Complexity: O((V + E) log V) with min-heap\r\n * Space Complexity: O(V)\r\n *\r\n * Note: This implementation is for 4-directional movement (cardinal only).\r\n * For 8-directional (with diagonals), the forced neighbor rules differ.\r\n */\r\n\r\nimport { Grid, Node } from \"../../types\";\r\n\r\n// ============================================================================\r\n// Min-Heap Priority Queue Implementation\r\n// ============================================================================\r\n\r\ninterface JumpPointEntry {\r\n  row: number;\r\n  col: number;\r\n  dirRow: number;\r\n  dirCol: number;\r\n  fScore: number;\r\n}\r\n\r\n/**\r\n * Binary Min-Heap for efficient priority queue operations.\r\n */\r\nclass MinHeap {\r\n  private heap: JumpPointEntry[] = [];\r\n  private positionMap: Map<string, number> = new Map();\r\n\r\n  private getKey(entry: JumpPointEntry): string {\r\n    return `${entry.row}-${entry.col}`;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  insert(entry: JumpPointEntry): void {\r\n    const key = this.getKey(entry);\r\n    if (this.positionMap.has(key)) {\r\n      const idx = this.positionMap.get(key)!;\r\n      if (entry.fScore < this.heap[idx].fScore) {\r\n        this.heap[idx] = entry;\r\n        this.bubbleUp(idx);\r\n        this.bubbleDown(idx);\r\n      }\r\n    } else {\r\n      this.heap.push(entry);\r\n      const idx = this.heap.length - 1;\r\n      this.positionMap.set(key, idx);\r\n      this.bubbleUp(idx);\r\n    }\r\n  }\r\n\r\n  extractMin(): JumpPointEntry | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) {\r\n      const entry = this.heap.pop()!;\r\n      this.positionMap.delete(this.getKey(entry));\r\n      return entry;\r\n    }\r\n\r\n    const min = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n    this.positionMap.delete(this.getKey(min));\r\n\r\n    if (this.heap.length > 0) {\r\n      this.heap[0] = last;\r\n      this.positionMap.set(this.getKey(last), 0);\r\n      this.bubbleDown(0);\r\n    }\r\n\r\n    return min;\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.positionMap.has(key);\r\n  }\r\n\r\n  private bubbleUp(idx: number): void {\r\n    while (idx > 0) {\r\n      const parentIdx = Math.floor((idx - 1) / 2);\r\n      if (this.heap[idx].fScore >= this.heap[parentIdx].fScore) {\r\n        break;\r\n      }\r\n      this.swap(idx, parentIdx);\r\n      idx = parentIdx;\r\n    }\r\n  }\r\n\r\n  private bubbleDown(idx: number): void {\r\n    const length = this.heap.length;\r\n    while (true) {\r\n      const leftIdx = 2 * idx + 1;\r\n      const rightIdx = 2 * idx + 2;\r\n      let smallest = idx;\r\n\r\n      if (\r\n        leftIdx < length &&\r\n        this.heap[leftIdx].fScore < this.heap[smallest].fScore\r\n      ) {\r\n        smallest = leftIdx;\r\n      }\r\n      if (\r\n        rightIdx < length &&\r\n        this.heap[rightIdx].fScore < this.heap[smallest].fScore\r\n      ) {\r\n        smallest = rightIdx;\r\n      }\r\n\r\n      if (smallest === idx) break;\r\n\r\n      this.swap(idx, smallest);\r\n      idx = smallest;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    const keyI = this.getKey(this.heap[i]);\r\n    const keyJ = this.getKey(this.heap[j]);\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n    this.positionMap.set(keyI, j);\r\n    this.positionMap.set(keyJ, i);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Jump Point Search Algorithm\r\n// ============================================================================\r\n\r\n/**\r\n * Manhattan Distance Heuristic\r\n */\r\nfunction manhattanDistance(nodeA: Node, nodeB: Node): number {\r\n  return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\r\n}\r\n\r\n/**\r\n * Direction vectors for 4-directional movement\r\n * [row delta, col delta]\r\n */\r\nconst DIRECTIONS: [number, number][] = [\r\n  [-1, 0], // Up\r\n  [1, 0], // Down\r\n  [0, -1], // Left\r\n  [0, 1], // Right\r\n];\r\n\r\n/**\r\n * Performs Jump Point Search to find the shortest path.\r\n *\r\n * @param grid - The 2D grid of nodes\r\n * @param startNode - The starting node\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes in the order they were visited\r\n */\r\nexport function jumpPointSearch(\r\n  grid: Grid,\r\n  startNode: Node,\r\n  finishNode: Node\r\n): Node[] {\r\n  const visitedNodesInOrder: Node[] = [];\r\n  const numRows = grid.length;\r\n  const numCols = grid[0].length;\r\n\r\n  // Helper to get node key\r\n  const getKey = (row: number, col: number): string => `${row}-${col}`;\r\n\r\n  // Check if a position is valid and not a wall\r\n  const isWalkable = (row: number, col: number): boolean => {\r\n    if (row < 0 || row >= numRows || col < 0 || col >= numCols) return false;\r\n    return !grid[row][col].isWall;\r\n  };\r\n\r\n  // Use Maps to track scores (lazy initialization)\r\n  const gScore = new Map<string, number>();\r\n  const cameFrom = new Map<string, string | null>();\r\n\r\n  // Initialize start node\r\n  const startKey = getKey(startNode.row, startNode.col);\r\n  gScore.set(startKey, 0);\r\n  cameFrom.set(startKey, null);\r\n\r\n  // Min-heap priority queue\r\n  const openSet = new MinHeap();\r\n\r\n  // Add start node with all directions (no parent direction)\r\n  openSet.insert({\r\n    row: startNode.row,\r\n    col: startNode.col,\r\n    dirRow: 0,\r\n    dirCol: 0,\r\n    fScore: manhattanDistance(startNode, finishNode),\r\n  });\r\n\r\n  /**\r\n   * Jump function - the core of JPS (iterative to avoid stack overflow)\r\n   * Jumps in a direction until it finds:\r\n   * 1. The goal node\r\n   * 2. A jump point (forced neighbor exists)\r\n   * 3. A wall or boundary (returns null)\r\n   */\r\n  const jump = (\r\n    startRow: number,\r\n    startCol: number,\r\n    dirRow: number,\r\n    dirCol: number\r\n  ): { row: number; col: number } | null => {\r\n    let row = startRow + dirRow;\r\n    let col = startCol + dirCol;\r\n\r\n    while (true) {\r\n      // Hit wall or boundary\r\n      if (!isWalkable(row, col)) {\r\n        return null;\r\n      }\r\n\r\n      // Found the goal!\r\n      if (row === finishNode.row && col === finishNode.col) {\r\n        return { row, col };\r\n      }\r\n\r\n      // Check for forced neighbors (4-directional rules)\r\n      // Horizontal movement (dirRow === 0)\r\n      if (dirRow === 0) {\r\n        if (\r\n          (!isWalkable(row - 1, col - dirCol) && isWalkable(row - 1, col)) ||\r\n          (!isWalkable(row + 1, col - dirCol) && isWalkable(row + 1, col))\r\n        ) {\r\n          return { row, col };\r\n        }\r\n      }\r\n\r\n      // Vertical movement (dirCol === 0)\r\n      if (dirCol === 0) {\r\n        if (\r\n          (!isWalkable(row - dirRow, col - 1) && isWalkable(row, col - 1)) ||\r\n          (!isWalkable(row - dirRow, col + 1) && isWalkable(row, col + 1))\r\n        ) {\r\n          return { row, col };\r\n        }\r\n      }\r\n\r\n      // Continue jumping in the same direction\r\n      row += dirRow;\r\n      col += dirCol;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Identify successors (jump points) from a node\r\n   */\r\n  const identifySuccessors = (\r\n    row: number,\r\n    col: number,\r\n    parentDirRow: number,\r\n    parentDirCol: number\r\n  ): { row: number; col: number }[] => {\r\n    const successors: { row: number; col: number }[] = [];\r\n\r\n    // Determine which directions to explore based on parent direction\r\n    let directionsToCheck: [number, number][];\r\n\r\n    if (parentDirRow === 0 && parentDirCol === 0) {\r\n      // Start node - check all directions\r\n      directionsToCheck = DIRECTIONS;\r\n    } else if (parentDirRow === 0) {\r\n      // Horizontal movement - continue horizontal + check perpendicular if forced\r\n      directionsToCheck = [[0, parentDirCol]];\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - 1, col - parentDirCol) &&\r\n        isWalkable(row - 1, col)\r\n      ) {\r\n        directionsToCheck.push([-1, 0]);\r\n      }\r\n      if (\r\n        !isWalkable(row + 1, col - parentDirCol) &&\r\n        isWalkable(row + 1, col)\r\n      ) {\r\n        directionsToCheck.push([1, 0]);\r\n      }\r\n    } else {\r\n      // Vertical movement - continue vertical + check perpendicular if forced\r\n      directionsToCheck = [[parentDirRow, 0]];\r\n\r\n      // Add perpendicular directions if forced neighbors exist\r\n      if (\r\n        !isWalkable(row - parentDirRow, col - 1) &&\r\n        isWalkable(row, col - 1)\r\n      ) {\r\n        directionsToCheck.push([0, -1]);\r\n      }\r\n      if (\r\n        !isWalkable(row - parentDirRow, col + 1) &&\r\n        isWalkable(row, col + 1)\r\n      ) {\r\n        directionsToCheck.push([0, 1]);\r\n      }\r\n    }\r\n\r\n    // Jump in each valid direction\r\n    for (const [dRow, dCol] of directionsToCheck) {\r\n      const jumpPoint = jump(row, col, dRow, dCol);\r\n      if (jumpPoint) {\r\n        successors.push(jumpPoint);\r\n      }\r\n    }\r\n\r\n    return successors;\r\n  };\r\n\r\n  // Main loop\r\n  while (!openSet.isEmpty()) {\r\n    const current = openSet.extractMin()!;\r\n    const currentKey = getKey(current.row, current.col);\r\n    const currentNode = grid[current.row][current.col];\r\n\r\n    // Skip if already visited\r\n    if (currentNode.isVisited) continue;\r\n\r\n    // Mark as visited\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // Found the goal!\r\n    if (current.row === finishNode.row && current.col === finishNode.col) {\r\n      // Reconstruct path using previousNode pointers\r\n      reconstructPath(grid, cameFrom, finishNode);\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    // Get successors (jump points)\r\n    const successors = identifySuccessors(\r\n      current.row,\r\n      current.col,\r\n      current.dirRow,\r\n      current.dirCol\r\n    );\r\n\r\n    for (const successor of successors) {\r\n      const successorKey = getKey(successor.row, successor.col);\r\n      const successorNode = grid[successor.row][successor.col];\r\n\r\n      if (successorNode.isVisited) continue;\r\n\r\n      // Calculate tentative gScore (actual distance, not just 1)\r\n      const tentativeGScore =\r\n        (gScore.get(currentKey) ?? Infinity) +\r\n        manhattanDistance(currentNode, successorNode);\r\n\r\n      if (tentativeGScore < (gScore.get(successorKey) ?? Infinity)) {\r\n        // Found a better path\r\n        cameFrom.set(successorKey, currentKey);\r\n        gScore.set(successorKey, tentativeGScore);\r\n\r\n        const fScoreValue =\r\n          tentativeGScore + manhattanDistance(successorNode, finishNode);\r\n\r\n        // Calculate direction from current to successor\r\n        const dirRow =\r\n          successor.row === current.row\r\n            ? 0\r\n            : successor.row > current.row\r\n            ? 1\r\n            : -1;\r\n        const dirCol =\r\n          successor.col === current.col\r\n            ? 0\r\n            : successor.col > current.col\r\n            ? 1\r\n            : -1;\r\n\r\n        openSet.insert({\r\n          row: successor.row,\r\n          col: successor.col,\r\n          dirRow,\r\n          dirCol,\r\n          fScore: fScoreValue,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // No path found\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n/**\r\n * Reconstructs the path by setting previousNode pointers\r\n * JPS jumps over nodes, so we need to fill in the gaps\r\n */\r\nfunction reconstructPath(\r\n  grid: Grid,\r\n  cameFrom: Map<string, string | null>,\r\n  finishNode: Node\r\n): void {\r\n  const path: Node[] = [];\r\n  let currentKey: string | null = `${finishNode.row}-${finishNode.col}`;\r\n\r\n  // Collect jump points from finish to start\r\n  const jumpPoints: Node[] = [];\r\n  while (currentKey !== null) {\r\n    const [row, col] = currentKey.split(\"-\").map(Number);\r\n    jumpPoints.unshift(grid[row][col]);\r\n    currentKey = cameFrom.get(currentKey) ?? null;\r\n  }\r\n\r\n  // Fill in intermediate nodes between jump points\r\n  for (let i = 0; i < jumpPoints.length - 1; i++) {\r\n    const from = jumpPoints[i];\r\n    const to = jumpPoints[i + 1];\r\n\r\n    // Add intermediate nodes\r\n    let currentRow = from.row;\r\n    let currentCol = from.col;\r\n\r\n    while (currentRow !== to.row || currentCol !== to.col) {\r\n      const node = grid[currentRow][currentCol];\r\n      if (path.length > 0) {\r\n        node.previousNode = path[path.length - 1];\r\n      }\r\n      path.push(node);\r\n\r\n      // Move towards target\r\n      if (currentRow < to.row) currentRow++;\r\n      else if (currentRow > to.row) currentRow--;\r\n      else if (currentCol < to.col) currentCol++;\r\n      else if (currentCol > to.col) currentCol--;\r\n    }\r\n  }\r\n\r\n  // Add the finish node\r\n  if (jumpPoints.length > 0) {\r\n    finishNode.previousNode = path.length > 0 ? path[path.length - 1] : null;\r\n    path.push(finishNode);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the shortest path found by Jump Point Search.\r\n *\r\n * @param finishNode - The destination node\r\n * @returns Array of nodes representing the shortest path from start to finish\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode: Node): Node[] {\r\n  const nodesInShortestPathOrder: Node[] = [];\r\n  let currentNode: Node | null = finishNode;\r\n\r\n  // Check if finish was actually reached\r\n  if (!finishNode.isVisited) {\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * Benchmark Web Worker\r\n * Industrial-Grade Isolated Timing System\r\n *\r\n * This worker runs in a completely separate thread from the UI,\r\n * guaranteeing zero interference from:\r\n * - DOM rendering\r\n * - React state updates\r\n * - User interactions (mouse, scroll, resize)\r\n * - Animation frames\r\n * - Garbage collection on main thread\r\n *\r\n * Uses adaptive sampling: keeps running until minDuration passes,\r\n * then calculates average time per operation.\r\n */\r\n\r\nimport { Grid, Node, AlgorithmType } from \"../types\";\r\n\r\n// === ALGORITHM IMPORTS ===\r\n// Import the raw algorithm functions directly\r\nimport { dijkstra } from \"../algorithms/pathfinding/dijkstra\";\r\nimport { astar } from \"../algorithms/pathfinding/astar\";\r\nimport { bfs } from \"../algorithms/pathfinding/bfs\";\r\nimport { dfs } from \"../algorithms/pathfinding/dfs\";\r\nimport { greedyBestFirst } from \"../algorithms/pathfinding/greedyBestFirst\";\r\nimport { bidirectionalBFS } from \"../algorithms/pathfinding/bidirectionalBFS\";\r\nimport { bidirectionalAStar } from \"../algorithms/pathfinding/bidirectionalAStar\";\r\nimport { jumpPointSearch } from \"../algorithms/pathfinding/jumpPointSearch\";\r\n\r\n// === TYPE DEFINITIONS ===\r\n\r\ninterface BenchmarkInput {\r\n  requestId: number; // Unique ID to match request with response\r\n  algorithmName: AlgorithmType;\r\n  gridData: SerializedGrid;\r\n  startPos: { row: number; col: number };\r\n  finishPos: { row: number; col: number };\r\n  minDuration: number; // Minimum benchmark duration in ms (e.g., 200)\r\n}\r\n\r\ninterface BenchmarkOutput {\r\n  avgTime: number; // Average time per execution in ms\r\n  iterations: number; // Number of iterations completed\r\n  opsPerSec: number; // Operations per second\r\n  totalTime: number; // Total benchmark duration\r\n}\r\n\r\n// Serialized grid format (no circular references)\r\ntype SerializedNode = {\r\n  row: number;\r\n  col: number;\r\n  isStart: boolean;\r\n  isFinish: boolean;\r\n  isWall: boolean;\r\n};\r\n\r\ntype SerializedGrid = SerializedNode[][];\r\n\r\n// === HELPER FUNCTIONS ===\r\n\r\n/**\r\n * Reconstructs a full Grid from serialized data\r\n * Creates fresh Node objects with all required properties\r\n */\r\nfunction deserializeGrid(serialized: SerializedGrid): Grid {\r\n  return serialized.map((row) =>\r\n    row.map((cell) => ({\r\n      row: cell.row,\r\n      col: cell.col,\r\n      isStart: cell.isStart,\r\n      isFinish: cell.isFinish,\r\n      isWall: cell.isWall,\r\n      isVisited: false,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n      weight: 1, // Default weight for benchmark grids\r\n    }))\r\n  );\r\n}\r\n\r\n/**\r\n * Creates a fresh deep copy of the grid for each benchmark iteration\r\n * Ensures no state pollution between runs\r\n */\r\nfunction cloneGridForIteration(grid: Grid): {\r\n  clonedGrid: Grid;\r\n  start: Node;\r\n  finish: Node;\r\n} {\r\n  const clonedGrid: Grid = grid.map((row) =>\r\n    row.map((node) => ({\r\n      ...node,\r\n      isVisited: false,\r\n      distance: Infinity,\r\n      previousNode: null,\r\n    }))\r\n  );\r\n\r\n  let start: Node | null = null;\r\n  let finish: Node | null = null;\r\n\r\n  for (const row of clonedGrid) {\r\n    for (const node of row) {\r\n      if (node.isStart) start = node;\r\n      if (node.isFinish) finish = node;\r\n    }\r\n  }\r\n\r\n  if (!start || !finish) {\r\n    throw new Error(\"Start or Finish node not found in grid\");\r\n  }\r\n\r\n  return { clonedGrid, start, finish };\r\n}\r\n\r\n/**\r\n * Runs the specified algorithm on a grid\r\n */\r\nfunction runAlgorithm(\r\n  algorithmName: AlgorithmType,\r\n  grid: Grid,\r\n  start: Node,\r\n  finish: Node\r\n): void {\r\n  switch (algorithmName) {\r\n    case AlgorithmType.DIJKSTRA:\r\n      dijkstra(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.ASTAR:\r\n      astar(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.BFS:\r\n      bfs(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.DFS:\r\n      dfs(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.GREEDY_BEST_FIRST:\r\n      greedyBestFirst(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.BIDIRECTIONAL_BFS:\r\n      bidirectionalBFS(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.BIDIRECTIONAL_ASTAR:\r\n      bidirectionalAStar(grid, start, finish);\r\n      break;\r\n    case AlgorithmType.JUMP_POINT_SEARCH:\r\n      jumpPointSearch(grid, start, finish);\r\n      break;\r\n    default:\r\n      dijkstra(grid, start, finish);\r\n  }\r\n}\r\n\r\n// === MAIN MESSAGE HANDLER ===\r\n\r\nself.onmessage = (event: MessageEvent<BenchmarkInput>) => {\r\n  const {\r\n    requestId,\r\n    algorithmName,\r\n    gridData,\r\n    startPos,\r\n    finishPos,\r\n    minDuration,\r\n  } = event.data;\r\n\r\n  try {\r\n    // === PHASE 1: DESERIALIZE ===\r\n    // Parse grid data (this overhead is NOT measured)\r\n    const baseGrid = deserializeGrid(gridData);\r\n\r\n    // Verify start/finish positions\r\n    if (\r\n      !baseGrid[startPos.row]?.[startPos.col]?.isStart ||\r\n      !baseGrid[finishPos.row]?.[finishPos.col]?.isFinish\r\n    ) {\r\n      throw new Error(\"Invalid start/finish positions\");\r\n    }\r\n\r\n    // === PHASE 2: WARM-UP ===\r\n    // Run 3 times to trigger JIT optimization\r\n    // These results are discarded\r\n    for (let i = 0; i < 3; i++) {\r\n      const { clonedGrid, start, finish } = cloneGridForIteration(baseGrid);\r\n      runAlgorithm(algorithmName, clonedGrid, start, finish);\r\n    }\r\n\r\n    // === PHASE 3: ADAPTIVE SAMPLING LOOP ===\r\n    // Keep running until minDuration has passed\r\n    let iterations = 0;\r\n    const startTime = performance.now();\r\n    let elapsed = 0;\r\n\r\n    while (elapsed < minDuration) {\r\n      // Create fresh grid for this iteration\r\n      const { clonedGrid, start, finish } = cloneGridForIteration(baseGrid);\r\n\r\n      // Run algorithm (only this is timed)\r\n      runAlgorithm(algorithmName, clonedGrid, start, finish);\r\n\r\n      iterations++;\r\n      elapsed = performance.now() - startTime;\r\n    }\r\n\r\n    // === PHASE 4: CALCULATE STATISTICS ===\r\n    const totalTime = elapsed;\r\n    const avgTime = totalTime / iterations;\r\n    const opsPerSec = 1000 / avgTime;\r\n\r\n    // === PHASE 5: RETURN RESULTS ===\r\n    const output: BenchmarkOutput = {\r\n      avgTime,\r\n      iterations,\r\n      opsPerSec,\r\n      totalTime,\r\n    };\r\n\r\n    self.postMessage({ success: true, data: output, requestId });\r\n  } catch (error) {\r\n    self.postMessage({\r\n      success: false,\r\n      error: error instanceof Error ? error.message : \"Unknown error\",\r\n      requestId,\r\n    });\r\n  }\r\n};\r\n\r\n// TypeScript requires this for module workers\r\nexport {};\r\n"],"names":["AlgorithmType","MinHeap$4","__publicField","node","key","idx","min","last","parentIdx","length","leftIdx","rightIdx","smallest","i","j","keyI","keyJ","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","visited","getKey","minHeap","MinHeap","closestNode","closestKey","neighbors","getUnvisitedNeighbors","neighbor","newDistance","row","col","numRows","numCols","MinHeap$3","getPriority","manhattanDistance","nodeA","nodeB","astar","gScore","fScore","startKey","openSet","current","currentKey","currentGScore","getNeighbors","neighborKey","tentativeGScore","neighborGScore","Queue$1","item","bfs","queue","Queue","currentNode","dfs","stack","MinHeap$2","greedyBestFirst","hScore","bidirectionalBFS","parentFromStart","parentFromFinish","visitedFromStart","visitedFromFinish","getNodeFromKey","startQueue","finishQueue","finishKey","meetingKey","n","pathFromStart","parent","pathToFinish","meetingParentFromFinish","fullPath","MinHeap$1","bidirectionalAStar","gScoreStart","fScoreStart","gScoreFinish","fScoreFinish","openSetStart","openSetFinish","bestPathCost","topFStart","topFFinish","pathCost","entry","DIRECTIONS","jumpPointSearch","isWalkable","cameFrom","jump","startRow","startCol","dirRow","dirCol","identifySuccessors","parentDirRow","parentDirCol","successors","directionsToCheck","dRow","dCol","jumpPoint","reconstructPath","successor","successorKey","successorNode","fScoreValue","path","jumpPoints","from","to","currentRow","currentCol","deserializeGrid","serialized","cell","cloneGridForIteration","clonedGrid","start","finish","runAlgorithm","algorithmName","event","requestId","gridData","startPos","finishPos","minDuration","baseGrid","_b","_a","_d","_c","iterations","startTime","elapsed","totalTime","avgTime","opsPerSec","output","error"],"mappings":"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"}